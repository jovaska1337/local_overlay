diff --git a/configure.ac b/configure.ac
index a519e63d7..e948b76f9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1101,24 +1101,50 @@ AM_CONDITIONAL([HAVE_BLUEZ], [test "x$HAVE_BLUEZ" = x1])
 
 ## Bluetooth Headset profiles backend ##
 
-AC_ARG_ENABLE([bluez5-ofono-headset],
-    AS_HELP_STRING([--disable-bluez5-ofono-headset],[Disable optional ofono headset backend support (Bluez 5)]))
-AS_IF([test "x$HAVE_BLUEZ_5" = "x1" && test "x$enable_bluez5_ofono_headset" != "xno"], HAVE_BLUEZ_5_OFONO_HEADSET=1,
-      HAVE_BLUEZ_5_OFONO_HEADSET=0)
-AC_SUBST(HAVE_BLUEZ_5_OFONO_HEADSET)
-AM_CONDITIONAL([HAVE_BLUEZ_5_OFONO_HEADSET], [test "x$HAVE_BLUEZ_5_OFONO_HEADSET" = x1])
-AS_IF([test "x$HAVE_BLUEZ_5_OFONO_HEADSET" = "x1"], AC_DEFINE([HAVE_BLUEZ_5_OFONO_HEADSET], 1, [Bluez 5 ofono headset backend enabled]))
-
-AC_ARG_ENABLE([bluez5-native-headset],
-    AS_HELP_STRING([--disable-bluez5-native-headset],[Disable optional native headset backend support (Bluez 5)]))
-AS_IF([test "x$HAVE_BLUEZ_5" = "x1" && test "x$enable_bluez5_native_headset" != "xno"],
-      [PKG_CHECK_MODULES(BLUEZ, [ bluez >= 4.101 ], HAVE_BLUEZ_5_NATIVE_HEADSET=1, HAVE_BLUEZ_5_NATIVE_HEADSET=0)],
-      HAVE_BLUEZ_5_NATIVE_HEADSET=0)
-AS_IF([test "x$enable_bluez5_native_headset" = "xyes" && test "x$HAVE_BLUEZ_5_NATIVE_HEADSET" = "x0"],
-      [AC_MSG_ERROR([*** BlueZ 5 native headset backend support not available (requires the libbluetooth headers)])])
-AC_SUBST(HAVE_BLUEZ_5_NATIVE_HEADSET)
-AM_CONDITIONAL([HAVE_BLUEZ_5_NATIVE_HEADSET], [test "x$HAVE_BLUEZ_5_NATIVE_HEADSET" = x1])
-AS_IF([test "x$HAVE_BLUEZ_5_NATIVE_HEADSET" = "x1"], AC_DEFINE([HAVE_BLUEZ_5_NATIVE_HEADSET], 1, [Bluez 5 native headset backend enabled]))
+AC_ARG_ENABLE([bluez5-legacy-hsp],
+    AS_HELP_STRING([--disable-bluez5-legacy-hsp],[Disable optional legacy HSP backend support (Bluez 5)]))
+AS_IF([test "x$HAVE_BLUEZ_5" = "x1" && test "x$enable_bluez5_legacy_hsp" != "xno"],
+      [PKG_CHECK_MODULES(BLUEZ, [ bluez >= 4.101 ], HAVE_BLUEZ_5_LEGACY_HSP=1, HAVE_BLUEZ_5_LEGACY_HSP=0)],
+      HAVE_BLUEZ_5_LEGACY_HSP=0)
+AS_IF([test "x$enable_bluez5_legacy_hsp" = "xyes" && test "x$HAVE_BLUEZ_5_LEGACY_HSP" = "x0"],
+      [AC_MSG_ERROR([*** BlueZ 5 legacy HSP backend support not available (requires the libbluetooth headers)])])
+AC_SUBST(HAVE_BLUEZ_5_LEGACY_HSP)
+AM_CONDITIONAL([HAVE_BLUEZ_5_LEGACY_HSP], [test "x$HAVE_BLUEZ_5_LEGACY_HSP" = x1])
+AS_IF([test "x$HAVE_BLUEZ_5_LEGACY_HSP" = "x1"], AC_DEFINE([HAVE_BLUEZ_5_LEGACY_HSP], 1, [Bluez 5 legacy HSP backend enabled]))
+
+#### Bluetooth A2DP aptX codec (optional) ###
+
+AC_ARG_ENABLE([aptx],
+    AS_HELP_STRING([--disable-aptx],[Disable optional bluetooth A2DP aptX and aptX HD codecs support (via libopenaptx)]))
+AC_ARG_VAR([OPENAPTX_CPPFLAGS], [C preprocessor flags for openaptx])
+AC_ARG_VAR([OPENAPTX_LDFLAGS], [linker flags for openaptx])
+
+CPPFLAGS_SAVE="$CPPFLAGS"
+LDFLAGS_SAVE="$LDFLAGS"
+LIBS_SAVE="$LIBS"
+
+CPPFLAGS="$CPPFLAGS $OPENAPTX_CPPFLAGS"
+LDFLAGS="$LDFLAGS $OPENAPTX_LDFLAGS"
+
+AS_IF([test "x$HAVE_BLUEZ_5" = "x1" && test "x$enable_aptx" != "xno"],
+    [AC_CHECK_HEADER([openaptx.h],
+        [AC_SEARCH_LIBS([aptx_init], [openaptx],
+            [HAVE_OPENAPTX=1; AS_IF([test "x$ac_cv_search_aptx_init" != "xnone required"], [OPENAPTX_LDFLAGS="$OPENAPTX_LDFLAGS $ac_cv_search_aptx_init"])],
+            [HAVE_OPENAPTX=0])],
+        [HAVE_OPENAPTX=0])])
+
+CPPFLAGS="$CPPFLAGS_SAVE"
+LDFLAGS="$LDFLAGS_SAVE"
+LIBS="$LIBS_SAVE"
+
+AS_IF([test "x$HAVE_BLUEZ_5" = "x1" && test "x$enable_aptx" = "xyes" && test "x$HAVE_OPENAPTX" = "x0"],
+    [AC_MSG_ERROR([*** libopenaptx from https://github.com/pali/libopenaptx not found])])
+
+AC_SUBST(OPENAPTX_CPPFLAGS)
+AC_SUBST(OPENAPTX_LDFLAGS)
+AC_SUBST(HAVE_OPENAPTX)
+AM_CONDITIONAL([HAVE_OPENAPTX], [test "x$HAVE_OPENAPTX" = "x1"])
+AS_IF([test "x$HAVE_OPENAPTX" = "x1"], AC_DEFINE([HAVE_OPENAPTX], 1, [Have openaptx codec library]))
 
 #### UDEV support (optional) ####
 
@@ -1639,8 +1665,8 @@ AS_IF([test "x$HAVE_SYSTEMD_DAEMON" = "x1"], ENABLE_SYSTEMD_DAEMON=yes, ENABLE_S
 AS_IF([test "x$HAVE_SYSTEMD_LOGIN" = "x1"], ENABLE_SYSTEMD_LOGIN=yes, ENABLE_SYSTEMD_LOGIN=no)
 AS_IF([test "x$HAVE_SYSTEMD_JOURNAL" = "x1"], ENABLE_SYSTEMD_JOURNAL=yes, ENABLE_SYSTEMD_JOURNAL=no)
 AS_IF([test "x$HAVE_BLUEZ_5" = "x1"], ENABLE_BLUEZ_5=yes, ENABLE_BLUEZ_5=no)
-AS_IF([test "x$HAVE_BLUEZ_5_OFONO_HEADSET" = "x1"], ENABLE_BLUEZ_5_OFONO_HEADSET=yes, ENABLE_BLUEZ_5_OFONO_HEADSET=no)
-AS_IF([test "x$HAVE_BLUEZ_5_NATIVE_HEADSET" = "x1"], ENABLE_BLUEZ_5_NATIVE_HEADSET=yes, ENABLE_BLUEZ_5_NATIVE_HEADSET=no)
+AS_IF([test "x$HAVE_BLUEZ_5_LEGACY_HSP" = "x1"], ENABLE_BLUEZ_5_LEGACY_HSP=yes, ENABLE_BLUEZ_5_LEGACY_HSP=no)
+AS_IF([test "x$HAVE_OPENAPTX" = "x1"], ENABLE_APTX=yes, ENABLE_APTX=no)
 AS_IF([test "x$HAVE_HAL_COMPAT" = "x1"], ENABLE_HAL_COMPAT=yes, ENABLE_HAL_COMPAT=no)
 AS_IF([test "x$HAVE_TCPWRAP" = "x1"], ENABLE_TCPWRAP=yes, ENABLE_TCPWRAP=no)
 AS_IF([test "x$HAVE_LIBSAMPLERATE" = "x1"], ENABLE_LIBSAMPLERATE="yes (DEPRECATED)", ENABLE_LIBSAMPLERATE=no)
@@ -1700,8 +1726,8 @@ echo "
     Enable LIRC:                   ${ENABLE_LIRC}
     Enable D-Bus:                  ${ENABLE_DBUS}
       Enable BlueZ 5:              ${ENABLE_BLUEZ_5}
-        Enable ofono headsets:     ${ENABLE_BLUEZ_5_OFONO_HEADSET}
-        Enable native headsets:    ${ENABLE_BLUEZ_5_NATIVE_HEADSET}
+        Enable legacy HSP backend: ${ENABLE_BLUEZ_5_LEGACY_HSP}
+        Enable aptX+aptXHD codecs: ${ENABLE_APTX}
     Enable udev:                   ${ENABLE_UDEV}
       Enable HAL->udev compat:     ${ENABLE_HAL_COMPAT}
     Enable systemd
diff --git a/meson.build b/meson.build
index 658eeee57..17006c4ad 100644
--- a/meson.build
+++ b/meson.build
@@ -635,14 +635,19 @@ if get_option('bluez5')
   cdata.set('HAVE_SBC', 1)
   cdata.set('HAVE_BLUEZ', 1)
   cdata.set('HAVE_BLUEZ_5', 1)
-  if get_option('bluez5-native-headset')
-    cdata.set('HAVE_BLUEZ_5_NATIVE_HEADSET', 1)
-  endif
-  if get_option('bluez5-ofono-headset')
-    cdata.set('HAVE_BLUEZ_5_OFONO_HEADSET', 1)
+  if get_option('bluez5-legacy-hsp')
+    cdata.set('HAVE_BLUEZ_5_LEGACY_HSP', 1)
   endif
 endif
 
+bluez5_aptx_feature = get_option('bluez5-aptx')
+bluez5_aptx_dep = cc.find_library('openaptx', required : bluez5_aptx_feature)
+bluez5_aptx = cc.has_header_symbol('openaptx.h', 'aptx_init', required : bluez5_aptx_feature) \
+    and bluez5_aptx_dep.found()
+if bluez5_aptx
+  cdata.set('HAVE_OPENAPTX', 1)
+endif
+
 fftw_dep = dependency('fftw3f', required : get_option('fftw'))
 if fftw_dep.found()
   cdata.set('HAVE_FFTW', 1)
@@ -824,8 +829,8 @@ summary = [
   'Enable LIRC:                   @0@'.format(lirc_dep.found()),
   'Enable D-Bus:                  @0@'.format(dbus_dep.found()),
   '  Enable BlueZ 5:              @0@'.format(get_option('bluez5')),
-  '    Enable native headsets:    @0@'.format(get_option('bluez5-native-headset')),
-  '    Enable  ofono headsets:    @0@'.format(get_option('bluez5-ofono-headset')),
+  '    Enable legacy HSP backend: @0@'.format(get_option('bluez5-legacy-hsp')),
+  '    Enable aptX+aptXHD codecs: @0@'.format(bluez5_aptx),
   'Enable udev:                   @0@'.format(udev_dep.found()),
   '  Enable HAL->udev compat:     @0@'.format(get_option('hal-compat')),
   'Enable systemd:                @0@'.format(libsystemd_dep.found()),
diff --git a/meson_options.txt b/meson_options.txt
index 824f24e08..874e01a8e 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -81,12 +81,12 @@ option('avahi',
 option('bluez5',
        type : 'boolean', value : 'true',
        description : 'Optional BlueZ 5 support')
-option('bluez5-native-headset',
-       type : 'boolean',
-       description : 'Optional native headset backend support (BlueZ 5)')
-option('bluez5-ofono-headset',
+option('bluez5-aptx',
+       type : 'feature', value : 'auto',
+       description : 'Optional aptX support')
+option('bluez5-legacy-hsp',
        type : 'boolean',
-       description : 'Optional oFono headset backend support (BlueZ 5)')
+       description : 'Optional legacy HSP backend support (BlueZ 5)')
 option('dbus',
        type : 'feature', value : 'auto',
        description : 'Optional D-Bus support')
diff --git a/src/Makefile.am b/src/Makefile.am
index bd764037b..b0244ba84 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -2158,20 +2158,19 @@ module_bluetooth_discover_la_CFLAGS = $(AM_CFLAGS) -DPA_MODULE_NAME=module_bluet
 
 # Bluetooth BlueZ 5 sink / source
 libbluez5_util_la_SOURCES = \
+		modules/bluetooth/hsphfpd-util.c \
+		modules/bluetooth/hsphfpd-util.h \
 		modules/bluetooth/bluez5-util.c \
 		modules/bluetooth/bluez5-util.h \
+		modules/bluetooth/legacy-hsp.h \
 		modules/bluetooth/a2dp-codec-api.h \
 		modules/bluetooth/a2dp-codec-util.c \
 		modules/bluetooth/a2dp-codec-util.h \
 		modules/bluetooth/a2dp-codecs.h \
 		modules/bluetooth/rtp.h
-if HAVE_BLUEZ_5_OFONO_HEADSET
+if HAVE_BLUEZ_5_LEGACY_HSP
 libbluez5_util_la_SOURCES += \
-		modules/bluetooth/backend-ofono.c
-endif
-if HAVE_BLUEZ_5_NATIVE_HEADSET
-libbluez5_util_la_SOURCES += \
-		modules/bluetooth/backend-native.c
+		modules/bluetooth/legacy-hsp.c
 endif
 
 libbluez5_util_la_LDFLAGS = -avoid-version
@@ -2183,6 +2182,14 @@ libbluez5_util_la_SOURCES += modules/bluetooth/a2dp-codec-sbc.c
 libbluez5_util_la_LIBADD += $(SBC_LIBS)
 libbluez5_util_la_CFLAGS += $(SBC_CFLAGS)
 
+libbluez5_util_la_SOURCES += modules/bluetooth/a2dp-codec-faststream.c
+
+if HAVE_OPENAPTX
+libbluez5_util_la_SOURCES += modules/bluetooth/a2dp-codec-aptx.c
+libbluez5_util_la_CPPFLAGS += $(OPENAPTX_CPPFLAGS)
+libbluez5_util_la_LDFLAGS += $(OPENAPTX_LDFLAGS)
+endif
+
 module_bluez5_discover_la_SOURCES = modules/bluetooth/module-bluez5-discover.c
 module_bluez5_discover_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_bluez5_discover_la_LIBADD = $(MODULE_LIBADD) $(DBUS_LIBS) libbluez5-util.la
diff --git a/src/daemon/default.pa.in b/src/daemon/default.pa.in
index 030334f36..8498f7e55 100755
--- a/src/daemon/default.pa.in
+++ b/src/daemon/default.pa.in
@@ -78,6 +78,8 @@ load-module module-jackdbus-detect channels=2
 ifelse(@HAVE_BLUEZ@, 1, [dnl
 ### Automatically load driver modules for Bluetooth hardware
 .ifexists module-bluetooth-policy@PA_SOEXT@
+# Uncomment next line to enable switching between headset/handsfree head unit and a2dp sink profiles based on heuristic (by default is is based on media.role=phone)
+#load-module module-bluetooth-policy auto_switch=2
 load-module module-bluetooth-policy
 .endif
 
diff --git a/src/modules/bluetooth/a2dp-codec-api.h b/src/modules/bluetooth/a2dp-codec-api.h
index a3123f4ca..6ee722e37 100644
--- a/src/modules/bluetooth/a2dp-codec-api.h
+++ b/src/modules/bluetooth/a2dp-codec-api.h
@@ -24,11 +24,6 @@
 
 #define MAX_A2DP_CAPS_SIZE 254
 
-typedef struct pa_a2dp_codec_capabilities {
-    uint8_t size;
-    uint8_t buffer[]; /* max size is 254 bytes */
-} pa_a2dp_codec_capabilities;
-
 typedef struct pa_a2dp_codec_id {
     uint8_t codec_id;
     uint32_t vendor_id;
@@ -51,11 +46,17 @@ typedef struct pa_a2dp_codec {
     /* Returns true if codec accepts capabilities, for_encoding is true when
      * capabilities are used for encoding */
     bool (*can_accept_capabilities)(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding);
-    /* Choose remote endpoint based on capabilities from hash map
-     * (const char *endpoint -> const pa_a2dp_codec_capabilities *capability)
-     * and returns corresponding endpoint key (or NULL when there is no valid),
-     * for_encoder is true when capabilities hash map is used for encoding */
-    const char *(*choose_remote_endpoint)(const pa_hashmap *capabilities_hashmap, const pa_sample_spec *default_sample_spec, bool for_encoding);
+    /* Comparator function for sorting endpoints, based on endpoint capabilities
+     * and default sample spec, this function should return:
+     * -1 if first endpoint is preferred;
+     *  1 if second endpoint is preferred;
+     *  0 if both endpoints have same priority;
+     * for_encoding is true when endpoints are used for encoding,
+     * only endpoints which passed can_accept_capabilities() are compared,
+     * remote endpoints are tried from most preferred to less preferred,
+     * endpoint which better fits for default sample spec should be more
+     * preferred than other endpoints */
+    int (*cmp_endpoints)(const uint8_t *capabilities1_buffer, uint8_t capabilities1_size, const uint8_t *capabilities2_buffer, uint8_t capabilities2_size, const pa_sample_spec *default_sample_spec, bool for_encoding);
     /* Fill codec capabilities, returns size of filled buffer */
     uint8_t (*fill_capabilities)(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]);
     /* Validate codec configuration, returns true on success */
diff --git a/src/modules/bluetooth/a2dp-codec-aptx.c b/src/modules/bluetooth/a2dp-codec-aptx.c
new file mode 100644
index 000000000..746af39c7
--- /dev/null
+++ b/src/modules/bluetooth/a2dp-codec-aptx.c
@@ -0,0 +1,556 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2018-2019 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulsecore/log.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/once.h>
+#include <pulse/sample.h>
+
+#include <arpa/inet.h>
+
+#include <openaptx.h>
+
+#include "a2dp-codecs.h"
+#include "a2dp-codec-api.h"
+#include "rtp.h"
+
+struct aptx_hd_info {
+    struct aptx_context *aptx_c;
+    uint16_t seq_num;
+};
+
+static bool can_accept_capabilities_common(const a2dp_aptx_t *capabilities, uint32_t vendor_id, uint16_t codec_id) {
+    if (A2DP_GET_VENDOR_ID(capabilities->info) != vendor_id || A2DP_GET_CODEC_ID(capabilities->info) != codec_id)
+        return false;
+
+    if (!(capabilities->frequency & (APTX_SAMPLING_FREQ_16000 | APTX_SAMPLING_FREQ_32000 |
+                                     APTX_SAMPLING_FREQ_44100 | APTX_SAMPLING_FREQ_48000)))
+        return false;
+
+    if (!(capabilities->channel_mode & APTX_CHANNEL_MODE_STEREO))
+        return false;
+
+    return true;
+}
+
+static bool can_accept_capabilities(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    const a2dp_aptx_t *capabilities = (const a2dp_aptx_t *) capabilities_buffer;
+
+    if (capabilities_size != sizeof(*capabilities))
+        return false;
+
+    return can_accept_capabilities_common(capabilities, APTX_VENDOR_ID, APTX_CODEC_ID);
+}
+
+static bool can_accept_capabilities_hd(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    const a2dp_aptx_hd_t *capabilities = (const a2dp_aptx_hd_t *) capabilities_buffer;
+
+    if (capabilities_size != sizeof(*capabilities))
+        return false;
+
+    return can_accept_capabilities_common(&capabilities->aptx, APTX_HD_VENDOR_ID, APTX_HD_CODEC_ID);
+}
+
+static int cmp_endpoints_common(const a2dp_aptx_t *capabilities1, const a2dp_aptx_t *capabilities2, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    uint32_t freq1 = 0;
+    uint32_t freq2 = 0;
+    int i;
+
+    static const struct {
+        uint32_t rate;
+        uint8_t cap;
+    } freq_table[] = {
+        { 16000U, APTX_SAMPLING_FREQ_16000 },
+        { 32000U, APTX_SAMPLING_FREQ_32000 },
+        { 44100U, APTX_SAMPLING_FREQ_44100 },
+        { 48000U, APTX_SAMPLING_FREQ_48000 }
+    };
+
+    /* Find the lowest freq that is at least as high as the requested sampling rate */
+    for (i = 0; (unsigned)i < PA_ELEMENTSOF(freq_table); i++) {
+        if (!freq1 && freq_table[i].rate >= default_sample_spec->rate && (capabilities1->frequency & freq_table[i].cap))
+            freq1 = freq_table[i].rate;
+        if (!freq2 && freq_table[i].rate >= default_sample_spec->rate && (capabilities2->frequency & freq_table[i].cap))
+            freq2 = freq_table[i].rate;
+        if (freq1 && freq2)
+            break;
+    }
+
+    /* Prefer endpoint which frequency is near to default sample rate */
+    if (freq1 && freq2) {
+        if (freq1 < freq2)
+            return -1;
+        if (freq1 > freq2)
+            return 1;
+    } else if (freq1) {
+        return -1;
+    } else if (freq2) {
+        return 1;
+    } else {
+        /* Both endpoints support only frequencies lower than requested sampling rate, therefore prefer endpoint with higher supported frequency */
+        for (i = PA_ELEMENTSOF(freq_table)-1; i >= 0; i--) {
+            if (!freq1 && (capabilities1->frequency & freq_table[i].cap))
+                freq1 = freq_table[i].rate;
+            if (!freq2 && (capabilities2->frequency & freq_table[i].cap))
+                freq2 = freq_table[i].rate;
+            if (freq1 && freq2)
+                break;
+        }
+        pa_assert(i >= 0);
+
+        if (freq1 > freq2)
+            return -1;
+        if (freq1 < freq2)
+            return 1;
+    }
+
+    return 0;
+}
+
+static int cmp_endpoints(const uint8_t *capabilities1_buffer, uint8_t capabilities1_size, const uint8_t *capabilities2_buffer, uint8_t capabilities2_size, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    pa_assert(capabilities1_size == sizeof(a2dp_aptx_t));
+    pa_assert(capabilities2_size == sizeof(a2dp_aptx_t));
+    return cmp_endpoints_common((const a2dp_aptx_t *)capabilities1_buffer, (const a2dp_aptx_t *)capabilities2_buffer, default_sample_spec, for_encoding);
+}
+
+static int cmp_endpoints_hd(const uint8_t *capabilities1_buffer, uint8_t capabilities1_size, const uint8_t *capabilities2_buffer, uint8_t capabilities2_size, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    pa_assert(capabilities1_size == sizeof(a2dp_aptx_hd_t));
+    pa_assert(capabilities2_size == sizeof(a2dp_aptx_hd_t));
+    return cmp_endpoints_common(&((const a2dp_aptx_hd_t *)capabilities1_buffer)->aptx, &((const a2dp_aptx_hd_t *)capabilities2_buffer)->aptx, default_sample_spec, for_encoding);
+}
+
+static void fill_capabilities_common(a2dp_aptx_t *capabilities, uint32_t vendor_id, uint16_t codec_id) {
+    capabilities->info = A2DP_SET_VENDOR_ID_CODEC_ID(vendor_id, codec_id);
+    capabilities->channel_mode = APTX_CHANNEL_MODE_STEREO;
+    capabilities->frequency = APTX_SAMPLING_FREQ_16000 | APTX_SAMPLING_FREQ_32000 |
+                              APTX_SAMPLING_FREQ_44100 | APTX_SAMPLING_FREQ_48000;
+}
+
+static uint8_t fill_capabilities(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_aptx_t *capabilities = (a2dp_aptx_t *) capabilities_buffer;
+
+    pa_zero(*capabilities);
+    fill_capabilities_common(capabilities, APTX_VENDOR_ID, APTX_CODEC_ID);
+    return sizeof(*capabilities);
+}
+
+static uint8_t fill_capabilities_hd(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_aptx_hd_t *capabilities = (a2dp_aptx_hd_t *) capabilities_buffer;
+
+    pa_zero(*capabilities);
+    fill_capabilities_common(&capabilities->aptx, APTX_HD_VENDOR_ID, APTX_HD_CODEC_ID);
+    return sizeof(*capabilities);
+}
+
+static bool is_configuration_valid_common(const a2dp_aptx_t *config, uint32_t vendor_id, uint16_t codec_id) {
+    if (A2DP_GET_VENDOR_ID(config->info) != vendor_id || A2DP_GET_CODEC_ID(config->info) != codec_id) {
+        pa_log_error("Invalid vendor codec information in configuration");
+        return false;
+    }
+
+    if (config->frequency != APTX_SAMPLING_FREQ_16000 && config->frequency != APTX_SAMPLING_FREQ_32000 &&
+        config->frequency != APTX_SAMPLING_FREQ_44100 && config->frequency != APTX_SAMPLING_FREQ_48000) {
+        pa_log_error("Invalid sampling frequency in configuration");
+        return false;
+    }
+
+    if (config->channel_mode != APTX_CHANNEL_MODE_STEREO) {
+        pa_log_error("Invalid channel mode in configuration");
+        return false;
+    }
+
+    return true;
+}
+
+static bool is_configuration_valid(const uint8_t *config_buffer, uint8_t config_size) {
+    const a2dp_aptx_t *config = (const a2dp_aptx_t *) config_buffer;
+
+    if (config_size != sizeof(*config)) {
+        pa_log_error("Invalid size of config buffer");
+        return false;
+    }
+
+    return is_configuration_valid_common(config, APTX_VENDOR_ID, APTX_CODEC_ID);
+}
+
+static bool is_configuration_valid_hd(const uint8_t *config_buffer, uint8_t config_size) {
+    const a2dp_aptx_hd_t *config = (const a2dp_aptx_hd_t *) config_buffer;
+
+    if (config_size != sizeof(*config)) {
+        pa_log_error("Invalid size of config buffer");
+        return false;
+    }
+
+    return is_configuration_valid_common(&config->aptx, APTX_HD_VENDOR_ID, APTX_HD_CODEC_ID);
+}
+
+static int fill_preferred_configuration_common(const pa_sample_spec *default_sample_spec, const a2dp_aptx_t *capabilities, a2dp_aptx_t *config, uint32_t vendor_id, uint16_t codec_id) {
+    int i;
+
+    static const struct {
+        uint32_t rate;
+        uint8_t cap;
+    } freq_table[] = {
+        { 16000U, APTX_SAMPLING_FREQ_16000 },
+        { 32000U, APTX_SAMPLING_FREQ_32000 },
+        { 44100U, APTX_SAMPLING_FREQ_44100 },
+        { 48000U, APTX_SAMPLING_FREQ_48000 }
+    };
+
+    if (A2DP_GET_VENDOR_ID(capabilities->info) != vendor_id || A2DP_GET_CODEC_ID(capabilities->info) != codec_id) {
+        pa_log_error("No supported vendor codec information");
+        return -1;
+    }
+
+    config->info = A2DP_SET_VENDOR_ID_CODEC_ID(vendor_id, codec_id);
+
+    if (!(capabilities->channel_mode & APTX_CHANNEL_MODE_STEREO)) {
+        pa_log_error("No supported channel modes");
+        return -1;
+    }
+
+    config->channel_mode = APTX_CHANNEL_MODE_STEREO;
+
+    /* Find the lowest freq that is at least as high as the requested sampling rate */
+    for (i = 0; (unsigned) i < PA_ELEMENTSOF(freq_table); i++) {
+        if (freq_table[i].rate >= default_sample_spec->rate && (capabilities->frequency & freq_table[i].cap)) {
+            config->frequency = freq_table[i].cap;
+            break;
+        }
+    }
+
+    if ((unsigned) i == PA_ELEMENTSOF(freq_table)) {
+        for (--i; i >= 0; i--) {
+            if (capabilities->frequency & freq_table[i].cap) {
+                config->frequency = freq_table[i].cap;
+                break;
+            }
+        }
+
+        if (i < 0) {
+            pa_log_error("Not suitable sample rate");
+            return false;
+        }
+    }
+
+    return 0;
+}
+
+static uint8_t fill_preferred_configuration(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_aptx_t *config = (a2dp_aptx_t *) config_buffer;
+    const a2dp_aptx_t *capabilities = (const a2dp_aptx_t *) capabilities_buffer;
+
+    if (capabilities_size != sizeof(*capabilities)) {
+        pa_log_error("Invalid size of capabilities buffer");
+        return 0;
+    }
+
+    pa_zero(*config);
+
+    if (fill_preferred_configuration_common(default_sample_spec, capabilities, config, APTX_VENDOR_ID, APTX_CODEC_ID) < 0)
+        return 0;
+
+    return sizeof(*config);
+}
+
+static uint8_t fill_preferred_configuration_hd(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_aptx_hd_t *config = (a2dp_aptx_hd_t *) config_buffer;
+    const a2dp_aptx_hd_t *capabilities = (const a2dp_aptx_hd_t *) capabilities_buffer;
+
+    if (capabilities_size != sizeof(*capabilities)) {
+        pa_log_error("Invalid size of capabilities buffer");
+        return 0;
+    }
+
+    pa_zero(*config);
+
+    if (fill_preferred_configuration_common(default_sample_spec, &capabilities->aptx, &config->aptx, APTX_HD_VENDOR_ID, APTX_HD_CODEC_ID) < 0)
+        return 0;
+
+    return sizeof(*config);
+}
+
+static void *init_common(const a2dp_aptx_t *config, pa_sample_spec *sample_spec, int hd) {
+    struct aptx_context *aptx_c;
+
+    aptx_c = aptx_init(hd);
+    if (!aptx_c) {
+        pa_log_error("libopenaptx initialization failed");
+        return NULL;
+    }
+
+    sample_spec->format = PA_SAMPLE_S24LE;
+
+    switch (config->frequency) {
+        case APTX_SAMPLING_FREQ_16000:
+            sample_spec->rate = 16000U;
+            break;
+        case APTX_SAMPLING_FREQ_32000:
+            sample_spec->rate = 32000U;
+            break;
+        case APTX_SAMPLING_FREQ_44100:
+            sample_spec->rate = 44100U;
+            break;
+        case APTX_SAMPLING_FREQ_48000:
+            sample_spec->rate = 48000U;
+            break;
+        default:
+            pa_assert_not_reached();
+    }
+
+    switch (config->channel_mode) {
+        case APTX_CHANNEL_MODE_STEREO:
+            sample_spec->channels = 2;
+            break;
+        default:
+            pa_assert_not_reached();
+    }
+
+    PA_ONCE_BEGIN {
+#if OPENAPTX_MAJOR == 0 && OPENAPTX_MINOR == 0 && OPENAPTX_PATCH == 0
+        /* libopenaptx version 0.0.0 does not export version global variables */
+        pa_log_debug("Using aptX codec implementation: libopenaptx from https://github.com/pali/libopenaptx");
+#else
+        pa_log_debug("Using aptX codec implementation: libopenaptx %d.%d.%d from https://github.com/pali/libopenaptx", aptx_major, aptx_minor, aptx_patch);
+#endif
+    } PA_ONCE_END;
+
+    return aptx_c;
+}
+
+static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec) {
+    const a2dp_aptx_t *config = (const a2dp_aptx_t *) config_buffer;
+
+    pa_assert(config_size == sizeof(*config));
+    pa_assert(!for_backchannel);
+
+    return init_common(config, sample_spec, 0);
+}
+
+static void *init_hd(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec) {
+    struct aptx_hd_info *aptx_hd_info;
+    const a2dp_aptx_hd_t *config = (const a2dp_aptx_hd_t *) config_buffer;
+
+    pa_assert(config_size == sizeof(*config));
+    pa_assert(!for_backchannel);
+
+    aptx_hd_info = pa_xnew0(struct aptx_hd_info, 1);
+
+    aptx_hd_info->aptx_c = init_common(&config->aptx, sample_spec, 1);
+    if (!aptx_hd_info->aptx_c) {
+        pa_xfree(aptx_hd_info);
+        return NULL;
+    }
+
+    return aptx_hd_info;
+}
+
+static void deinit(void *codec_info) {
+    struct aptx_context *aptx_c = (struct aptx_context *) codec_info;
+
+    aptx_finish(aptx_c);
+}
+
+static void deinit_hd(void *codec_info) {
+    struct aptx_hd_info *aptx_hd_info = (struct aptx_hd_info *) codec_info;
+
+    deinit(aptx_hd_info->aptx_c);
+    pa_xfree(aptx_hd_info);
+}
+
+static int reset(void *codec_info) {
+    struct aptx_context *aptx_c = (struct aptx_context *) codec_info;
+
+    aptx_reset(aptx_c);
+
+#if OPENAPTX_MAJOR == 0 && OPENAPTX_MINOR >= 2
+    aptx_decode_sync_finish(aptx_c);
+#endif
+
+    return 0;
+}
+
+static int reset_hd(void *codec_info) {
+    struct aptx_hd_info *aptx_hd_info = (struct aptx_hd_info *) codec_info;
+
+    reset(aptx_hd_info->aptx_c);
+    aptx_hd_info->seq_num = 0;
+    return 0;
+}
+
+static size_t get_read_block_size(void *codec_info, size_t link_mtu) {
+    /* one aptX sample is 4 bytes long and decompress to four stereo 24 bit samples */
+    size_t frame_count = (link_mtu / 4);
+
+    /* due to synchronization support, libopenaptx may decode one additional frame */
+    return (frame_count + 1) * 3 * 2 * 4;
+}
+
+static size_t get_write_block_size(void *codec_info, size_t link_mtu) {
+    /* one aptX sample is 4 bytes long and decompress to four stereo 24 bit samples */
+    size_t frame_count = (link_mtu / 4);
+
+    return frame_count * 3 * 2 * 4;
+}
+
+static size_t get_read_block_size_hd(void *codec_info, size_t link_mtu) {
+    /* one aptX HD sample is 6 bytes long and decompress to four stereo 24 bit samples */
+    size_t rtp_size = sizeof(struct rtp_header);
+    size_t frame_count = (link_mtu - rtp_size) / 6;
+
+    /* due to synchronization support, libopenaptx may decode one additional frame */
+    return (frame_count + 1) * 3 * 2 * 4;
+}
+
+static size_t get_write_block_size_hd(void *codec_info, size_t link_mtu) {
+    /* one aptX HD sample is 6 bytes long and decompress to four stereo 24 bit samples */
+    size_t rtp_size = sizeof(struct rtp_header);
+    size_t frame_count = (link_mtu - rtp_size) / 6;
+
+    return frame_count * 3 * 2 * 4;
+}
+
+static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
+    return 0;
+}
+
+static size_t encode_buffer(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct aptx_context *aptx_c = (struct aptx_context *) codec_info;
+    size_t written;
+
+    *processed = aptx_encode(aptx_c, input_buffer, input_size, output_buffer, output_size, &written);
+    if (PA_UNLIKELY(*processed == 0 || *processed != input_size))
+        pa_log_error("aptX encoding error");
+
+    return written;
+}
+
+static size_t encode_buffer_hd(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct aptx_hd_info *aptx_hd_info = (struct aptx_hd_info *) codec_info;
+    struct rtp_header *header;
+    size_t written;
+
+    if (PA_UNLIKELY(output_size < sizeof(*header))) {
+        *processed = 0;
+        return 0;
+    }
+
+    written = encode_buffer(aptx_hd_info->aptx_c, timestamp, input_buffer, input_size, output_buffer + sizeof(*header), output_size - sizeof(*header), processed);
+
+    if (PA_LIKELY(written > 0)) {
+        header = (struct rtp_header *) output_buffer;
+        pa_zero(*header);
+        header->v = 2;
+        header->pt = 96;
+        header->sequence_number = htons(aptx_hd_info->seq_num++);
+        header->timestamp = htonl(timestamp);
+        header->ssrc = htonl(1);
+        written += sizeof(*header);
+    }
+
+    return written;
+}
+
+static size_t decode_buffer(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct aptx_context *aptx_c = (struct aptx_context *) codec_info;
+    size_t written;
+
+#if OPENAPTX_MAJOR == 0 && OPENAPTX_MINOR >= 2
+    int synced;
+    size_t dropped;
+
+    *processed = aptx_decode_sync(aptx_c, input_buffer, input_size, output_buffer, output_size, &written, &synced, &dropped);
+    if (!synced)
+        pa_log_warn("aptX decoding is failing");
+    if (dropped)
+        pa_log_warn("aptX decoder dropped %lu bytes", dropped);
+#else
+    *processed = aptx_decode(aptx_c, input_buffer, input_size, output_buffer, output_size, &written);
+#endif
+
+    /* Due to aptX latency, aptx_decode starts filling output buffer after 90 input samples.
+     * If input buffer contains less than 90 samples, aptx_decode returns zero (=no output)
+     * but set *processed to non zero as input samples were processed. So do not check for
+     * return value of aptx_decode, zero is valid. Decoding error is indicating by fact that
+     * not all input samples were processed. */
+    if (PA_UNLIKELY(*processed != input_size))
+        pa_log_error("aptX decoding error");
+
+    return written;
+}
+
+static size_t decode_buffer_hd(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct aptx_hd_info *aptx_hd_info = (struct aptx_hd_info *) codec_info;
+    struct rtp_header *header;
+    size_t written;
+
+    if (PA_UNLIKELY(input_size < sizeof(*header))) {
+        *processed = 0;
+        return 0;
+    }
+
+    header = (struct rtp_header *) input_buffer;
+    written = decode_buffer(aptx_hd_info->aptx_c, input_buffer + sizeof(*header), input_size - sizeof(*header), output_buffer, output_size, processed);
+    *processed += sizeof(*header);
+    return written;
+}
+
+const pa_a2dp_codec pa_a2dp_codec_aptx = {
+    .name = "aptx",
+    .description = "aptX",
+    .id = { A2DP_CODEC_VENDOR, APTX_VENDOR_ID, APTX_CODEC_ID },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities,
+    .cmp_endpoints = cmp_endpoints,
+    .fill_capabilities = fill_capabilities,
+    .is_configuration_valid = is_configuration_valid,
+    .fill_preferred_configuration = fill_preferred_configuration,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_read_block_size,
+    .get_write_block_size = get_write_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
+
+const pa_a2dp_codec pa_a2dp_codec_aptx_hd = {
+    .name = "aptx_hd",
+    .description = "aptX HD",
+    .id = { A2DP_CODEC_VENDOR, APTX_HD_VENDOR_ID, APTX_HD_CODEC_ID },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities_hd,
+    .cmp_endpoints = cmp_endpoints_hd,
+    .fill_capabilities = fill_capabilities_hd,
+    .is_configuration_valid = is_configuration_valid_hd,
+    .fill_preferred_configuration = fill_preferred_configuration_hd,
+    .init = init_hd,
+    .deinit = deinit_hd,
+    .reset = reset_hd,
+    .get_read_block_size = get_read_block_size_hd,
+    .get_write_block_size = get_write_block_size_hd,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate,
+    .encode_buffer = encode_buffer_hd,
+    .decode_buffer = decode_buffer_hd,
+};
diff --git a/src/modules/bluetooth/a2dp-codec-faststream.c b/src/modules/bluetooth/a2dp-codec-faststream.c
new file mode 100644
index 000000000..1e4a4f52c
--- /dev/null
+++ b/src/modules/bluetooth/a2dp-codec-faststream.c
@@ -0,0 +1,569 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2018-2019 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulsecore/core-util.h>
+#include <pulsecore/log.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/once.h>
+#include <pulse/sample.h>
+#include <pulse/xmalloc.h>
+
+#include <sbc/sbc.h>
+
+#include "a2dp-codecs.h"
+#include "a2dp-codec-api.h"
+
+struct faststream_info {
+    sbc_t sbc;                           /* Codec data */
+    size_t codesize, frame_length;       /* SBC Codesize, frame_length. We simply cache those values here */
+    bool is_microphone;
+    uint8_t frequency;
+};
+
+static bool can_accept_capabilities(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    const a2dp_faststream_t *capabilities = (const a2dp_faststream_t *) capabilities_buffer;
+
+    if (capabilities_size != sizeof(*capabilities))
+        return false;
+
+    if (A2DP_GET_VENDOR_ID(capabilities->info) != FASTSTREAM_VENDOR_ID || A2DP_GET_CODEC_ID(capabilities->info) != FASTSTREAM_CODEC_ID)
+        return false;
+
+    if (!(capabilities->direction & FASTSTREAM_DIRECTION_SINK))
+        return false;
+
+    if (!(capabilities->sink_frequency & (FASTSTREAM_SINK_SAMPLING_FREQ_44100 | FASTSTREAM_SINK_SAMPLING_FREQ_48000)))
+        return false;
+
+    return true;
+}
+
+static bool can_accept_capabilities_mic(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    const a2dp_faststream_t *capabilities = (const a2dp_faststream_t *) capabilities_buffer;
+
+    if (!can_accept_capabilities(capabilities_buffer, capabilities_size, for_encoding))
+        return false;
+
+    if (!(capabilities->direction & FASTSTREAM_DIRECTION_SOURCE))
+        return false;
+
+    if (!(capabilities->source_frequency & FASTSTREAM_SOURCE_SAMPLING_FREQ_16000))
+        return false;
+
+    return true;
+}
+
+static int cmp_endpoints_common(const uint8_t *capabilities1_buffer, uint8_t capabilities1_size, const uint8_t *capabilities2_buffer, uint8_t capabilities2_size, const pa_sample_spec *default_sample_spec, bool for_encoding, bool with_mic) {
+    const a2dp_faststream_t *capabilities1 = (const a2dp_faststream_t *) capabilities1_buffer;
+    const a2dp_faststream_t *capabilities2 = (const a2dp_faststream_t *) capabilities2_buffer;
+    bool cap1_has_mic, cap1_has_freq_44100, cap1_has_freq_48000;
+    bool cap2_has_mic, cap2_has_freq_44100, cap2_has_freq_48000;
+
+    pa_assert(capabilities1_size == sizeof(*capabilities1));
+    pa_assert(capabilities2_size == sizeof(*capabilities2));
+
+    cap1_has_mic = (capabilities1->direction & FASTSTREAM_DIRECTION_SOURCE);
+    cap2_has_mic = (capabilities2->direction & FASTSTREAM_DIRECTION_SOURCE);
+    cap1_has_freq_44100 = (capabilities1->sink_frequency & FASTSTREAM_SINK_SAMPLING_FREQ_44100);
+    cap2_has_freq_44100 = (capabilities2->sink_frequency & FASTSTREAM_SINK_SAMPLING_FREQ_44100);
+    cap1_has_freq_48000 = (capabilities1->sink_frequency & FASTSTREAM_SINK_SAMPLING_FREQ_48000);
+    cap2_has_freq_48000 = (capabilities2->sink_frequency & FASTSTREAM_SINK_SAMPLING_FREQ_48000);
+
+    /* Prefer endpoint which frequency is near to default sample rate */
+    if (default_sample_spec->rate <= 44100) {
+        if (cap1_has_freq_44100 && !cap2_has_freq_44100)
+            return -1;
+        if (!cap1_has_freq_44100 && cap2_has_freq_44100)
+            return 1;
+    } else {
+        if (cap1_has_freq_48000 && !cap2_has_freq_48000)
+            return -1;
+        if (!cap1_has_freq_48000 && cap2_has_freq_48000)
+            return 1;
+    }
+
+    /* Prefer endpoint without microphone when microphone is not used */
+    if (!with_mic) {
+        if (cap1_has_mic && !cap2_has_mic)
+            return 1;
+        if (!cap1_has_mic && cap2_has_mic)
+            return -1;
+    }
+
+    return 0;
+}
+
+static int cmp_endpoints(const uint8_t *capabilities1_buffer, uint8_t capabilities1_size, const uint8_t *capabilities2_buffer, uint8_t capabilities2_size, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    return cmp_endpoints_common(capabilities1_buffer, capabilities1_size, capabilities2_buffer, capabilities2_size, default_sample_spec, for_encoding, false);
+}
+
+static int cmp_endpoints_mic(const uint8_t *capabilities1_buffer, uint8_t capabilities1_size, const uint8_t *capabilities2_buffer, uint8_t capabilities2_size, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    return cmp_endpoints_common(capabilities1_buffer, capabilities1_size, capabilities2_buffer, capabilities2_size, default_sample_spec, for_encoding, true);
+}
+
+static uint8_t fill_capabilities(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_faststream_t *capabilities = (a2dp_faststream_t *) capabilities_buffer;
+
+    pa_zero(*capabilities);
+
+    capabilities->info = A2DP_SET_VENDOR_ID_CODEC_ID(FASTSTREAM_VENDOR_ID, FASTSTREAM_CODEC_ID);
+    capabilities->direction = FASTSTREAM_DIRECTION_SINK;
+    capabilities->sink_frequency = FASTSTREAM_SINK_SAMPLING_FREQ_44100 | FASTSTREAM_SINK_SAMPLING_FREQ_48000;
+
+    return sizeof(*capabilities);
+}
+
+static uint8_t fill_capabilities_mic(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_faststream_t *capabilities = (a2dp_faststream_t *) capabilities_buffer;
+
+    pa_zero(*capabilities);
+
+    fill_capabilities(capabilities_buffer);
+
+    capabilities->direction |= FASTSTREAM_DIRECTION_SOURCE;
+    capabilities->source_frequency = FASTSTREAM_SOURCE_SAMPLING_FREQ_16000;
+
+    return sizeof(*capabilities);
+}
+
+static bool is_configuration_valid_common(const a2dp_faststream_t *config, uint8_t config_size) {
+    uint8_t sink_frequency;
+
+    if (config_size != sizeof(*config)) {
+        pa_log_error("Invalid size of config buffer");
+        return false;
+    }
+
+    if (A2DP_GET_VENDOR_ID(config->info) != FASTSTREAM_VENDOR_ID || A2DP_GET_CODEC_ID(config->info) != FASTSTREAM_CODEC_ID) {
+        pa_log_error("Invalid vendor codec information in configuration");
+        return false;
+    }
+
+    if (!(config->direction & FASTSTREAM_DIRECTION_SINK)) {
+        pa_log_error("Invalid direction in configuration");
+        return false;
+    }
+
+    sink_frequency = config->sink_frequency;
+
+    /* Some headsets are buggy and set both 48 kHz and 44.1 kHz in
+     * the config. In such situation trying to send audio at 44.1 kHz
+     * results in choppy audio, so we have to assume that the headset
+     * actually wants 48 kHz audio. */
+    if (sink_frequency == (FASTSTREAM_SINK_SAMPLING_FREQ_44100 | FASTSTREAM_SINK_SAMPLING_FREQ_48000))
+        sink_frequency = FASTSTREAM_SINK_SAMPLING_FREQ_48000;
+
+    if (sink_frequency != FASTSTREAM_SINK_SAMPLING_FREQ_44100 && sink_frequency != FASTSTREAM_SINK_SAMPLING_FREQ_48000) {
+        pa_log_error("Invalid sink sampling frequency in configuration");
+        return false;
+    }
+
+    return true;
+}
+
+static bool is_configuration_valid(const uint8_t *config_buffer, uint8_t config_size) {
+    const a2dp_faststream_t *config = (const a2dp_faststream_t *) config_buffer;
+
+    if (!is_configuration_valid_common(config, config_size))
+        return false;
+
+    if (config->direction & FASTSTREAM_DIRECTION_SOURCE) {
+        pa_log_error("Invalid direction in configuration");
+        return false;
+    }
+
+    return true;
+}
+
+static bool is_configuration_valid_mic(const uint8_t *config_buffer, uint8_t config_size) {
+    const a2dp_faststream_t *config = (const a2dp_faststream_t *) config_buffer;
+
+    if (!is_configuration_valid_common(config, config_size))
+        return false;
+
+    if (!(config->direction & FASTSTREAM_DIRECTION_SOURCE)) {
+        pa_log_error("Invalid direction in configuration");
+        return false;
+    }
+
+    if (config->source_frequency != FASTSTREAM_SOURCE_SAMPLING_FREQ_16000) {
+        pa_log_error("Invalid source sampling frequency in configuration");
+        return false;
+    }
+
+    return true;
+}
+
+static uint8_t fill_preferred_configuration(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_faststream_t *config = (a2dp_faststream_t *) config_buffer;
+    const a2dp_faststream_t *capabilities = (const a2dp_faststream_t *) capabilities_buffer;
+    int i;
+
+    static const struct {
+        uint32_t rate;
+        uint8_t cap;
+    } freq_table[] = {
+        { 44100U, FASTSTREAM_SINK_SAMPLING_FREQ_44100 },
+        { 48000U, FASTSTREAM_SINK_SAMPLING_FREQ_48000 }
+    };
+
+    if (capabilities_size != sizeof(*capabilities)) {
+        pa_log_error("Invalid size of capabilities buffer");
+        return 0;
+    }
+
+    pa_zero(*config);
+
+    if (A2DP_GET_VENDOR_ID(capabilities->info) != FASTSTREAM_VENDOR_ID || A2DP_GET_CODEC_ID(capabilities->info) != FASTSTREAM_CODEC_ID) {
+        pa_log_error("No supported vendor codec information");
+        return 0;
+    }
+
+    config->info = A2DP_SET_VENDOR_ID_CODEC_ID(FASTSTREAM_VENDOR_ID, FASTSTREAM_CODEC_ID);
+
+    /* Find the lowest freq that is at least as high as the requested sampling rate */
+    for (i = 0; (unsigned) i < PA_ELEMENTSOF(freq_table); i++) {
+        if (freq_table[i].rate >= default_sample_spec->rate && (capabilities->sink_frequency & freq_table[i].cap)) {
+            config->sink_frequency = freq_table[i].cap;
+            break;
+        }
+    }
+
+    if ((unsigned) i == PA_ELEMENTSOF(freq_table)) {
+        for (--i; i >= 0; i--) {
+            if (capabilities->sink_frequency & freq_table[i].cap) {
+                config->sink_frequency = freq_table[i].cap;
+                break;
+            }
+        }
+
+        if (i < 0) {
+            pa_log_error("Not suitable sample rate");
+            return 0;
+        }
+    }
+
+    pa_assert((unsigned) i < PA_ELEMENTSOF(freq_table));
+
+    if (!(capabilities->direction & FASTSTREAM_DIRECTION_SINK)) {
+        pa_log_error("No sink support");
+        return 0;
+    }
+
+    config->direction = FASTSTREAM_DIRECTION_SINK;
+
+    return sizeof(*config);
+}
+
+static uint8_t fill_preferred_configuration_mic(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_faststream_t *config = (a2dp_faststream_t *) config_buffer;
+    const a2dp_faststream_t *capabilities = (const a2dp_faststream_t *) capabilities_buffer;
+
+    if (fill_preferred_configuration(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer) == 0)
+        return 0;
+
+    if (!(capabilities->direction & FASTSTREAM_DIRECTION_SOURCE)) {
+        pa_log_error("No source support");
+        return 0;
+    }
+
+    if (!(capabilities->source_frequency & FASTSTREAM_SOURCE_SAMPLING_FREQ_16000)) {
+        pa_log_error("No suitable source sample rate");
+        return 0;
+    }
+
+    config->direction |= FASTSTREAM_DIRECTION_SOURCE;
+    config->source_frequency = FASTSTREAM_SOURCE_SAMPLING_FREQ_16000;
+
+    return sizeof(*config);
+}
+
+static void set_params(struct faststream_info *faststream_info) {
+    /* FastStream uses SBC codec with these fixed parameters */
+    if (faststream_info->is_microphone) {
+        faststream_info->sbc.mode = SBC_MODE_MONO;
+        faststream_info->sbc.bitpool = 32;
+    } else {
+        faststream_info->sbc.mode = SBC_MODE_JOINT_STEREO;
+        faststream_info->sbc.bitpool = 29;
+    }
+
+    faststream_info->sbc.frequency = faststream_info->frequency;
+    faststream_info->sbc.blocks = SBC_BLK_16;
+    faststream_info->sbc.subbands = SBC_SB_8;
+    faststream_info->sbc.allocation = SBC_AM_LOUDNESS;
+    faststream_info->sbc.endian = SBC_LE;
+
+    faststream_info->codesize = sbc_get_codesize(&faststream_info->sbc);
+    faststream_info->frame_length = sbc_get_frame_length(&faststream_info->sbc);
+
+    /* Frame length for FastStream is zero-padded to even byte length
+     * libsbc just pad frame length to an integral number of bytes */
+    if (faststream_info->frame_length & 1)
+        faststream_info->frame_length++;
+
+    /* Frame length for FastStream is 72 always bytes */
+    pa_assert(faststream_info->frame_length == 72);
+}
+
+static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec) {
+    struct faststream_info *faststream_info;
+    const a2dp_faststream_t *config = (const a2dp_faststream_t *) config_buffer;
+    int ret;
+
+    pa_assert(config_size == sizeof(*config));
+
+    faststream_info = pa_xnew0(struct faststream_info, 1);
+    faststream_info->is_microphone = for_backchannel;
+
+    ret = sbc_init(&faststream_info->sbc, 0);
+    if (ret != 0) {
+        pa_xfree(faststream_info);
+        pa_log_error("SBC initialization failed: %d", ret);
+        return NULL;
+    }
+
+    sample_spec->format = PA_SAMPLE_S16LE;
+
+    if (faststream_info->is_microphone) {
+        if (config->source_frequency == FASTSTREAM_SOURCE_SAMPLING_FREQ_16000) {
+            faststream_info->frequency = SBC_FREQ_16000;
+            sample_spec->rate = 16000U;
+        } else {
+            pa_assert_not_reached();
+        }
+
+        sample_spec->channels = 1;
+    } else {
+        uint8_t sink_frequency = config->sink_frequency;
+
+        /* Some headsets are buggy and set both 48 kHz and 44.1 kHz in
+         * the config. In such situation trying to send audio at 44.1 kHz
+         * results in choppy audio, so we have to assume that the headset
+         * actually wants 48 kHz audio. */
+        if (sink_frequency == (FASTSTREAM_SINK_SAMPLING_FREQ_44100 | FASTSTREAM_SINK_SAMPLING_FREQ_48000))
+            sink_frequency = FASTSTREAM_SINK_SAMPLING_FREQ_48000;
+
+        if (sink_frequency == FASTSTREAM_SINK_SAMPLING_FREQ_48000) {
+            faststream_info->frequency = SBC_FREQ_48000;
+            sample_spec->rate = 48000U;
+        } else if (config->sink_frequency == FASTSTREAM_SINK_SAMPLING_FREQ_44100) {
+            faststream_info->frequency = SBC_FREQ_44100;
+            sample_spec->rate = 44100U;
+        } else {
+            pa_assert_not_reached();
+        }
+
+        sample_spec->channels = 2;
+    }
+
+    set_params(faststream_info);
+
+    pa_log_info("SBC parameters: allocation=%s, subbands=%u, blocks=%u, mode=%s bitpool=%u codesize=%u frame_length=%u",
+                faststream_info->sbc.allocation ? "SNR" : "Loudness", faststream_info->sbc.subbands ? 8 : 4,
+                (faststream_info->sbc.blocks+1)*4, faststream_info->sbc.mode == SBC_MODE_MONO ? "Mono" :
+                faststream_info->sbc.mode == SBC_MODE_DUAL_CHANNEL ? "DualChannel" :
+                faststream_info->sbc.mode == SBC_MODE_STEREO ? "Stereo" : "JointStereo",
+                faststream_info->sbc.bitpool, (unsigned)faststream_info->codesize, (unsigned)faststream_info->frame_length);
+
+    return faststream_info;
+}
+
+static void deinit(void *codec_info) {
+    struct faststream_info *faststream_info = (struct faststream_info *) codec_info;
+
+    sbc_finish(&faststream_info->sbc);
+    pa_xfree(faststream_info);
+}
+
+static int reset(void *codec_info) {
+    struct faststream_info *faststream_info = (struct faststream_info *) codec_info;
+    int ret;
+
+    ret = sbc_reinit(&faststream_info->sbc, 0);
+    if (ret != 0) {
+        pa_log_error("SBC reinitialization failed: %d", ret);
+        return -1;
+    }
+
+    /* sbc_reinit() sets also default parameters, so reset them back */
+    set_params(faststream_info);
+    return 0;
+}
+
+static size_t get_read_block_size(void *codec_info, size_t read_link_mtu) {
+    struct faststream_info *faststream_info = (struct faststream_info *) codec_info;
+    size_t frame_count;
+
+    if (read_link_mtu < 220)
+        pa_log_error("Link MTU for FastStream codec is %u too small (need at least 220)", (unsigned)read_link_mtu);
+
+    frame_count = read_link_mtu / faststream_info->frame_length;
+    return frame_count * faststream_info->codesize;
+}
+
+static size_t get_write_block_size(void *codec_info, size_t write_link_mtu) {
+    /* FastStream must fit into DM5 packet (220 bytes) so ensure that we never generate larger packet */
+    return get_read_block_size(codec_info, (write_link_mtu > 220 ? 220 : write_link_mtu));
+}
+
+static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
+    return 0;
+}
+
+static size_t encode_buffer(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct faststream_info *faststream_info = (struct faststream_info *) codec_info;
+    uint8_t *d;
+    const uint8_t *p;
+    size_t to_write, to_encode;
+
+    p = input_buffer;
+    to_encode = input_size;
+
+    d = output_buffer;
+    to_write = output_size;
+
+    while (PA_LIKELY(to_encode > 0 && to_write > 0)) {
+        ssize_t written;
+        ssize_t encoded;
+
+        encoded = sbc_encode(&faststream_info->sbc, p, to_encode, d, (to_write & ~0x1), &written);
+
+        if (PA_UNLIKELY(encoded <= 0)) {
+            pa_log_error("SBC encoding error (%li)", (long) encoded);
+            break;
+        }
+
+        if (PA_UNLIKELY(written < 0)) {
+            pa_log_error("SBC encoding error (%li)", (long) written);
+            break;
+        }
+
+        /* If necessary add zero padding to have frame size of even length */
+        if (written & 1)
+            d[written++] = 0;
+
+        pa_assert_fp((size_t) encoded <= to_encode);
+        pa_assert_fp((size_t) encoded == faststream_info->codesize);
+
+        pa_assert_fp((size_t) written <= to_write);
+        pa_assert_fp((size_t) written == faststream_info->frame_length);
+
+        p += encoded;
+        to_encode -= encoded;
+
+        d += written;
+        to_write -= written;
+    }
+
+    PA_ONCE_BEGIN {
+        pa_log_debug("Using FastStream codec with SBC codec implementation: %s", pa_strnull(sbc_get_implementation_info(&faststream_info->sbc)));
+    } PA_ONCE_END;
+
+    *processed = p - input_buffer;
+    return d - output_buffer;
+}
+
+static size_t decode_buffer(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct faststream_info *faststream_info = (struct faststream_info *) codec_info;
+    const uint8_t *p;
+    uint8_t *d;
+    size_t to_write, to_decode;
+
+    p = input_buffer;
+    to_decode = input_size;
+
+    d = output_buffer;
+    to_write = output_size;
+
+    while (PA_LIKELY(to_decode > 0 && to_write > 0)) {
+        size_t written;
+        ssize_t decoded;
+
+        decoded = sbc_decode(&faststream_info->sbc, p, to_decode, d, to_write, &written);
+
+        if (PA_UNLIKELY(decoded <= 0)) {
+            pa_log_error("SBC decoding error (%li)", (long) decoded);
+            break;
+        }
+
+        /* Frame size is of even length so process zero padding */
+        if ((size_t)decoded < to_decode && (decoded & 1))
+            decoded++;
+
+        pa_assert_fp((size_t) decoded <= to_decode);
+        pa_assert_fp((size_t) decoded == faststream_info->frame_length);
+
+        pa_assert_fp((size_t) written <= to_write);
+        pa_assert_fp((size_t) written == faststream_info->codesize);
+
+        p += decoded;
+        to_decode -= decoded;
+
+        d += written;
+        to_write -= written;
+    }
+
+    *processed = p - input_buffer;
+    return d - output_buffer;
+}
+
+const pa_a2dp_codec pa_a2dp_codec_faststream = {
+    .name = "faststream",
+    .description = "FastStream (without microphone)",
+    .id = { A2DP_CODEC_VENDOR, FASTSTREAM_VENDOR_ID, FASTSTREAM_CODEC_ID },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities,
+    .cmp_endpoints = cmp_endpoints,
+    .fill_capabilities = fill_capabilities,
+    .is_configuration_valid = is_configuration_valid,
+    .fill_preferred_configuration = fill_preferred_configuration,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_read_block_size,
+    .get_write_block_size = get_write_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
+
+const pa_a2dp_codec pa_a2dp_codec_faststream_mic = {
+    .name = "faststream_mic",
+    .description = "FastStream (with microphone)",
+    .id = { A2DP_CODEC_VENDOR, FASTSTREAM_VENDOR_ID, FASTSTREAM_CODEC_ID },
+    .support_backchannel = true,
+    .can_accept_capabilities = can_accept_capabilities_mic,
+    .cmp_endpoints = cmp_endpoints_mic,
+    .fill_capabilities = fill_capabilities_mic,
+    .is_configuration_valid = is_configuration_valid_mic,
+    .fill_preferred_configuration = fill_preferred_configuration_mic,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_read_block_size,
+    .get_write_block_size = get_write_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
diff --git a/src/modules/bluetooth/a2dp-codec-sbc.c b/src/modules/bluetooth/a2dp-codec-sbc.c
index 89c647fbe..28439e89c 100644
--- a/src/modules/bluetooth/a2dp-codec-sbc.c
+++ b/src/modules/bluetooth/a2dp-codec-sbc.c
@@ -36,8 +36,71 @@
 #include "a2dp-codec-api.h"
 #include "rtp.h"
 
-#define SBC_BITPOOL_DEC_LIMIT 32
-#define SBC_BITPOOL_DEC_STEP 5
+/* Below are capabilities tables for different qualities. Order of capabilities in tables are from the most preferred to the least preferred. */
+
+#define FIXED_SBC_CAPS(mode, freq, bitpool) { .channel_mode = (mode), .frequency = (freq), .min_bitpool = (bitpool), .max_bitpool = (bitpool), .allocation_method = SBC_ALLOCATION_LOUDNESS, .subbands = SBC_SUBBANDS_8, .block_length = SBC_BLOCK_LENGTH_16 }
+
+/* SBC Low Quality, Joint Stereo is same as FastStream's SBC codec configuration, Mono was calculated to match Joint Stereo */
+static const a2dp_sbc_t sbc_lq_caps_table[] = {
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_JOINT_STEREO, SBC_SAMPLING_FREQ_44100, 29), /* 195.7 kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_JOINT_STEREO, SBC_SAMPLING_FREQ_48000, 29), /* 213   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_MONO,         SBC_SAMPLING_FREQ_44100, 15), /* 104.7 kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_MONO,         SBC_SAMPLING_FREQ_48000, 15), /* 114   kbps */
+};
+
+/* SBC Middle Quality, based on A2DP spec: Recommended sets of SBC parameters */
+static const a2dp_sbc_t sbc_mq_caps_table[] = {
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_JOINT_STEREO, SBC_SAMPLING_FREQ_44100, SBC_BITPOOL_MQ_JOINT_STEREO_44100), /* bitpool = 35, 228.8 kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_JOINT_STEREO, SBC_SAMPLING_FREQ_48000, SBC_BITPOOL_MQ_JOINT_STEREO_48000), /* bitpool = 33, 237   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_MONO,         SBC_SAMPLING_FREQ_44100, SBC_BITPOOL_MQ_MONO_44100),         /* bitpool = 19, 126.8 kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_MONO,         SBC_SAMPLING_FREQ_48000, SBC_BITPOOL_MQ_MONO_48000),         /* bitpool = 18, 132   kbps */
+};
+
+/* SBC High Quality, based on A2DP spec: Recommended sets of SBC parameters */
+static const a2dp_sbc_t sbc_hq_caps_table[] = {
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_JOINT_STEREO, SBC_SAMPLING_FREQ_44100, SBC_BITPOOL_HQ_JOINT_STEREO_44100), /* bitpool = 53, 328   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_JOINT_STEREO, SBC_SAMPLING_FREQ_48000, SBC_BITPOOL_HQ_JOINT_STEREO_48000), /* bitpool = 51, 345   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_MONO,         SBC_SAMPLING_FREQ_44100, SBC_BITPOOL_HQ_MONO_44100),         /* bitpool = 31, 192.9 kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_MONO,         SBC_SAMPLING_FREQ_48000, SBC_BITPOOL_HQ_MONO_48000),         /* bitpool = 29, 210   kbps */
+};
+
+/* SBC eXtreme Quality, calculated to minimize wasted bytes for EDR-2 and to
+ * be below max possible 512 kbps. In most cases bluetooth headsets would
+ * support only sbc dual channel mode for 2 channels as they have limited
+ * maximal bitpool value to 53. We need to define it in two tables to disallow
+ * invalid combination of joint stereo with bitpool 38 which is not XQ. */
+static const a2dp_sbc_t sbc_xq1_caps_table[] = {
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_JOINT_STEREO, SBC_SAMPLING_FREQ_44100, 76), /* 454.8 kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_JOINT_STEREO, SBC_SAMPLING_FREQ_48000, 76), /* 495   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_STEREO,       SBC_SAMPLING_FREQ_44100, 76), /* 452   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_STEREO,       SBC_SAMPLING_FREQ_48000, 76), /* 492   kbps */
+};
+static const a2dp_sbc_t sbc_xq2_caps_table[] = {
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_DUAL_CHANNEL, SBC_SAMPLING_FREQ_44100, 38), /* 452   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_DUAL_CHANNEL, SBC_SAMPLING_FREQ_48000, 38), /* 492   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_MONO,         SBC_SAMPLING_FREQ_44100, 37), /* 226   kbps */
+    FIXED_SBC_CAPS(SBC_CHANNEL_MODE_MONO,         SBC_SAMPLING_FREQ_48000, 37), /* 246   kbps */
+};
+
+#undef FIXED_SBC_CAPS
+
+/* SBC Auto Quality, only one row which allow any possible configuration up to common High Quality */
+/* We need to ensure that bitrate is below max possible 512 kbps, therefore limit configuration to High Quality */
+static const a2dp_sbc_t sbc_auto_caps_table[] = { {
+    .channel_mode = SBC_CHANNEL_MODE_MONO | SBC_CHANNEL_MODE_DUAL_CHANNEL | SBC_CHANNEL_MODE_STEREO | SBC_CHANNEL_MODE_JOINT_STEREO,
+    .frequency = SBC_SAMPLING_FREQ_16000 | SBC_SAMPLING_FREQ_32000 | SBC_SAMPLING_FREQ_44100 | SBC_SAMPLING_FREQ_48000,
+    .allocation_method = SBC_ALLOCATION_SNR | SBC_ALLOCATION_LOUDNESS,
+    .subbands = SBC_SUBBANDS_4 | SBC_SUBBANDS_8,
+    .block_length = SBC_BLOCK_LENGTH_4 | SBC_BLOCK_LENGTH_8 | SBC_BLOCK_LENGTH_12 | SBC_BLOCK_LENGTH_16,
+    .min_bitpool = SBC_MIN_BITPOOL,
+    .max_bitpool = SBC_BITPOOL_HQ_JOINT_STEREO_44100,
+} };
+
+/* Bitpool limits and steps for reducing bitrate in Auto Quality mode */
+#define SBC_SEPARATE_BITPOOL_DEC_LIMIT 10
+#define SBC_COMBINED_BITPOOL_DEC_LIMIT 25
+#define SBC_SEPARATE_BITPOOL_DEC_STEP   2
+#define SBC_COMBINED_BITPOOL_DEC_STEP   4
 
 struct sbc_info {
     sbc_t sbc;                           /* Codec data */
@@ -53,62 +116,287 @@ struct sbc_info {
     uint8_t max_bitpool;
 };
 
-static bool can_accept_capabilities(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
-    const a2dp_sbc_t *capabilities = (const a2dp_sbc_t *) capabilities_buffer;
+static bool are_capabilities_compatible(const a2dp_sbc_t *capabilities1, const a2dp_sbc_t *capabilities2) {
+    if (!(capabilities1->channel_mode & capabilities2->channel_mode))
+        return false;
 
-    if (capabilities_size != sizeof(*capabilities))
+    if (!(capabilities1->frequency & capabilities2->frequency))
         return false;
 
-    if (!(capabilities->frequency & (SBC_SAMPLING_FREQ_16000 | SBC_SAMPLING_FREQ_32000 | SBC_SAMPLING_FREQ_44100 | SBC_SAMPLING_FREQ_48000)))
+    if (!(capabilities1->allocation_method & capabilities2->allocation_method))
         return false;
 
-    if (!(capabilities->channel_mode & (SBC_CHANNEL_MODE_MONO | SBC_CHANNEL_MODE_DUAL_CHANNEL | SBC_CHANNEL_MODE_STEREO | SBC_CHANNEL_MODE_JOINT_STEREO)))
+    if (!(capabilities1->subbands & capabilities2->subbands))
         return false;
 
-    if (!(capabilities->allocation_method & (SBC_ALLOCATION_SNR | SBC_ALLOCATION_LOUDNESS)))
+    if (!(capabilities1->block_length & capabilities2->block_length))
         return false;
 
-    if (!(capabilities->subbands & (SBC_SUBBANDS_4 | SBC_SUBBANDS_8)))
+    if (capabilities1->min_bitpool > capabilities2->max_bitpool || capabilities2->min_bitpool > capabilities1->max_bitpool)
         return false;
 
-    if (!(capabilities->block_length & (SBC_BLOCK_LENGTH_4 | SBC_BLOCK_LENGTH_8 | SBC_BLOCK_LENGTH_12 | SBC_BLOCK_LENGTH_16)))
+    if (capabilities1->min_bitpool > capabilities1->max_bitpool || capabilities2->min_bitpool > capabilities2->max_bitpool)
         return false;
 
     return true;
 }
 
-static const char *choose_remote_endpoint(const pa_hashmap *capabilities_hashmap, const pa_sample_spec *default_sample_spec, bool for_encoding) {
-    const pa_a2dp_codec_capabilities *a2dp_capabilities;
-    const char *key;
-    void *state;
+static bool can_accept_capabilities_table(const uint8_t *capabilities_buffer, uint8_t capabilities_size, const a2dp_sbc_t capabilities_table[], unsigned capabilities_table_elements) {
+    const a2dp_sbc_t *capabilities = (const a2dp_sbc_t *) capabilities_buffer;
+    unsigned i;
 
-    /* There is no preference, just choose random valid entry */
-    PA_HASHMAP_FOREACH_KV(key, a2dp_capabilities, capabilities_hashmap, state) {
-        if (can_accept_capabilities(a2dp_capabilities->buffer, a2dp_capabilities->size, for_encoding))
-            return key;
+    if (capabilities_size != sizeof(*capabilities))
+        return false;
+
+    for (i = 0; i < capabilities_table_elements; i++) {
+        if (!are_capabilities_compatible(capabilities, &capabilities_table[i]))
+            continue;
+        return true;
     }
 
-    return NULL;
+    return false;
 }
 
-static uint8_t fill_capabilities(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+static bool can_accept_capabilities_lq(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    return can_accept_capabilities_table(capabilities_buffer, capabilities_size, sbc_lq_caps_table, PA_ELEMENTSOF(sbc_lq_caps_table));
+}
+
+static bool can_accept_capabilities_mq(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    return can_accept_capabilities_table(capabilities_buffer, capabilities_size, sbc_mq_caps_table, PA_ELEMENTSOF(sbc_mq_caps_table));
+}
+
+static bool can_accept_capabilities_hq(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    return can_accept_capabilities_table(capabilities_buffer, capabilities_size, sbc_hq_caps_table, PA_ELEMENTSOF(sbc_hq_caps_table));
+}
+
+static bool can_accept_capabilities_xq1(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    return can_accept_capabilities_table(capabilities_buffer, capabilities_size, sbc_xq1_caps_table, PA_ELEMENTSOF(sbc_xq1_caps_table));
+}
+
+static bool can_accept_capabilities_xq2(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    return can_accept_capabilities_table(capabilities_buffer, capabilities_size, sbc_xq2_caps_table, PA_ELEMENTSOF(sbc_xq2_caps_table));
+}
+
+static bool can_accept_capabilities(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    return can_accept_capabilities_table(capabilities_buffer, capabilities_size, sbc_auto_caps_table, PA_ELEMENTSOF(sbc_auto_caps_table));
+}
+
+static int cmp_endpoints_by_channels(const a2dp_sbc_t *capabilities1, const a2dp_sbc_t *capabilities2, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    /* Prefer enpoint which number of channels is near to default sample channel number */
+    if (default_sample_spec->channels < 2) {
+        if ((capabilities1->channel_mode & SBC_CHANNEL_MODE_MONO) && !(capabilities2->channel_mode & SBC_CHANNEL_MODE_MONO))
+            return -1;
+        if (!(capabilities1->channel_mode & SBC_CHANNEL_MODE_MONO) && (capabilities2->channel_mode & SBC_CHANNEL_MODE_MONO))
+            return 1;
+    } else {
+        if ((capabilities1->channel_mode & (SBC_CHANNEL_MODE_DUAL_CHANNEL|SBC_CHANNEL_MODE_STEREO|SBC_CHANNEL_MODE_JOINT_STEREO)) &&
+           !(capabilities2->channel_mode & (SBC_CHANNEL_MODE_DUAL_CHANNEL|SBC_CHANNEL_MODE_STEREO|SBC_CHANNEL_MODE_JOINT_STEREO)))
+            return -1;
+        if (!(capabilities1->channel_mode & (SBC_CHANNEL_MODE_DUAL_CHANNEL|SBC_CHANNEL_MODE_STEREO|SBC_CHANNEL_MODE_JOINT_STEREO)) &&
+             (capabilities2->channel_mode & (SBC_CHANNEL_MODE_DUAL_CHANNEL|SBC_CHANNEL_MODE_STEREO|SBC_CHANNEL_MODE_JOINT_STEREO)))
+            return 1;
+    }
+
+    return 0;
+}
+
+static int cmp_endpoints_by_freq(const a2dp_sbc_t *capabilities1, const a2dp_sbc_t *capabilities2, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    uint32_t freq1 = 0;
+    uint32_t freq2 = 0;
+    int i;
+
+    static const struct {
+        uint32_t rate;
+        uint8_t cap;
+    } freq_table[] = {
+        { 16000U, SBC_SAMPLING_FREQ_16000 },
+        { 32000U, SBC_SAMPLING_FREQ_32000 },
+        { 44100U, SBC_SAMPLING_FREQ_44100 },
+        { 48000U, SBC_SAMPLING_FREQ_48000 }
+    };
+
+    /* Find the lowest freq that is at least as high as the requested sampling rate */
+    for (i = 0; (unsigned)i < PA_ELEMENTSOF(freq_table); i++) {
+        if (!freq1 && freq_table[i].rate >= default_sample_spec->rate && (capabilities1->frequency & freq_table[i].cap))
+            freq1 = freq_table[i].rate;
+        if (!freq2 && freq_table[i].rate >= default_sample_spec->rate && (capabilities2->frequency & freq_table[i].cap))
+            freq2 = freq_table[i].rate;
+        if (freq1 && freq2)
+            break;
+    }
+
+    /* Prefer endpoint which frequency is near to default sample rate */
+    if (freq1 && freq2) {
+        if (freq1 < freq2)
+            return -1;
+        if (freq1 > freq2)
+            return 1;
+    } else if (freq1) {
+        return -1;
+    } else if (freq2) {
+        return 1;
+    } else {
+        /* Both endpoints support only frequencies lower than requested sampling rate, therefore prefer endpoint with higher supported frequency */
+        for (i = PA_ELEMENTSOF(freq_table)-1; i >= 0; i--) {
+            if (!freq1 && (capabilities1->frequency & freq_table[i].cap))
+                freq1 = freq_table[i].rate;
+            if (!freq2 && (capabilities2->frequency & freq_table[i].cap))
+                freq2 = freq_table[i].rate;
+            if (freq1 && freq2)
+                break;
+        }
+        pa_assert(i >= 0);
+
+        if (freq1 > freq2)
+            return -1;
+        if (freq1 < freq2)
+            return 1;
+    }
+
+    return 0;
+}
+
+static int cmp_endpoints(const uint8_t *capabilities1_buffer, uint8_t capabilities1_size, const uint8_t *capabilities2_buffer, uint8_t capabilities2_size, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    const a2dp_sbc_t *capabilities1 = (const a2dp_sbc_t *) capabilities1_buffer;
+    const a2dp_sbc_t *capabilities2 = (const a2dp_sbc_t *) capabilities2_buffer;
+    uint8_t max1_bitpool, max2_bitpool, min1_bitpool, min2_bitpool;
+    uint8_t capabilities1_range, capabilities2_range;
+    uint8_t unusable1_range, unusable2_range;
+    int cmp;
+
+    pa_assert(capabilities1_size == sizeof(*capabilities1));
+    pa_assert(capabilities2_size == sizeof(*capabilities2));
+
+    /* For mono outputs prefer endpoint with mono capability and for other outputs prefer non-mono capabilities */
+    cmp = cmp_endpoints_by_channels(capabilities1, capabilities2, default_sample_spec, for_encoding);
+    if (cmp != 0)
+        return cmp;
+
+    /* For sample rate above 44.1kHz when at least one endpoint does not support frequency suitable for 44.1kHz, use preference based on frequency */
+    if (default_sample_spec->rate >= 44100 &&
+        !((capabilities1->frequency & (SBC_SAMPLING_FREQ_44100|SBC_SAMPLING_FREQ_48000)) &&
+          (capabilities2->frequency & (SBC_SAMPLING_FREQ_44100|SBC_SAMPLING_FREQ_48000)))) {
+        cmp = cmp_endpoints_by_freq(capabilities1, capabilities2, default_sample_spec, for_encoding);
+        if (cmp != 0)
+            return cmp;
+    }
+
+    /* Calculate usable bitpool range compatible with both remote capabilities and capabilities from auto sbc quality */
+    max1_bitpool = PA_MIN(capabilities1->max_bitpool, sbc_auto_caps_table[0].max_bitpool);
+    max2_bitpool = PA_MIN(capabilities2->max_bitpool, sbc_auto_caps_table[0].max_bitpool);
+    min1_bitpool = PA_MAX(capabilities1->min_bitpool, sbc_auto_caps_table[0].min_bitpool);
+    min2_bitpool = PA_MAX(capabilities2->min_bitpool, sbc_auto_caps_table[0].min_bitpool);
+    capabilities1_range = max1_bitpool - min1_bitpool;
+    capabilities2_range = max2_bitpool - min2_bitpool;
+
+    /* Prefer endpoint with larger usable bitpool range compatible with both sides */
+    if (capabilities1_range > capabilities2_range)
+        return -1;
+    if (capabilities1_range < capabilities2_range)
+        return 1;
+
+    /* Calculate unusable bitpool range which is not not compatible with both sides */
+    unusable1_range = PA_MAX(capabilities1->max_bitpool, sbc_auto_caps_table[0].max_bitpool) - PA_MIN(capabilities1->min_bitpool, sbc_auto_caps_table[0].min_bitpool) - capabilities1_range;
+    unusable2_range = PA_MAX(capabilities2->max_bitpool, sbc_auto_caps_table[0].max_bitpool) - PA_MIN(capabilities2->min_bitpool, sbc_auto_caps_table[0].min_bitpool) - capabilities2_range;
+
+    /* Prefer endpoint with smaller unusable bitpool range */
+    if (unusable1_range > unusable2_range)
+        return -1;
+    if (unusable1_range < unusable2_range)
+        return 1;
+
+    /* Prefer endpoint with higher maximal bitpool value compatible with boot sides */
+    if (max1_bitpool > max2_bitpool)
+        return -1;
+    if (max1_bitpool < max2_bitpool)
+        return 1;
+
+    /* Prefer endpoint with larger bitpool range */
+    if (capabilities1->max_bitpool - capabilities1->min_bitpool > capabilities2->max_bitpool - capabilities2->min_bitpool)
+        return -1;
+    if (capabilities1->max_bitpool - capabilities1->min_bitpool < capabilities2->max_bitpool - capabilities2->min_bitpool)
+        return 1;
+
+    /* Prefer endpoint with higher maximal bitpool value */
+    if (capabilities1->max_bitpool > capabilities2->max_bitpool)
+        return -1;
+    if (capabilities1->max_bitpool < capabilities2->max_bitpool)
+        return 1;
+
+    /* Last preference is by frequency */
+    return cmp_endpoints_by_freq(capabilities1, capabilities2, default_sample_spec, for_encoding);
+}
+
+static int cmp_endpoints_fixed_bitpool(const uint8_t *capabilities1_buffer, uint8_t capabilities1_size, const uint8_t *capabilities2_buffer, uint8_t capabilities2_size, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    const a2dp_sbc_t *capabilities1 = (const a2dp_sbc_t *) capabilities1_buffer;
+    const a2dp_sbc_t *capabilities2 = (const a2dp_sbc_t *) capabilities2_buffer;
+    int cmp;
+
+    pa_assert(capabilities1_size == sizeof(*capabilities1));
+    pa_assert(capabilities2_size == sizeof(*capabilities2));
+
+    cmp = cmp_endpoints_by_channels(capabilities1, capabilities2, default_sample_spec, for_encoding);
+    if (cmp != 0)
+        return cmp;
+
+    cmp = cmp_endpoints_by_freq(capabilities1, capabilities2, default_sample_spec, for_encoding);
+    if (cmp != 0)
+        return cmp;
+
+    return 0;
+}
+
+static uint8_t fill_capabilities_table(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE], const a2dp_sbc_t capabilities_table[], unsigned capabilities_table_elements) {
     a2dp_sbc_t *capabilities = (a2dp_sbc_t *) capabilities_buffer;
+    unsigned i;
 
     pa_zero(*capabilities);
 
-    capabilities->channel_mode = SBC_CHANNEL_MODE_MONO | SBC_CHANNEL_MODE_DUAL_CHANNEL | SBC_CHANNEL_MODE_STEREO |
-                                 SBC_CHANNEL_MODE_JOINT_STEREO;
-    capabilities->frequency = SBC_SAMPLING_FREQ_16000 | SBC_SAMPLING_FREQ_32000 | SBC_SAMPLING_FREQ_44100 |
-                              SBC_SAMPLING_FREQ_48000;
-    capabilities->allocation_method = SBC_ALLOCATION_SNR | SBC_ALLOCATION_LOUDNESS;
-    capabilities->subbands = SBC_SUBBANDS_4 | SBC_SUBBANDS_8;
-    capabilities->block_length = SBC_BLOCK_LENGTH_4 | SBC_BLOCK_LENGTH_8 | SBC_BLOCK_LENGTH_12 | SBC_BLOCK_LENGTH_16;
-    capabilities->min_bitpool = SBC_MIN_BITPOOL;
-    capabilities->max_bitpool = SBC_BITPOOL_HQ_JOINT_STEREO_44100;
+    capabilities->min_bitpool = 0xFF;
+    capabilities->max_bitpool = 0x00;
+
+    for (i = 0; i < capabilities_table_elements; i++) {
+        capabilities->channel_mode |= capabilities_table[i].channel_mode;
+        capabilities->frequency |= capabilities_table[i].frequency;
+        capabilities->allocation_method |= capabilities_table[i].allocation_method;
+        capabilities->subbands |= capabilities_table[i].subbands;
+        capabilities->block_length |= capabilities_table[i].block_length;
+        if (capabilities->min_bitpool > capabilities_table[i].min_bitpool)
+            capabilities->min_bitpool = capabilities_table[i].min_bitpool;
+        if (capabilities->max_bitpool < capabilities_table[i].max_bitpool)
+            capabilities->max_bitpool = capabilities_table[i].max_bitpool;
+    }
+
+    pa_assert(capabilities->min_bitpool != 0xFF);
+    pa_assert(capabilities->max_bitpool != 0x00);
 
     return sizeof(*capabilities);
 }
 
+static uint8_t fill_capabilities_lq(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_capabilities_table(capabilities_buffer, sbc_lq_caps_table, PA_ELEMENTSOF(sbc_lq_caps_table));
+}
+
+static uint8_t fill_capabilities_mq(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_capabilities_table(capabilities_buffer, sbc_mq_caps_table, PA_ELEMENTSOF(sbc_mq_caps_table));
+}
+
+static uint8_t fill_capabilities_hq(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_capabilities_table(capabilities_buffer, sbc_hq_caps_table, PA_ELEMENTSOF(sbc_hq_caps_table));
+}
+
+static uint8_t fill_capabilities_xq1(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_capabilities_table(capabilities_buffer, sbc_xq1_caps_table, PA_ELEMENTSOF(sbc_xq1_caps_table));
+}
+
+static uint8_t fill_capabilities_xq2(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_capabilities_table(capabilities_buffer, sbc_xq2_caps_table, PA_ELEMENTSOF(sbc_xq2_caps_table));
+}
+
+static uint8_t fill_capabilities(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_capabilities_table(capabilities_buffer, sbc_auto_caps_table, PA_ELEMENTSOF(sbc_auto_caps_table));
+}
+
 static bool is_configuration_valid(const uint8_t *config_buffer, uint8_t config_size) {
     const a2dp_sbc_t *config = (const a2dp_sbc_t *) config_buffer;
 
@@ -153,52 +441,76 @@ static bool is_configuration_valid(const uint8_t *config_buffer, uint8_t config_
     return true;
 }
 
-static uint8_t default_bitpool(uint8_t freq, uint8_t mode) {
-    /* These bitpool values were chosen based on the A2DP spec recommendation */
-    switch (freq) {
-        case SBC_SAMPLING_FREQ_16000:
-        case SBC_SAMPLING_FREQ_32000:
-            switch (mode) {
-                case SBC_CHANNEL_MODE_MONO:
-                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-                case SBC_CHANNEL_MODE_STEREO:
-                case SBC_CHANNEL_MODE_JOINT_STEREO:
-                    return SBC_BITPOOL_HQ_JOINT_STEREO_44100;
-            }
-            break;
+static bool are_configs_compatible(const a2dp_sbc_t *config1, const a2dp_sbc_t *config2) {
+    if (config1->frequency != config2->frequency)
+        return false;
 
-        case SBC_SAMPLING_FREQ_44100:
-            switch (mode) {
-                case SBC_CHANNEL_MODE_MONO:
-                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-                    return SBC_BITPOOL_HQ_MONO_44100;
+    if (config1->channel_mode != config2->channel_mode)
+        return false;
 
-                case SBC_CHANNEL_MODE_STEREO:
-                case SBC_CHANNEL_MODE_JOINT_STEREO:
-                    return SBC_BITPOOL_HQ_JOINT_STEREO_44100;
-            }
-            break;
+    if (config1->allocation_method != config2->allocation_method)
+        return false;
 
-        case SBC_SAMPLING_FREQ_48000:
-            switch (mode) {
-                case SBC_CHANNEL_MODE_MONO:
-                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-                    return SBC_BITPOOL_HQ_MONO_48000;
+    if (config1->subbands != config2->subbands)
+        return false;
 
-                case SBC_CHANNEL_MODE_STEREO:
-                case SBC_CHANNEL_MODE_JOINT_STEREO:
-                    return SBC_BITPOOL_HQ_JOINT_STEREO_48000;
-            }
-            break;
+    if (config1->block_length != config2->block_length)
+        return false;
+
+    /* second config must have constant bitpool */
+    pa_assert(config2->min_bitpool == config2->max_bitpool);
+
+    if (config1->min_bitpool > config2->min_bitpool || config1->max_bitpool < config2->min_bitpool)
+        return false;
+
+    return true;
+}
+
+static bool is_configuration_valid_table(const uint8_t *config_buffer, uint8_t config_size, const a2dp_sbc_t capabilities_table[], unsigned capabilities_table_elements) {
+    const a2dp_sbc_t *config;
+    unsigned i;
+
+    if (!is_configuration_valid(config_buffer, config_size))
+        return false;
+
+    config = (const a2dp_sbc_t *) config_buffer;
+
+    for (i = 0; i < capabilities_table_elements; i++) {
+        if (!are_configs_compatible(config, &capabilities_table[i]))
+            continue;
+        return true;
     }
 
-    pa_assert_not_reached();
+    pa_log_error("Some configuration settings are invalid for current quality");
+    return false;
 }
 
-static uint8_t fill_preferred_configuration(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+static bool is_configuration_valid_lq(const uint8_t *config_buffer, uint8_t config_size) {
+    return is_configuration_valid_table(config_buffer, config_size, sbc_lq_caps_table, PA_ELEMENTSOF(sbc_lq_caps_table));
+}
+
+static bool is_configuration_valid_mq(const uint8_t *config_buffer, uint8_t config_size) {
+    return is_configuration_valid_table(config_buffer, config_size, sbc_mq_caps_table, PA_ELEMENTSOF(sbc_mq_caps_table));
+}
+
+static bool is_configuration_valid_hq(const uint8_t *config_buffer, uint8_t config_size) {
+    return is_configuration_valid_table(config_buffer, config_size, sbc_hq_caps_table, PA_ELEMENTSOF(sbc_hq_caps_table));
+}
+
+static bool is_configuration_valid_xq1(const uint8_t *config_buffer, uint8_t config_size) {
+    return is_configuration_valid_table(config_buffer, config_size, sbc_xq1_caps_table, PA_ELEMENTSOF(sbc_xq1_caps_table));
+}
+
+static bool is_configuration_valid_xq2(const uint8_t *config_buffer, uint8_t config_size) {
+    return is_configuration_valid_table(config_buffer, config_size, sbc_xq2_caps_table, PA_ELEMENTSOF(sbc_xq2_caps_table));
+}
+
+static uint8_t fill_preferred_configuration_table(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE], const a2dp_sbc_t capabilities_table[], unsigned capabilities_table_elements) {
     a2dp_sbc_t *config = (a2dp_sbc_t *) config_buffer;
     const a2dp_sbc_t *capabilities = (const a2dp_sbc_t *) capabilities_buffer;
-    int i;
+    bool is_mono = (default_sample_spec->channels <= 1);
+    unsigned i;
+    int j;
 
     static const struct {
         uint32_t rate;
@@ -218,96 +530,191 @@ static uint8_t fill_preferred_configuration(const pa_sample_spec *default_sample
     pa_zero(*config);
 
     /* Find the lowest freq that is at least as high as the requested sampling rate */
-    for (i = 0; (unsigned) i < PA_ELEMENTSOF(freq_table); i++)
-        if (freq_table[i].rate >= default_sample_spec->rate && (capabilities->frequency & freq_table[i].cap)) {
-            config->frequency = freq_table[i].cap;
-            break;
+    for (j = 0; (unsigned) j < PA_ELEMENTSOF(freq_table); j++) {
+        if (freq_table[j].rate >= default_sample_spec->rate && (capabilities->frequency & freq_table[j].cap)) {
+            for (i = 0; i < capabilities_table_elements; i++) {
+                if (capabilities_table[i].frequency & freq_table[j].cap) {
+                    config->frequency = freq_table[j].cap;
+                    break;
+                }
+            }
+            if (i != capabilities_table_elements)
+                break;
         }
+    }
 
-    if ((unsigned) i == PA_ELEMENTSOF(freq_table)) {
-        for (--i; i >= 0; i--) {
-            if (capabilities->frequency & freq_table[i].cap) {
-                config->frequency = freq_table[i].cap;
-                break;
+    if ((unsigned) j == PA_ELEMENTSOF(freq_table)) {
+        for (--j; j >= 0; j--) {
+            if (capabilities->frequency & freq_table[j].cap) {
+                for (i = 0; i < capabilities_table_elements; i++) {
+                    if (capabilities_table[i].frequency & freq_table[j].cap) {
+                        config->frequency = freq_table[j].cap;
+                        break;
+                    }
+                }
+                if (i != capabilities_table_elements)
+                    break;
             }
         }
 
-        if (i < 0) {
-            pa_log_error("Not suitable sample rate");
+        if (j < 0) {
+            pa_log_error("No suitable sample rate");
             return 0;
         }
     }
 
-    pa_assert((unsigned) i < PA_ELEMENTSOF(freq_table));
+    pa_assert((unsigned) j < PA_ELEMENTSOF(freq_table));
+
+    for (i = 0; i < capabilities_table_elements; i++) {
+        if ((capabilities->block_length & SBC_BLOCK_LENGTH_16) && (capabilities_table[i].block_length & SBC_BLOCK_LENGTH_16))
+            config->block_length = SBC_BLOCK_LENGTH_16;
+        else if ((capabilities->block_length & SBC_BLOCK_LENGTH_12) && (capabilities_table[i].block_length & SBC_BLOCK_LENGTH_12))
+            config->block_length = SBC_BLOCK_LENGTH_12;
+        else if ((capabilities->block_length & SBC_BLOCK_LENGTH_8) && (capabilities_table[i].block_length & SBC_BLOCK_LENGTH_8))
+            config->block_length = SBC_BLOCK_LENGTH_8;
+        else if ((capabilities->block_length & SBC_BLOCK_LENGTH_4) && (capabilities_table[i].block_length & SBC_BLOCK_LENGTH_4))
+            config->block_length = SBC_BLOCK_LENGTH_4;
+        else {
+            pa_log_debug("No supported block lengths in table entry %u", i);
+            continue;
+        }
 
-    if (default_sample_spec->channels <= 1) {
-        if (capabilities->channel_mode & SBC_CHANNEL_MODE_MONO)
-            config->channel_mode = SBC_CHANNEL_MODE_MONO;
-        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO)
-            config->channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
-        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_STEREO)
-            config->channel_mode = SBC_CHANNEL_MODE_STEREO;
-        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
-            config->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
+        if ((capabilities->subbands & SBC_SUBBANDS_8) && (capabilities_table[i].subbands & SBC_SUBBANDS_8))
+            config->subbands = SBC_SUBBANDS_8;
+        else if ((capabilities->subbands & SBC_SUBBANDS_4) && (capabilities_table[i].subbands & SBC_SUBBANDS_4))
+            config->subbands = SBC_SUBBANDS_4;
         else {
-            pa_log_error("No supported channel modes");
-            return 0;
+            pa_log_debug("No supported subbands in table entry %u", i);
+            continue;
         }
-    } else {
-        if (capabilities->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO)
-            config->channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
-        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_STEREO)
-            config->channel_mode = SBC_CHANNEL_MODE_STEREO;
-        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
-            config->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
-        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_MONO)
-            config->channel_mode = SBC_CHANNEL_MODE_MONO;
+
+        if ((capabilities->allocation_method & SBC_ALLOCATION_LOUDNESS) && (capabilities_table[i].allocation_method & SBC_ALLOCATION_LOUDNESS))
+            config->allocation_method = SBC_ALLOCATION_LOUDNESS;
+        else if ((capabilities->allocation_method & SBC_ALLOCATION_SNR) && (capabilities_table[i].allocation_method & SBC_ALLOCATION_SNR))
+            config->allocation_method = SBC_ALLOCATION_SNR;
         else {
-            pa_log_error("No supported channel modes");
-            return 0;
+            pa_log_debug("No supported allocation method in table entry %u", i);
+            continue;
         }
-    }
 
-    if (capabilities->block_length & SBC_BLOCK_LENGTH_16)
-        config->block_length = SBC_BLOCK_LENGTH_16;
-    else if (capabilities->block_length & SBC_BLOCK_LENGTH_12)
-        config->block_length = SBC_BLOCK_LENGTH_12;
-    else if (capabilities->block_length & SBC_BLOCK_LENGTH_8)
-        config->block_length = SBC_BLOCK_LENGTH_8;
-    else if (capabilities->block_length & SBC_BLOCK_LENGTH_4)
-        config->block_length = SBC_BLOCK_LENGTH_4;
-    else {
-        pa_log_error("No supported block lengths");
-        return 0;
-    }
+        if (is_mono) {
+            if ((capabilities->channel_mode & SBC_CHANNEL_MODE_MONO) && (capabilities_table[i].channel_mode & SBC_CHANNEL_MODE_MONO))
+                config->channel_mode = SBC_CHANNEL_MODE_MONO;
+            else if ((capabilities->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO) && (capabilities_table[i].channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO))
+                config->channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
+            else if ((capabilities->channel_mode & SBC_CHANNEL_MODE_STEREO) && (capabilities_table[i].channel_mode & SBC_CHANNEL_MODE_STEREO))
+                config->channel_mode = SBC_CHANNEL_MODE_STEREO;
+            else if ((capabilities->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL) && (capabilities_table[i].channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL))
+                config->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
+            else {
+                pa_log_debug("No supported channel mode in table entry %u", i);
+                continue;
+            }
+        } else {
+            if ((capabilities->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO) && (capabilities_table[i].channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO))
+                config->channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
+            else if ((capabilities->channel_mode & SBC_CHANNEL_MODE_STEREO) && (capabilities_table[i].channel_mode & SBC_CHANNEL_MODE_STEREO))
+                config->channel_mode = SBC_CHANNEL_MODE_STEREO;
+            else if ((capabilities->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL) && (capabilities_table[i].channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL))
+                config->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
+            else if ((capabilities->channel_mode & SBC_CHANNEL_MODE_MONO) && (capabilities_table[i].channel_mode & SBC_CHANNEL_MODE_MONO))
+                config->channel_mode = SBC_CHANNEL_MODE_MONO;
+            else {
+                pa_log_debug("No supported channel mode in table entry %u", i);
+                continue;
+            }
+        }
 
-    if (capabilities->subbands & SBC_SUBBANDS_8)
-        config->subbands = SBC_SUBBANDS_8;
-    else if (capabilities->subbands & SBC_SUBBANDS_4)
-        config->subbands = SBC_SUBBANDS_4;
-    else {
-        pa_log_error("No supported subbands");
-        return 0;
+        config->min_bitpool = PA_MAX(capabilities->min_bitpool, capabilities_table[i].min_bitpool);
+        config->max_bitpool = PA_MIN(capabilities->max_bitpool, capabilities_table[i].max_bitpool);
+
+        if (config->min_bitpool > config->max_bitpool) {
+            pa_log_debug("No supported bitpool in table entry %u [%u, %u], need [%u, %u]", i, capabilities_table[i].min_bitpool, capabilities_table[i].max_bitpool, capabilities->min_bitpool, capabilities->max_bitpool);
+            continue;
+        }
+
+        break;
     }
 
-    if (capabilities->allocation_method & SBC_ALLOCATION_LOUDNESS)
-        config->allocation_method = SBC_ALLOCATION_LOUDNESS;
-    else if (capabilities->allocation_method & SBC_ALLOCATION_SNR)
-        config->allocation_method = SBC_ALLOCATION_SNR;
-    else {
-        pa_log_error("No supported allocation method");
+    if (i == capabilities_table_elements) {
+        pa_log_error("No supported configuration");
         return 0;
     }
 
-    config->min_bitpool = (uint8_t) PA_MAX(SBC_MIN_BITPOOL, capabilities->min_bitpool);
-    config->max_bitpool = (uint8_t) PA_MIN(default_bitpool(config->frequency, config->channel_mode), capabilities->max_bitpool);
+    return sizeof(*config);
+}
 
-    if (config->min_bitpool > config->max_bitpool) {
-        pa_log_error("No supported bitpool");
-        return 0;
+static uint8_t fill_preferred_configuration_lq(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_preferred_configuration_table(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, sbc_lq_caps_table, PA_ELEMENTSOF(sbc_lq_caps_table));
+}
+
+static uint8_t fill_preferred_configuration_mq(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_preferred_configuration_table(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, sbc_mq_caps_table, PA_ELEMENTSOF(sbc_mq_caps_table));
+}
+
+static uint8_t fill_preferred_configuration_hq(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_preferred_configuration_table(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, sbc_hq_caps_table, PA_ELEMENTSOF(sbc_hq_caps_table));
+}
+
+static uint8_t fill_preferred_configuration_xq1(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_preferred_configuration_table(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, sbc_xq1_caps_table, PA_ELEMENTSOF(sbc_xq1_caps_table));
+}
+
+static uint8_t fill_preferred_configuration_xq2(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    return fill_preferred_configuration_table(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, sbc_xq2_caps_table, PA_ELEMENTSOF(sbc_xq2_caps_table));
+}
+
+static uint8_t default_bitpool(uint8_t freq, uint8_t mode) {
+    /* These bitpool values were chosen based on the A2DP spec recommendation */
+    switch (freq) {
+        case SBC_SAMPLING_FREQ_16000:
+        case SBC_SAMPLING_FREQ_32000:
+            switch (mode) {
+                case SBC_CHANNEL_MODE_MONO:
+                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
+                case SBC_CHANNEL_MODE_STEREO:
+                case SBC_CHANNEL_MODE_JOINT_STEREO:
+                    return SBC_BITPOOL_HQ_JOINT_STEREO_44100;
+            }
+            break;
+
+        case SBC_SAMPLING_FREQ_44100:
+            switch (mode) {
+                case SBC_CHANNEL_MODE_MONO:
+                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
+                    return SBC_BITPOOL_HQ_MONO_44100;
+
+                case SBC_CHANNEL_MODE_STEREO:
+                case SBC_CHANNEL_MODE_JOINT_STEREO:
+                    return SBC_BITPOOL_HQ_JOINT_STEREO_44100;
+            }
+            break;
+
+        case SBC_SAMPLING_FREQ_48000:
+            switch (mode) {
+                case SBC_CHANNEL_MODE_MONO:
+                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
+                    return SBC_BITPOOL_HQ_MONO_48000;
+
+                case SBC_CHANNEL_MODE_STEREO:
+                case SBC_CHANNEL_MODE_JOINT_STEREO:
+                    return SBC_BITPOOL_HQ_JOINT_STEREO_48000;
+            }
+            break;
     }
 
-    return sizeof(*config);
+    pa_assert_not_reached();
+}
+
+static uint8_t fill_preferred_configuration(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_sbc_t *config = (a2dp_sbc_t *) config_buffer;
+    uint8_t ret;
+
+    ret = fill_preferred_configuration_table(default_sample_spec, capabilities_buffer, capabilities_size, config_buffer, sbc_auto_caps_table, PA_ELEMENTSOF(sbc_auto_caps_table));
+    config->max_bitpool = PA_MIN(default_bitpool(config->frequency, config->channel_mode), config->max_bitpool);
+    config->max_bitpool = PA_MAX(config->max_bitpool, config->min_bitpool);
+
+    return ret;
 }
 
 static void set_params(struct sbc_info *sbc_info) {
@@ -500,13 +907,17 @@ static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
     uint8_t bitpool;
 
     /* Check if bitpool is already at its limit */
-    if (sbc_info->sbc.bitpool <= SBC_BITPOOL_DEC_LIMIT)
-        return 0;
-
-    bitpool = sbc_info->sbc.bitpool - SBC_BITPOOL_DEC_STEP;
-
-    if (bitpool < SBC_BITPOOL_DEC_LIMIT)
-        bitpool = SBC_BITPOOL_DEC_LIMIT;
+    if (sbc_info->mode == SBC_CHANNEL_MODE_MONO || sbc_info->mode == SBC_CHANNEL_MODE_DUAL_CHANNEL) {
+        /* For Mono and Dual Channel modes bitpool value is separete for each channel */
+        bitpool = sbc_info->sbc.bitpool - SBC_SEPARATE_BITPOOL_DEC_STEP;
+        if (bitpool <= SBC_SEPARATE_BITPOOL_DEC_LIMIT)
+            return 0;
+    } else {
+        /* For Stereo modes bitpool value is combined for both channels */
+        bitpool = sbc_info->sbc.bitpool - SBC_COMBINED_BITPOOL_DEC_STEP;
+        if (bitpool <= SBC_COMBINED_BITPOOL_DEC_LIMIT)
+            return 0;
+    }
 
     if (sbc_info->sbc.bitpool == bitpool)
         return 0;
@@ -515,6 +926,10 @@ static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
     return get_block_size(codec_info, write_link_mtu);
 }
 
+static size_t reduce_encoder_bitrate_none(void *codec_info, size_t write_link_mtu) {
+    return 0;
+}
+
 static size_t encode_buffer(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
     struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
     struct rtp_header *header;
@@ -661,13 +1076,73 @@ static size_t decode_buffer(void *codec_info, const uint8_t *input_buffer, size_
     return d - output_buffer;
 }
 
+const pa_a2dp_codec pa_a2dp_codec_sbc_lq = {
+    .name = "sbc_lq",
+    .description = "SBC (Low Quality)",
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities_lq,
+    .cmp_endpoints = cmp_endpoints_fixed_bitpool,
+    .fill_capabilities = fill_capabilities_lq,
+    .is_configuration_valid = is_configuration_valid_lq,
+    .fill_preferred_configuration = fill_preferred_configuration_lq,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_block_size,
+    .get_write_block_size = get_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate_none,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
+
+const pa_a2dp_codec pa_a2dp_codec_sbc_mq = {
+    .name = "sbc_mq",
+    .description = "SBC (Middle Quality)",
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities_mq,
+    .cmp_endpoints = cmp_endpoints_fixed_bitpool,
+    .fill_capabilities = fill_capabilities_mq,
+    .is_configuration_valid = is_configuration_valid_mq,
+    .fill_preferred_configuration = fill_preferred_configuration_mq,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_block_size,
+    .get_write_block_size = get_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate_none,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
+
+const pa_a2dp_codec pa_a2dp_codec_sbc_hq = {
+    .name = "sbc_hq",
+    .description = "SBC (High Quality)",
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities_hq,
+    .cmp_endpoints = cmp_endpoints_fixed_bitpool,
+    .fill_capabilities = fill_capabilities_hq,
+    .is_configuration_valid = is_configuration_valid_hq,
+    .fill_preferred_configuration = fill_preferred_configuration_hq,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_block_size,
+    .get_write_block_size = get_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate_none,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
+
 const pa_a2dp_codec pa_a2dp_codec_sbc = {
     .name = "sbc",
-    .description = "SBC",
+    .description = "SBC (Automatic Quality)",
     .id = { A2DP_CODEC_SBC, 0, 0 },
     .support_backchannel = false,
     .can_accept_capabilities = can_accept_capabilities,
-    .choose_remote_endpoint = choose_remote_endpoint,
+    .cmp_endpoints = cmp_endpoints,
     .fill_capabilities = fill_capabilities,
     .is_configuration_valid = is_configuration_valid,
     .fill_preferred_configuration = fill_preferred_configuration,
@@ -680,3 +1155,43 @@ const pa_a2dp_codec pa_a2dp_codec_sbc = {
     .encode_buffer = encode_buffer,
     .decode_buffer = decode_buffer,
 };
+
+const pa_a2dp_codec pa_a2dp_codec_sbc_xq1 = {
+    .name = "sbc_xq1",
+    .description = "SBC (eXtreme Quality profile 1)",
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities_xq1,
+    .cmp_endpoints = cmp_endpoints_fixed_bitpool,
+    .fill_capabilities = fill_capabilities_xq1,
+    .is_configuration_valid = is_configuration_valid_xq1,
+    .fill_preferred_configuration = fill_preferred_configuration_xq1,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_block_size,
+    .get_write_block_size = get_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate_none,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
+
+const pa_a2dp_codec pa_a2dp_codec_sbc_xq2 = {
+    .name = "sbc_xq2",
+    .description = "SBC (eXtreme Quality profile 2)",
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities_xq2,
+    .cmp_endpoints = cmp_endpoints_fixed_bitpool,
+    .fill_capabilities = fill_capabilities_xq2,
+    .is_configuration_valid = is_configuration_valid_xq2,
+    .fill_preferred_configuration = fill_preferred_configuration_xq2,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_block_size,
+    .get_write_block_size = get_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate_none,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
diff --git a/src/modules/bluetooth/a2dp-codec-util.c b/src/modules/bluetooth/a2dp-codec-util.c
index 94d01e7bd..a80879252 100644
--- a/src/modules/bluetooth/a2dp-codec-util.c
+++ b/src/modules/bluetooth/a2dp-codec-util.c
@@ -26,12 +26,36 @@
 
 #include "a2dp-codec-util.h"
 
+extern const pa_a2dp_codec pa_a2dp_codec_faststream;
+extern const pa_a2dp_codec pa_a2dp_codec_faststream_mic;
 extern const pa_a2dp_codec pa_a2dp_codec_sbc;
+extern const pa_a2dp_codec pa_a2dp_codec_sbc_lq;
+extern const pa_a2dp_codec pa_a2dp_codec_sbc_mq;
+extern const pa_a2dp_codec pa_a2dp_codec_sbc_hq;
+extern const pa_a2dp_codec pa_a2dp_codec_sbc_xq1;
+extern const pa_a2dp_codec pa_a2dp_codec_sbc_xq2;
+#ifdef HAVE_OPENAPTX
+extern const pa_a2dp_codec pa_a2dp_codec_aptx;
+extern const pa_a2dp_codec pa_a2dp_codec_aptx_hd;
+#endif
 
 /* This is list of supported codecs. Their order is important.
  * Codec with higher index has higher priority. */
-const pa_a2dp_codec *pa_a2dp_codecs[] = {
-    &pa_a2dp_codec_sbc,
+static const pa_a2dp_codec *pa_a2dp_codecs[] = {
+    &pa_a2dp_codec_sbc_lq,
+    &pa_a2dp_codec_faststream,        /* Exactly same as SBC-LQ, but could provide lower latency */
+    &pa_a2dp_codec_faststream_mic,    /* Exactly same as FastStream, but with voice backchannel */
+    &pa_a2dp_codec_sbc_mq,
+    &pa_a2dp_codec_sbc,               /* SBC in automatic mode, from SBC-LQ to SBC-HQ; not SBC-XQ */
+#ifdef HAVE_OPENAPTX
+    &pa_a2dp_codec_aptx,
+#endif
+    &pa_a2dp_codec_sbc_hq,            /* SBC-HQ has similar quality as aptX */
+#ifdef HAVE_OPENAPTX
+    &pa_a2dp_codec_aptx_hd,
+#endif
+    &pa_a2dp_codec_sbc_xq1,           /* SBC-XQ has similar quality as aptX-HD */
+    &pa_a2dp_codec_sbc_xq2,           /* SBC-XQ has similar quality as aptX-HD */
 };
 
 unsigned int pa_bluetooth_a2dp_codec_count(void) {
diff --git a/src/modules/bluetooth/backend-ofono.c b/src/modules/bluetooth/backend-ofono.c
deleted file mode 100644
index 0e5bbe8b7..000000000
--- a/src/modules/bluetooth/backend-ofono.c
+++ /dev/null
@@ -1,765 +0,0 @@
-/***
-  This file is part of PulseAudio.
-
-  Copyright 2013 João Paulo Rechi Vita
-
-  PulseAudio is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License as
-  published by the Free Software Foundation; either version 2.1 of the
-  License, or (at your option) any later version.
-
-  PulseAudio is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-  General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
-***/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <errno.h>
-#include <poll.h>
-
-#include <pulsecore/core-util.h>
-#include <pulsecore/dbus-shared.h>
-#include <pulsecore/shared.h>
-#include <pulsecore/core-error.h>
-
-#include "bluez5-util.h"
-
-#define HFP_AUDIO_CODEC_CVSD    0x01
-#define HFP_AUDIO_CODEC_MSBC    0x02
-
-#define OFONO_SERVICE "org.ofono"
-#define HF_AUDIO_AGENT_INTERFACE OFONO_SERVICE ".HandsfreeAudioAgent"
-#define HF_AUDIO_MANAGER_INTERFACE OFONO_SERVICE ".HandsfreeAudioManager"
-
-#define HF_AUDIO_AGENT_PATH "/HandsfreeAudioAgent"
-
-#define HF_AUDIO_AGENT_XML                                          \
-    DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                       \
-    "<node>"                                                        \
-    "  <interface name=\"org.freedesktop.DBus.Introspectable\">"    \
-    "    <method name=\"Introspect\">"                              \
-    "      <arg direction=\"out\" type=\"s\" />"                    \
-    "    </method>"                                                 \
-    "  </interface>"                                                \
-    "  <interface name=\"org.ofono.HandsfreeAudioAgent\">"          \
-    "    <method name=\"Release\">"                                 \
-    "    </method>"                                                 \
-    "    <method name=\"NewConnection\">"                           \
-    "      <arg direction=\"in\"  type=\"o\" name=\"card_path\" />" \
-    "      <arg direction=\"in\"  type=\"h\" name=\"sco_fd\" />"    \
-    "      <arg direction=\"in\"  type=\"y\" name=\"codec\" />"     \
-    "    </method>"                                                 \
-    "  </interface>"                                                \
-    "</node>"
-
-struct hf_audio_card {
-    pa_bluetooth_backend *backend;
-    char *path;
-    char *remote_address;
-    char *local_address;
-
-    bool connecting;
-    int fd;
-    int (*acquire)(struct hf_audio_card *card);
-
-    pa_bluetooth_transport *transport;
-    pa_hook_slot *device_unlink_slot;
-};
-
-struct pa_bluetooth_backend {
-    pa_core *core;
-    pa_bluetooth_discovery *discovery;
-    pa_dbus_connection *connection;
-    pa_hashmap *cards;
-    char *ofono_bus_id;
-
-    PA_LLIST_HEAD(pa_dbus_pending, pending);
-};
-
-static pa_dbus_pending* hf_dbus_send_and_add_to_pending(pa_bluetooth_backend *backend, DBusMessage *m,
-                                                    DBusPendingCallNotifyFunction func, void *call_data) {
-    pa_dbus_pending *p;
-    DBusPendingCall *call;
-
-    pa_assert(backend);
-    pa_assert(m);
-
-    pa_assert_se(dbus_connection_send_with_reply(pa_dbus_connection_get(backend->connection), m, &call, -1));
-
-    p = pa_dbus_pending_new(pa_dbus_connection_get(backend->connection), m, call, backend, call_data);
-    PA_LLIST_PREPEND(pa_dbus_pending, backend->pending, p);
-    dbus_pending_call_set_notify(call, func, p, NULL);
-
-    return p;
-}
-
-static DBusMessage *card_send(struct hf_audio_card *card, const char *method, DBusError *err)
-{
-    pa_bluetooth_transport *t = card->transport;
-    DBusMessage *m, *r;
-
-    pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, "org.ofono.HandsfreeAudioCard", method));
-    r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(card->backend->connection), m, -1, err);
-    dbus_message_unref(m);
-
-    return r;
-}
-
-static int card_connect(struct hf_audio_card *card) {
-    DBusMessage *r;
-    DBusError err;
-
-    if (card->connecting)
-        return -EAGAIN;
-
-    card->connecting = true;
-
-    dbus_error_init(&err);
-    r = card_send(card, "Connect", &err);
-
-    if (!r) {
-        pa_log_error("Failed to connect %s: %s", err.name, err.message);
-        card->connecting = false;
-        dbus_error_free(&err);
-        return -1;
-    }
-
-    dbus_message_unref(r);
-
-    if (card->connecting)
-        return -EAGAIN;
-
-    return 0;
-}
-
-static int card_acquire(struct hf_audio_card *card) {
-    int fd;
-    uint8_t codec;
-    DBusMessage *r;
-    DBusError err;
-
-    /* Try acquiring the stream first which was introduced in 1.21 */
-    dbus_error_init(&err);
-    r = card_send(card, "Acquire", &err);
-
-    if (!r) {
-        if (!pa_streq(err.name, DBUS_ERROR_UNKNOWN_METHOD)) {
-            pa_log_error("Failed to acquire %s: %s", err.name, err.message);
-            dbus_error_free(&err);
-            return -1;
-        }
-        dbus_error_free(&err);
-        /* Fallback to Connect as this might be an old version of ofono */
-        card->acquire = card_connect;
-        return card_connect(card);
-    }
-
-    if ((dbus_message_get_args(r, NULL, DBUS_TYPE_UNIX_FD, &fd,
-                                      DBUS_TYPE_BYTE, &codec,
-                                      DBUS_TYPE_INVALID) == true)) {
-        dbus_message_unref(r);
-        if (codec != HFP_AUDIO_CODEC_CVSD) {
-            pa_log_error("Invalid codec: %u", codec);
-            /* shutdown to make sure connection is dropped immediately */
-            shutdown(fd, SHUT_RDWR);
-            close(fd);
-            return -1;
-        }
-        card->transport->codec = codec;
-        card->fd = fd;
-        return 0;
-    }
-
-    pa_log_error("Unable to acquire");
-    dbus_message_unref(r);
-    return -1;
-}
-
-static void hf_audio_agent_card_removed(pa_bluetooth_backend *backend, const char *path);
-
-static pa_hook_result_t device_unlink_cb(pa_bluetooth_discovery *y, const pa_bluetooth_device *d, struct hf_audio_card *card) {
-    pa_assert(d);
-    pa_assert(card);
-
-    hf_audio_agent_card_removed(card->backend, card->path);
-
-    return PA_HOOK_OK;
-}
-
-static struct hf_audio_card *hf_audio_card_new(pa_bluetooth_backend *backend, const char *path) {
-    struct hf_audio_card *card = pa_xnew0(struct hf_audio_card, 1);
-
-    card->path = pa_xstrdup(path);
-    card->backend = backend;
-    card->fd = -1;
-    card->acquire = card_acquire;
-
-    card->device_unlink_slot = pa_hook_connect(pa_bluetooth_discovery_hook(backend->discovery, PA_BLUETOOTH_HOOK_DEVICE_UNLINK),
-                                               PA_HOOK_NORMAL, (pa_hook_cb_t) device_unlink_cb, card);
-
-    return card;
-}
-
-static void hf_audio_card_free(struct hf_audio_card *card) {
-    pa_assert(card);
-
-    if (card->device_unlink_slot)
-        pa_hook_slot_free(card->device_unlink_slot);
-
-    if (card->transport)
-        pa_bluetooth_transport_free(card->transport);
-
-    pa_xfree(card->path);
-    pa_xfree(card->remote_address);
-    pa_xfree(card->local_address);
-    pa_xfree(card);
-}
-
-static int socket_accept(int sock)
-{
-    char c;
-    struct pollfd pfd;
-
-    if (sock < 0)
-        return -ENOTCONN;
-
-    memset(&pfd, 0, sizeof(pfd));
-    pfd.fd = sock;
-    pfd.events = POLLOUT;
-
-    if (poll(&pfd, 1, 0) < 0)
-        return -errno;
-
-    /*
-     * If socket already writable then it is not in defer setup state,
-     * otherwise it needs to be read to authorize the connection.
-     */
-    if ((pfd.revents & POLLOUT))
-        return 0;
-
-    /* Enable socket by reading 1 byte */
-    if (read(sock, &c, 1) < 0)
-        return -errno;
-
-    return 0;
-}
-
-static int hf_audio_agent_transport_acquire(pa_bluetooth_transport *t, bool optional, size_t *imtu, size_t *omtu) {
-    struct hf_audio_card *card = t->userdata;
-    int err;
-
-    pa_assert(card);
-
-    if (!optional && card->fd < 0) {
-        err = card->acquire(card);
-        if (err < 0)
-            return err;
-    }
-
-    /* The correct block size should take into account the SCO MTU from
-     * the Bluetooth adapter and (for adapters in the USB bus) the MxPS
-     * value from the Isoc USB endpoint in use by btusb and should be
-     * made available to userspace by the Bluetooth kernel subsystem.
-     * Meanwhile the empiric value 48 will be used. */
-    if (imtu)
-        *imtu = 48;
-    if (omtu)
-        *omtu = 48;
-
-    err = socket_accept(card->fd);
-    if (err < 0) {
-        pa_log_error("Deferred setup failed on fd %d: %s", card->fd, pa_cstrerror(-err));
-        return -1;
-    }
-
-    return card->fd;
-}
-
-static void hf_audio_agent_transport_release(pa_bluetooth_transport *t) {
-    struct hf_audio_card *card = t->userdata;
-
-    pa_assert(card);
-
-    if (card->fd < 0) {
-        pa_log_info("Transport %s already released", t->path);
-        return;
-    }
-
-    /* shutdown to make sure connection is dropped immediately */
-    shutdown(card->fd, SHUT_RDWR);
-    close(card->fd);
-    card->fd = -1;
-}
-
-static void hf_audio_agent_card_found(pa_bluetooth_backend *backend, const char *path, DBusMessageIter *props_i) {
-    DBusMessageIter i, value_i;
-    const char *key, *value;
-    struct hf_audio_card *card;
-    pa_bluetooth_device *d;
-    pa_bluetooth_profile_t p = PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY;
-
-    pa_assert(backend);
-    pa_assert(path);
-    pa_assert(props_i);
-
-    pa_log_debug("New HF card found: %s", path);
-
-    card = hf_audio_card_new(backend, path);
-
-    while (dbus_message_iter_get_arg_type(props_i) != DBUS_TYPE_INVALID) {
-        char c;
-
-        dbus_message_iter_recurse(props_i, &i);
-
-        dbus_message_iter_get_basic(&i, &key);
-        dbus_message_iter_next(&i);
-        dbus_message_iter_recurse(&i, &value_i);
-
-        if ((c = dbus_message_iter_get_arg_type(&value_i)) != DBUS_TYPE_STRING) {
-            pa_log_error("Invalid properties for %s: expected 's', received '%c'", path, c);
-            goto fail;
-        }
-
-        dbus_message_iter_get_basic(&value_i, &value);
-
-        if (pa_streq(key, "RemoteAddress")) {
-            pa_xfree(card->remote_address);
-            card->remote_address = pa_xstrdup(value);
-        } else if (pa_streq(key, "LocalAddress")) {
-            pa_xfree(card->local_address);
-            card->local_address = pa_xstrdup(value);
-        } else if (pa_streq(key, "Type")) {
-            if (pa_streq(value, "gateway"))
-                p = PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT;
-        }
-
-        pa_log_debug("%s: %s", key, value);
-
-        dbus_message_iter_next(props_i);
-    }
-
-    d = pa_bluetooth_discovery_get_device_by_address(backend->discovery, card->remote_address, card->local_address);
-    if (!d) {
-        pa_log_error("Device doesnt exist for %s", path);
-        goto fail;
-    }
-
-    card->transport = pa_bluetooth_transport_new(d, backend->ofono_bus_id, path, p, NULL, 0);
-    card->transport->acquire = hf_audio_agent_transport_acquire;
-    card->transport->release = hf_audio_agent_transport_release;
-    card->transport->userdata = card;
-
-    pa_bluetooth_transport_put(card->transport);
-    pa_hashmap_put(backend->cards, card->path, card);
-
-    return;
-
-fail:
-    hf_audio_card_free(card);
-}
-
-static void hf_audio_agent_card_removed(pa_bluetooth_backend *backend, const char *path) {
-    struct hf_audio_card *card;
-
-    pa_assert(backend);
-    pa_assert(path);
-
-    pa_log_debug("HF card removed: %s", path);
-
-    card = pa_hashmap_remove(backend->cards, path);
-    if (!card)
-        return;
-
-    hf_audio_card_free(card);
-}
-
-static void hf_audio_agent_get_cards_reply(DBusPendingCall *pending, void *userdata) {
-    DBusMessage *r;
-    pa_dbus_pending *p;
-    pa_bluetooth_backend *backend;
-    DBusMessageIter i, array_i, struct_i, props_i;
-
-    pa_assert_se(p = userdata);
-    pa_assert_se(backend = p->context_data);
-    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
-
-    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
-        pa_log_error("Failed to get a list of handsfree audio cards from ofono: %s: %s",
-                     dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
-        goto finish;
-    }
-
-    if (!dbus_message_iter_init(r, &i) || !pa_streq(dbus_message_get_signature(r), "a(oa{sv})")) {
-        pa_log_error("Invalid arguments in GetCards() reply");
-        goto finish;
-    }
-
-    dbus_message_iter_recurse(&i, &array_i);
-    while (dbus_message_iter_get_arg_type(&array_i) != DBUS_TYPE_INVALID) {
-        const char *path;
-
-        dbus_message_iter_recurse(&array_i, &struct_i);
-        dbus_message_iter_get_basic(&struct_i, &path);
-        dbus_message_iter_next(&struct_i);
-
-        dbus_message_iter_recurse(&struct_i, &props_i);
-
-        hf_audio_agent_card_found(backend, path, &props_i);
-
-        dbus_message_iter_next(&array_i);
-    }
-
-finish:
-    dbus_message_unref(r);
-
-    PA_LLIST_REMOVE(pa_dbus_pending, backend->pending, p);
-    pa_dbus_pending_free(p);
-}
-
-static void hf_audio_agent_get_cards(pa_bluetooth_backend *hf) {
-    DBusMessage *m;
-
-    pa_assert(hf);
-
-    pa_assert_se(m = dbus_message_new_method_call(OFONO_SERVICE, "/", HF_AUDIO_MANAGER_INTERFACE, "GetCards"));
-    hf_dbus_send_and_add_to_pending(hf, m, hf_audio_agent_get_cards_reply, NULL);
-}
-
-static void ofono_bus_id_destroy(pa_bluetooth_backend *backend) {
-    pa_hashmap_remove_all(backend->cards);
-
-    if (backend->ofono_bus_id) {
-        pa_xfree(backend->ofono_bus_id);
-        backend->ofono_bus_id = NULL;
-        pa_bluetooth_discovery_set_ofono_running(backend->discovery, false);
-    }
-}
-
-static void hf_audio_agent_register_reply(DBusPendingCall *pending, void *userdata) {
-    DBusMessage *r;
-    pa_dbus_pending *p;
-    pa_bluetooth_backend *backend;
-
-    pa_assert_se(p = userdata);
-    pa_assert_se(backend = p->context_data);
-    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
-
-    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
-        pa_log_info("Failed to register as a handsfree audio agent with ofono: %s: %s",
-                    dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
-        goto finish;
-    }
-
-    backend->ofono_bus_id = pa_xstrdup(dbus_message_get_sender(r));
-
-    hf_audio_agent_get_cards(backend);
-
-finish:
-    dbus_message_unref(r);
-
-    PA_LLIST_REMOVE(pa_dbus_pending, backend->pending, p);
-    pa_dbus_pending_free(p);
-
-    pa_bluetooth_discovery_set_ofono_running(backend->discovery, backend->ofono_bus_id != NULL);
-}
-
-static void hf_audio_agent_register(pa_bluetooth_backend *hf) {
-    DBusMessage *m;
-    uint8_t codecs[2];
-    const uint8_t *pcodecs = codecs;
-    int ncodecs = 0;
-    const char *path = HF_AUDIO_AGENT_PATH;
-
-    pa_assert(hf);
-
-    pa_assert_se(m = dbus_message_new_method_call(OFONO_SERVICE, "/", HF_AUDIO_MANAGER_INTERFACE, "Register"));
-
-    codecs[ncodecs++] = HFP_AUDIO_CODEC_CVSD;
-
-    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &pcodecs, ncodecs,
-                                          DBUS_TYPE_INVALID));
-
-    hf_dbus_send_and_add_to_pending(hf, m, hf_audio_agent_register_reply, NULL);
-}
-
-static void hf_audio_agent_unregister(pa_bluetooth_backend *backend) {
-    DBusMessage *m;
-    const char *path = HF_AUDIO_AGENT_PATH;
-
-    pa_assert(backend);
-    pa_assert(backend->connection);
-
-    if (backend->ofono_bus_id) {
-        pa_assert_se(m = dbus_message_new_method_call(backend->ofono_bus_id, "/", HF_AUDIO_MANAGER_INTERFACE, "Unregister"));
-        pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_INVALID));
-        pa_assert_se(dbus_connection_send(pa_dbus_connection_get(backend->connection), m, NULL));
-
-        ofono_bus_id_destroy(backend);
-    }
-}
-
-static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *data) {
-    const char *sender;
-    DBusError err;
-    pa_bluetooth_backend *backend = data;
-
-    pa_assert(bus);
-    pa_assert(m);
-    pa_assert(backend);
-
-    sender = dbus_message_get_sender(m);
-    if (!pa_safe_streq(backend->ofono_bus_id, sender) && !pa_streq("org.freedesktop.DBus", sender))
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    dbus_error_init(&err);
-
-    if (dbus_message_is_signal(m, "org.freedesktop.DBus", "NameOwnerChanged")) {
-        const char *name, *old_owner, *new_owner;
-
-        if (!dbus_message_get_args(m, &err,
-                                   DBUS_TYPE_STRING, &name,
-                                   DBUS_TYPE_STRING, &old_owner,
-                                   DBUS_TYPE_STRING, &new_owner,
-                                   DBUS_TYPE_INVALID)) {
-            pa_log_error("Failed to parse org.freedesktop.DBus.NameOwnerChanged: %s", err.message);
-            goto fail;
-        }
-
-        if (pa_streq(name, OFONO_SERVICE)) {
-
-            if (old_owner && *old_owner) {
-                pa_log_debug("oFono disappeared");
-                ofono_bus_id_destroy(backend);
-            }
-
-            if (new_owner && *new_owner) {
-                pa_log_debug("oFono appeared");
-                hf_audio_agent_register(backend);
-            }
-        }
-
-    } else if (dbus_message_is_signal(m, "org.ofono.HandsfreeAudioManager", "CardAdded")) {
-        const char *p;
-        DBusMessageIter arg_i, props_i;
-
-        if (!dbus_message_iter_init(m, &arg_i) || !pa_streq(dbus_message_get_signature(m), "oa{sv}")) {
-            pa_log_error("Failed to parse org.ofono.HandsfreeAudioManager.CardAdded");
-            goto fail;
-        }
-
-        dbus_message_iter_get_basic(&arg_i, &p);
-
-        pa_assert_se(dbus_message_iter_next(&arg_i));
-        pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_ARRAY);
-
-        dbus_message_iter_recurse(&arg_i, &props_i);
-
-        hf_audio_agent_card_found(backend, p, &props_i);
-    } else if (dbus_message_is_signal(m, "org.ofono.HandsfreeAudioManager", "CardRemoved")) {
-        const char *p;
-
-        if (!dbus_message_get_args(m, &err, DBUS_TYPE_OBJECT_PATH, &p, DBUS_TYPE_INVALID)) {
-            pa_log_error("Failed to parse org.ofono.HandsfreeAudioManager.CardRemoved: %s", err.message);
-            goto fail;
-        }
-
-        hf_audio_agent_card_removed(backend, p);
-    }
-
-fail:
-    dbus_error_free(&err);
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-static DBusMessage *hf_audio_agent_release(DBusConnection *c, DBusMessage *m, void *data) {
-    DBusMessage *r;
-    const char *sender;
-    pa_bluetooth_backend *backend = data;
-
-    pa_assert(backend);
-
-    sender = dbus_message_get_sender(m);
-    if (!pa_safe_streq(backend->ofono_bus_id, sender)) {
-        pa_assert_se(r = dbus_message_new_error(m, "org.ofono.Error.NotAllowed", "Operation is not allowed by this sender"));
-        return r;
-    }
-
-    pa_log_debug("HF audio agent has been unregistered by oFono (%s)", backend->ofono_bus_id);
-
-    ofono_bus_id_destroy(backend);
-
-    pa_assert_se(r = dbus_message_new_method_return(m));
-
-    return r;
-}
-
-static DBusMessage *hf_audio_agent_new_connection(DBusConnection *c, DBusMessage *m, void *data) {
-    DBusMessage *r;
-    const char *sender, *path;
-    int fd;
-    uint8_t codec;
-    struct hf_audio_card *card;
-    pa_bluetooth_backend *backend = data;
-
-    pa_assert(backend);
-
-    sender = dbus_message_get_sender(m);
-    if (!pa_safe_streq(backend->ofono_bus_id, sender)) {
-        pa_assert_se(r = dbus_message_new_error(m, "org.ofono.Error.NotAllowed", "Operation is not allowed by this sender"));
-        return r;
-    }
-
-    if (dbus_message_get_args(m, NULL,
-                              DBUS_TYPE_OBJECT_PATH, &path,
-                              DBUS_TYPE_UNIX_FD, &fd,
-                              DBUS_TYPE_BYTE, &codec,
-                              DBUS_TYPE_INVALID) == FALSE) {
-        pa_assert_se(r = dbus_message_new_error(m, "org.ofono.Error.InvalidArguments", "Invalid arguments in method call"));
-        return r;
-    }
-
-    card = pa_hashmap_get(backend->cards, path);
-
-    card->connecting = false;
-
-    if (!card || codec != HFP_AUDIO_CODEC_CVSD || card->fd >= 0) {
-        pa_log_warn("New audio connection invalid arguments (path=%s fd=%d, codec=%d)", path, fd, codec);
-        pa_assert_se(r = dbus_message_new_error(m, "org.ofono.Error.InvalidArguments", "Invalid arguments in method call"));
-        shutdown(fd, SHUT_RDWR);
-        close(fd);
-        return r;
-    }
-
-    pa_log_debug("New audio connection on card %s (fd=%d, codec=%d)", path, fd, codec);
-
-    card->fd = fd;
-    card->transport->codec = codec;
-
-    pa_bluetooth_transport_set_state(card->transport, PA_BLUETOOTH_TRANSPORT_STATE_PLAYING);
-
-    pa_assert_se(r = dbus_message_new_method_return(m));
-
-    return r;
-}
-
-static DBusHandlerResult hf_audio_agent_handler(DBusConnection *c, DBusMessage *m, void *data) {
-    pa_bluetooth_backend *backend = data;
-    DBusMessage *r = NULL;
-    const char *path, *interface, *member;
-
-    pa_assert(backend);
-
-    path = dbus_message_get_path(m);
-    interface = dbus_message_get_interface(m);
-    member = dbus_message_get_member(m);
-
-    if (!pa_streq(path, HF_AUDIO_AGENT_PATH))
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
-
-    if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
-        const char *xml = HF_AUDIO_AGENT_XML;
-
-        pa_assert_se(r = dbus_message_new_method_return(m));
-        pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_STRING, &xml, DBUS_TYPE_INVALID));
-
-    } else if (dbus_message_is_method_call(m, HF_AUDIO_AGENT_INTERFACE, "NewConnection"))
-        r = hf_audio_agent_new_connection(c, m, data);
-    else if (dbus_message_is_method_call(m, HF_AUDIO_AGENT_INTERFACE, "Release"))
-        r = hf_audio_agent_release(c, m, data);
-    else
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    if (r) {
-        pa_assert_se(dbus_connection_send(pa_dbus_connection_get(backend->connection), r, NULL));
-        dbus_message_unref(r);
-    }
-
-    return DBUS_HANDLER_RESULT_HANDLED;
-}
-
-pa_bluetooth_backend *pa_bluetooth_ofono_backend_new(pa_core *c, pa_bluetooth_discovery *y) {
-    pa_bluetooth_backend *backend;
-    DBusError err;
-    static const DBusObjectPathVTable vtable_hf_audio_agent = {
-        .message_function = hf_audio_agent_handler,
-    };
-
-    pa_assert(c);
-
-    backend = pa_xnew0(pa_bluetooth_backend, 1);
-    backend->core = c;
-    backend->discovery = y;
-    backend->cards = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL,
-                                         (pa_free_cb_t) hf_audio_card_free);
-
-    dbus_error_init(&err);
-
-    if (!(backend->connection = pa_dbus_bus_get(c, DBUS_BUS_SYSTEM, &err))) {
-        pa_log("Failed to get D-Bus connection: %s", err.message);
-        dbus_error_free(&err);
-        pa_xfree(backend);
-        return NULL;
-    }
-
-    /* dynamic detection of handsfree audio cards */
-    if (!dbus_connection_add_filter(pa_dbus_connection_get(backend->connection), filter_cb, backend, NULL)) {
-        pa_log_error("Failed to add filter function");
-        pa_dbus_connection_unref(backend->connection);
-        pa_xfree(backend);
-        return NULL;
-    }
-
-    if (pa_dbus_add_matches(pa_dbus_connection_get(backend->connection), &err,
-            "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',"
-            "arg0='" OFONO_SERVICE "'",
-            "type='signal',sender='" OFONO_SERVICE "',interface='" HF_AUDIO_MANAGER_INTERFACE "',member='CardAdded'",
-            "type='signal',sender='" OFONO_SERVICE "',interface='" HF_AUDIO_MANAGER_INTERFACE "',member='CardRemoved'",
-            NULL) < 0) {
-        pa_log("Failed to add oFono D-Bus matches: %s", err.message);
-        dbus_connection_remove_filter(pa_dbus_connection_get(backend->connection), filter_cb, backend);
-        pa_dbus_connection_unref(backend->connection);
-        pa_xfree(backend);
-        return NULL;
-    }
-
-    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(backend->connection), HF_AUDIO_AGENT_PATH,
-                                                      &vtable_hf_audio_agent, backend));
-
-    hf_audio_agent_register(backend);
-
-    return backend;
-}
-
-void pa_bluetooth_ofono_backend_free(pa_bluetooth_backend *backend) {
-    pa_assert(backend);
-
-    pa_dbus_free_pending_list(&backend->pending);
-
-    hf_audio_agent_unregister(backend);
-
-    dbus_connection_unregister_object_path(pa_dbus_connection_get(backend->connection), HF_AUDIO_AGENT_PATH);
-
-    pa_dbus_remove_matches(pa_dbus_connection_get(backend->connection),
-            "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',"
-            "arg0='" OFONO_SERVICE "'",
-            "type='signal',sender='" OFONO_SERVICE "',interface='" HF_AUDIO_MANAGER_INTERFACE "',member='CardAdded'",
-            "type='signal',sender='" OFONO_SERVICE "',interface='" HF_AUDIO_MANAGER_INTERFACE "',member='CardRemoved'",
-            NULL);
-
-    dbus_connection_remove_filter(pa_dbus_connection_get(backend->connection), filter_cb, backend);
-
-    pa_dbus_connection_unref(backend->connection);
-
-    pa_hashmap_free(backend->cards);
-
-    pa_xfree(backend);
-}
diff --git a/src/modules/bluetooth/bluez5-util.c b/src/modules/bluetooth/bluez5-util.c
index a21896ede..ed405f449 100644
--- a/src/modules/bluetooth/bluez5-util.c
+++ b/src/modules/bluetooth/bluez5-util.c
@@ -22,6 +22,8 @@
 #include <config.h>
 #endif
 
+#include <errno.h>
+
 #include <pulse/rtclock.h>
 #include <pulse/timeval.h>
 #include <pulse/xmalloc.h>
@@ -38,9 +40,12 @@
 #include "a2dp-codecs.h"
 
 #include "bluez5-util.h"
+#include "hsphfpd-util.h"
 
 #define WAIT_FOR_PROFILES_TIMEOUT_USEC (3 * PA_USEC_PER_SEC)
 
+#define A2DP_MAX_GAIN 127
+
 #define BLUEZ_SERVICE "org.bluez"
 #define BLUEZ_ADAPTER_INTERFACE BLUEZ_SERVICE ".Adapter1"
 #define BLUEZ_DEVICE_INTERFACE BLUEZ_SERVICE ".Device1"
@@ -49,34 +54,61 @@
 #define BLUEZ_MEDIA_TRANSPORT_INTERFACE BLUEZ_SERVICE ".MediaTransport1"
 
 #define BLUEZ_ERROR_NOT_SUPPORTED "org.bluez.Error.NotSupported"
-
-#define A2DP_SOURCE_ENDPOINT "/MediaEndpoint/A2DPSource"
-#define A2DP_SINK_ENDPOINT "/MediaEndpoint/A2DPSink"
+#define BLUEZ_ERROR_NOT_AVAILABLE "org.bluez.Error.NotAvailable"
+
+#define A2DP_OBJECT_MANAGER_PATH "/A2DPEndpoint"
+#define A2DP_SOURCE_ENDPOINT A2DP_OBJECT_MANAGER_PATH "/Source"
+#define A2DP_SINK_ENDPOINT A2DP_OBJECT_MANAGER_PATH "/Sink"
+
+#define OBJECT_MANAGER_INTROSPECT_XML                                          \
+    DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                                  \
+    "<node>\n"                                                                 \
+    " <interface name=\"org.freedesktop.DBus.ObjectManager\">\n"               \
+    "  <method name=\"GetManagedObjects\">\n"                                  \
+    "   <arg name=\"objects\" direction=\"out\" type=\"a{oa{sa{sv}}}\"/>\n"    \
+    "  </method>\n"                                                            \
+    "  <signal name=\"InterfacesAdded\">\n"                                    \
+    "   <arg name=\"object\" type=\"o\"/>\n"                                   \
+    "   <arg name=\"interfaces\" type=\"a{sa{sv}}\"/>\n"                       \
+    "  </signal>\n"                                                            \
+    "  <signal name=\"InterfacesRemoved\">\n"                                  \
+    "   <arg name=\"object\" type=\"o\"/>\n"                                   \
+    "   <arg name=\"interfaces\" type=\"as\"/>\n"                              \
+    "  </signal>\n"                                                            \
+    " </interface>\n"                                                          \
+    " <interface name=\"org.freedesktop.DBus.Introspectable\">\n"              \
+    "  <method name=\"Introspect\">\n"                                         \
+    "   <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"                   \
+    "  </method>\n"                                                            \
+    " </interface>\n"                                                          \
+    " <node name=\"Sink\"/>\n"                                                 \
+    " <node name=\"Source\"/>\n"                                               \
+    "</node>\n"
 
 #define ENDPOINT_INTROSPECT_XML                                         \
     DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                           \
-    "<node>"                                                            \
-    " <interface name=\"" BLUEZ_MEDIA_ENDPOINT_INTERFACE "\">"          \
-    "  <method name=\"SetConfiguration\">"                              \
-    "   <arg name=\"transport\" direction=\"in\" type=\"o\"/>"          \
-    "   <arg name=\"properties\" direction=\"in\" type=\"ay\"/>"        \
-    "  </method>"                                                       \
-    "  <method name=\"SelectConfiguration\">"                           \
-    "   <arg name=\"capabilities\" direction=\"in\" type=\"ay\"/>"      \
-    "   <arg name=\"configuration\" direction=\"out\" type=\"ay\"/>"    \
-    "  </method>"                                                       \
-    "  <method name=\"ClearConfiguration\">"                            \
-    "   <arg name=\"transport\" direction=\"in\" type=\"o\"/>"          \
-    "  </method>"                                                       \
-    "  <method name=\"Release\">"                                       \
-    "  </method>"                                                       \
-    " </interface>"                                                     \
-    " <interface name=\"org.freedesktop.DBus.Introspectable\">"         \
-    "  <method name=\"Introspect\">"                                    \
-    "   <arg name=\"data\" type=\"s\" direction=\"out\"/>"              \
-    "  </method>"                                                       \
-    " </interface>"                                                     \
-    "</node>"
+    "<node>\n"                                                          \
+    " <interface name=\"" BLUEZ_MEDIA_ENDPOINT_INTERFACE "\">\n"        \
+    "  <method name=\"SetConfiguration\">\n"                            \
+    "   <arg name=\"transport\" direction=\"in\" type=\"o\"/>\n"        \
+    "   <arg name=\"properties\" direction=\"in\" type=\"ay\"/>\n"      \
+    "  </method>\n"                                                     \
+    "  <method name=\"SelectConfiguration\">\n"                         \
+    "   <arg name=\"capabilities\" direction=\"in\" type=\"ay\"/>\n"    \
+    "   <arg name=\"configuration\" direction=\"out\" type=\"ay\"/>\n"  \
+    "  </method>\n"                                                     \
+    "  <method name=\"ClearConfiguration\">\n"                          \
+    "   <arg name=\"transport\" direction=\"in\" type=\"o\"/>\n"        \
+    "  </method>\n"                                                     \
+    "  <method name=\"Release\">\n"                                     \
+    "  </method>\n"                                                     \
+    " </interface>\n"                                                   \
+    " <interface name=\"org.freedesktop.DBus.Introspectable\">\n"       \
+    "  <method name=\"Introspect\">\n"                                  \
+    "   <arg name=\"data\" type=\"s\" direction=\"out\"/>\n"            \
+    "  </method>\n"                                                     \
+    " </interface>\n"                                                   \
+    "</node>\n"
 
 struct pa_bluetooth_discovery {
     PA_REFCNT_DECLARE;
@@ -90,12 +122,23 @@ struct pa_bluetooth_discovery {
     pa_hashmap *adapters;
     pa_hashmap *devices;
     pa_hashmap *transports;
-
-    int headset_backend;
-    pa_bluetooth_backend *ofono_backend, *native_backend;
+    pa_hashmap *pending_transport_fds;
+    pa_bluetooth_hsphfpd *hsphfpd;
     PA_LLIST_HEAD(pa_dbus_pending, pending);
 };
 
+struct pending_transport_fd {
+    pa_bluetooth_discovery *discovery;
+    char *path;
+    size_t imtu, omtu;
+    int fd;
+};
+
+struct a2dp_codec_capabilities {
+    uint8_t size;
+    uint8_t buffer[]; /* max size is 254 bytes */
+};
+
 static pa_dbus_pending* send_and_add_to_pending(pa_bluetooth_discovery *y, DBusMessage *m,
                                                                   DBusPendingCallNotifyFunction func, void *call_data) {
     pa_dbus_pending *p;
@@ -171,23 +214,50 @@ static const char *transport_state_to_string(pa_bluetooth_transport_state_t stat
 }
 
 static bool device_supports_profile(pa_bluetooth_device *device, pa_bluetooth_profile_t profile) {
+    const struct a2dp_codec_capabilities *a2dp_codec_capabilities;
+    const pa_a2dp_codec *a2dp_codec;
+    bool is_a2dp_sink;
+    pa_hashmap *endpoints;
+    void *state;
+
     switch (profile) {
-        case PA_BLUETOOTH_PROFILE_A2DP_SINK:
-            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SINK);
-        case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SOURCE);
-        case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
+        case PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT:
             return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_HS)
-                || !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_HS_ALT)
-                || !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_HF);
-        case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
-            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_AG)
-                || !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_AG);
+                || !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_HS_ALT);
+        case PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT:
+            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_HF);
+        case PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY:
+            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_AG);
+        case PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY:
+            return !!pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HFP_AG);
         case PA_BLUETOOTH_PROFILE_OFF:
-            pa_assert_not_reached();
+            return true;
+        default:
+            break;
+    }
+
+    a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(profile);
+    is_a2dp_sink = pa_bluetooth_profile_is_a2dp_sink(profile);
+
+    if (is_a2dp_sink && !pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SINK))
+        return false;
+    else if (!is_a2dp_sink && !pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SOURCE))
+        return false;
+
+    if (is_a2dp_sink)
+        endpoints = pa_hashmap_get(device->a2dp_sink_endpoints, &a2dp_codec->id);
+    else
+        endpoints = pa_hashmap_get(device->a2dp_source_endpoints, &a2dp_codec->id);
+
+    if (!endpoints)
+        return false;
+
+    PA_HASHMAP_FOREACH(a2dp_codec_capabilities, endpoints, state) {
+        if (a2dp_codec->can_accept_capabilities(a2dp_codec_capabilities->buffer, a2dp_codec_capabilities->size, is_a2dp_sink))
+            return true;
     }
 
-    pa_assert_not_reached();
+    return false;
 }
 
 static bool device_is_profile_connected(pa_bluetooth_device *device, pa_bluetooth_profile_t profile) {
@@ -197,18 +267,29 @@ static bool device_is_profile_connected(pa_bluetooth_device *device, pa_bluetoot
         return false;
 }
 
-static unsigned device_count_disconnected_profiles(pa_bluetooth_device *device) {
+static unsigned device_count_disconnected_profile_uuids(pa_bluetooth_device *device) {
     pa_bluetooth_profile_t profile;
+    unsigned bluetooth_profile_count;
     unsigned count = 0;
 
-    for (profile = 0; profile < PA_BLUETOOTH_PROFILE_COUNT; profile++) {
-        if (!device_supports_profile(device, profile))
+    bluetooth_profile_count = pa_bluetooth_profile_count();
+    for (profile = 0; profile < bluetooth_profile_count; profile++) {
+        if (profile == PA_BLUETOOTH_PROFILE_OFF)
+            continue;
+
+        if (!device_supports_profile(device, profile) || pa_bluetooth_profile_is_a2dp(profile))
             continue;
 
         if (!device_is_profile_connected(device, profile))
             count++;
     }
 
+    if (pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SINK) && !pa_bluetooth_device_a2dp_sink_transport_connected(device))
+        count++;
+
+    if (pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_A2DP_SOURCE) && !pa_bluetooth_device_a2dp_source_transport_connected(device))
+        count++;
+
     return count;
 }
 
@@ -224,6 +305,7 @@ static void wait_for_profiles_cb(pa_mainloop_api *api, pa_time_event* event, con
     pa_bluetooth_device *device = userdata;
     pa_strbuf *buf;
     pa_bluetooth_profile_t profile;
+    unsigned bluetooth_profile_count;
     bool first = true;
     char *profiles_str;
 
@@ -231,7 +313,11 @@ static void wait_for_profiles_cb(pa_mainloop_api *api, pa_time_event* event, con
 
     buf = pa_strbuf_new();
 
-    for (profile = 0; profile < PA_BLUETOOTH_PROFILE_COUNT; profile++) {
+    bluetooth_profile_count = pa_bluetooth_profile_count();
+    for (profile = 0; profile < bluetooth_profile_count; profile++) {
+        if (profile == PA_BLUETOOTH_PROFILE_OFF)
+            continue;
+
         if (device_is_profile_connected(device, profile))
             continue;
 
@@ -262,7 +348,7 @@ static void device_start_waiting_for_profiles(pa_bluetooth_device *device) {
 
 void pa_bluetooth_transport_set_state(pa_bluetooth_transport *t, pa_bluetooth_transport_state_t state) {
     bool old_any_connected;
-    unsigned n_disconnected_profiles;
+    unsigned n_disconnected_profile_uuids;
     bool new_device_appeared;
     bool device_disconnected;
 
@@ -288,13 +374,13 @@ void pa_bluetooth_transport_set_state(pa_bluetooth_transport *t, pa_bluetooth_tr
      * which would prevent module-card-restore from restoring the initial
      * profile properly. */
 
-    n_disconnected_profiles = device_count_disconnected_profiles(t->device);
+    n_disconnected_profile_uuids = device_count_disconnected_profile_uuids(t->device);
 
     new_device_appeared = !old_any_connected && pa_bluetooth_device_any_transport_connected(t->device);
     device_disconnected = old_any_connected && !pa_bluetooth_device_any_transport_connected(t->device);
 
     if (new_device_appeared) {
-        if (n_disconnected_profiles > 0)
+        if (n_disconnected_profile_uuids > 0)
             device_start_waiting_for_profiles(t->device);
         else
             pa_hook_fire(&t->device->discovery->hooks[PA_BLUETOOTH_HOOK_DEVICE_CONNECTION_CHANGED], t->device);
@@ -313,7 +399,7 @@ void pa_bluetooth_transport_set_state(pa_bluetooth_transport *t, pa_bluetooth_tr
         return;
     }
 
-    if (n_disconnected_profiles == 0 && t->device->wait_for_profiles_timer) {
+    if (n_disconnected_profile_uuids == 0 && t->device->wait_for_profiles_timer) {
         /* All profiles are now connected, so we can stop the wait timer and
          * send a notification of the new device. */
         device_stop_waiting_for_profiles(t->device);
@@ -321,6 +407,44 @@ void pa_bluetooth_transport_set_state(pa_bluetooth_transport *t, pa_bluetooth_tr
     }
 }
 
+pa_bluetooth_transport *pa_bluetooth_transport_get(pa_bluetooth_discovery *y, const char *path) {
+    pa_assert(path);
+    return pa_hashmap_get(y->transports, path);
+}
+
+pa_hashmap *pa_bluetooth_transport_get_all(pa_bluetooth_discovery *y) {
+    return y->transports;
+}
+
+static void pa_bluetooth_transport_remote_volume_changed(pa_bluetooth_transport *t, uint16_t volume) {
+    pa_bluetooth_hook_t hook;
+    bool is_source;
+
+    pa_assert(t);
+
+    is_source = pa_bluetooth_profile_is_a2dp_source(t->profile);
+
+    pa_log_debug("Reporting volume change %d/127 for %s",
+                 volume,
+                 is_source ? "source" : "sink");
+
+    if (is_source) {
+        if (t->rx_soft_volume)
+            t->rx_soft_volume = false;
+        t->rx_volume_gain = volume;
+        hook = PA_BLUETOOTH_HOOK_TRANSPORT_RX_VOLUME_GAIN_CHANGED;
+    } else if (pa_bluetooth_profile_is_a2dp_sink(t->profile)) {
+        if (t->tx_soft_volume)
+            t->tx_soft_volume = false;
+        t->tx_volume_gain = volume;
+        hook = PA_BLUETOOTH_HOOK_TRANSPORT_TX_VOLUME_GAIN_CHANGED;
+    } else {
+        pa_assert_not_reached();
+    }
+
+    pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, hook), t);
+}
+
 void pa_bluetooth_transport_put(pa_bluetooth_transport *t) {
     pa_assert(t);
 
@@ -329,20 +453,16 @@ void pa_bluetooth_transport_put(pa_bluetooth_transport *t) {
     pa_bluetooth_transport_set_state(t, PA_BLUETOOTH_TRANSPORT_STATE_IDLE);
 }
 
-void pa_bluetooth_transport_unlink(pa_bluetooth_transport *t) {
+void pa_bluetooth_transport_free(pa_bluetooth_transport *t) {
     pa_assert(t);
 
     pa_bluetooth_transport_set_state(t, PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED);
-    pa_hashmap_remove(t->device->discovery->transports, t->path);
-    t->device->transports[t->profile] = NULL;
-}
-
-void pa_bluetooth_transport_free(pa_bluetooth_transport *t) {
-    pa_assert(t);
 
     if (t->destroy)
         t->destroy(t);
-    pa_bluetooth_transport_unlink(t);
+
+    pa_hashmap_remove(t->device->discovery->transports, t->path);
+    t->device->transports[t->profile] = NULL;
 
     pa_xfree(t->owner);
     pa_xfree(t->path);
@@ -350,99 +470,304 @@ void pa_bluetooth_transport_free(pa_bluetooth_transport *t) {
     pa_xfree(t);
 }
 
-static int bluez5_transport_acquire_cb(pa_bluetooth_transport *t, bool optional, size_t *imtu, size_t *omtu) {
-    DBusMessage *m, *r;
+static void bluez5_transport_acquire_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
     DBusError err;
-    int ret;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+    pa_bluetooth_transport *t;
+    struct pending_transport_fd *pending_transport_fd;
+    char *path;
+    int fd;
     uint16_t i, o;
-    const char *method = optional ? "TryAcquire" : "Acquire";
 
-    pa_assert(t);
-    pa_assert(t->device);
-    pa_assert(t->device->discovery);
-
-    pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, BLUEZ_MEDIA_TRANSPORT_INTERFACE, method));
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(path = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
 
     dbus_error_init(&err);
 
-    r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(t->device->discovery->connection), m, -1, &err);
-    dbus_message_unref(m);
-    m = NULL;
-    if (!r) {
-        if (optional && pa_streq(err.name, "org.bluez.Error.NotAvailable"))
-            pa_log_info("Failed optional acquire of unavailable transport %s", t->path);
-        else
-            pa_log_error("Transport %s() failed for transport %s (%s)", method, t->path, err.message);
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_error("Transport Acquire() failed for transport %s (%s)", path, pa_dbus_get_error_message(r));
+        goto failed;
+    }
 
-        dbus_error_free(&err);
-        return -1;
+    if (!dbus_message_get_args(r, &err, DBUS_TYPE_UNIX_FD, &fd, DBUS_TYPE_UINT16, &i, DBUS_TYPE_UINT16, &o, DBUS_TYPE_INVALID)) {
+        pa_log_error("Failed to parse Acquire() reply: %s", err.message);
+        goto failed;
     }
 
-    if (!dbus_message_get_args(r, &err, DBUS_TYPE_UNIX_FD, &ret, DBUS_TYPE_UINT16, &i, DBUS_TYPE_UINT16, &o,
-                               DBUS_TYPE_INVALID)) {
-        pa_log_error("Failed to parse %s() reply: %s", method, err.message);
-        dbus_error_free(&err);
-        ret = -1;
-        goto finish;
+    pa_log_info("Transport %s acquired", path);
+    goto success;
+
+failed:
+    /* If transport state is not disconnected then switch it to disconnected state and
+     * then to idle state so sinks and sources are properly released and connection
+     * attempt is marked as failed, this also trigger profile change to off */
+    t = pa_bluetooth_transport_get(y, path);
+    if (t && t->state > PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED) {
+        pa_bluetooth_transport_set_state(t, PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED);
+        pa_bluetooth_transport_set_state(t, PA_BLUETOOTH_TRANSPORT_STATE_IDLE);
+    }
+
+    fd = -1;
+    i = 0;
+    o = 0;
+    /* fall through, we need to put failure into pending_transport_fds hashmap */
+
+success:
+    pending_transport_fd = pa_hashmap_get(y->pending_transport_fds, path);
+    if (!pending_transport_fd) {
+        pending_transport_fd = pa_xnew0(struct pending_transport_fd, 1);
+        pending_transport_fd->discovery = y;
+        pending_transport_fd->path = pa_xstrdup(path);
+        pa_hashmap_put(y->pending_transport_fds, pending_transport_fd->path, pending_transport_fd);
+    } else if (pending_transport_fd->fd != fd) {
+        pa_log_info("Closing staled pending fd %d for transport %s", pending_transport_fd->fd, path);
+        close(pending_transport_fd->fd);
+    }
+
+    pending_transport_fd->fd = fd;
+    pending_transport_fd->imtu = i;
+    pending_transport_fd->omtu = o;
+
+/* finish: */
+    dbus_error_free(&err);
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+
+    pa_xfree(path);
+}
+
+static void bluez5_transport_request_volume(pa_bluetooth_transport *t);
+
+static int bluez5_transport_acquire_cb(pa_bluetooth_transport *t, size_t *imtu, size_t *omtu) {
+    struct pending_transport_fd *pending_transport_fd;
+    DBusMessage *m;
+    int fd;
+
+    pa_assert(t);
+    pa_assert(t->device);
+    pa_assert(t->device->discovery);
+
+    pending_transport_fd = pa_hashmap_remove(t->device->discovery->pending_transport_fds, t->path);
+    if (!pending_transport_fd) {
+        pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, BLUEZ_MEDIA_TRANSPORT_INTERFACE, "Acquire"));
+        send_and_add_to_pending(t->device->discovery, m, bluez5_transport_acquire_reply, pa_xstrdup(t->path));
+        return -EAGAIN;
     }
 
+    fd = pending_transport_fd->fd;
+
     if (imtu)
-        *imtu = i;
+        *imtu = pending_transport_fd->imtu;
 
     if (omtu)
-        *omtu = o;
+        *omtu = pending_transport_fd->omtu;
 
-finish:
-    dbus_message_unref(r);
-    return ret;
+    bluez5_transport_request_volume(t);
+
+    pa_xfree(pending_transport_fd->path);
+    pa_xfree(pending_transport_fd);
+
+    return fd;
 }
 
 static void bluez5_transport_release_cb(pa_bluetooth_transport *t) {
-    DBusMessage *m, *r;
-    DBusError err;
+    DBusMessage *m;
 
     pa_assert(t);
     pa_assert(t->device);
     pa_assert(t->device->discovery);
 
-    dbus_error_init(&err);
-
     if (t->state <= PA_BLUETOOTH_TRANSPORT_STATE_IDLE) {
         pa_log_info("Transport %s auto-released by BlueZ or already released", t->path);
         return;
     }
 
     pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, BLUEZ_MEDIA_TRANSPORT_INTERFACE, "Release"));
-    r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(t->device->discovery->connection), m, -1, &err);
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(t->device->discovery->connection), m, NULL));
+    pa_log_info("Transport %s released", t->path);
+}
+
+static void bluez5_transport_release_staled_pending_fd(struct pending_transport_fd *pending_transport_fd) {
+    pa_bluetooth_transport *t;
+
+    pa_assert(pending_transport_fd);
+    pa_assert(pending_transport_fd->discovery);
+
+    pa_log_info("Releasing staled pending transport %s", pending_transport_fd->path);
+
+    t = pa_hashmap_get(pending_transport_fd->discovery->transports, pending_transport_fd->path);
+    if (t)
+        bluez5_transport_release_cb(t);
+
+    close(pending_transport_fd->fd);
+
+    pa_xfree(pending_transport_fd->path);
+    pa_xfree(pending_transport_fd);
+}
+
+static void bluez5_transport_set_volume(pa_bluetooth_transport *t, uint16_t gain) {
+    static const char *volume_str = "Volume";
+    static const char *mediatransport_str = BLUEZ_MEDIA_TRANSPORT_INTERFACE;
+    DBusMessage *m;
+    DBusMessageIter iter;
+
+    pa_assert(t);
+    pa_assert(t->device);
+    pa_assert(pa_bluetooth_profile_is_a2dp(t->profile));
+    pa_assert(t->device->discovery);
+
+    if (pa_bluetooth_profile_is_a2dp_source(t->profile) && t->rx_volume_gain == gain)
+        return;
+    else if (pa_bluetooth_profile_is_a2dp_sink(t->profile) && t->tx_volume_gain == gain)
+        return;
+
+    pa_log_debug("Sending A2DP volume %d/127 to peer", gain);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, t->path, DBUS_INTERFACE_PROPERTIES, "Set"));
+
+    dbus_message_iter_init_append(m, &iter);
+    pa_assert_se(dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &mediatransport_str));
+    pa_assert_se(dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &volume_str));
+    pa_dbus_append_basic_variant(&iter, DBUS_TYPE_UINT16, &gain);
+
+    /* Ignore replies, instead wait for the Volume property changed notification */
+    dbus_message_set_no_reply(m, true);
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(t->device->discovery->connection), m, NULL));
     dbus_message_unref(m);
-    m = NULL;
-    if (r) {
-        dbus_message_unref(r);
-        r = NULL;
+}
+
+static void bluez5_transport_set_sink_volume(pa_bluetooth_transport *t, uint16_t gain) {
+    pa_assert(t);
+
+    /* Currently we can set absolute volume for sink only in A2DP sink profile */
+    if (pa_bluetooth_profile_is_a2dp_sink(t->profile))
+        bluez5_transport_set_volume(t, gain);
+}
+
+static void bluez5_transport_set_source_volume(pa_bluetooth_transport *t, uint16_t gain) {
+    pa_assert(t);
+
+    /* Currently we can set absolute volume for source only in A2DP source profile */
+    if (pa_bluetooth_profile_is_a2dp_source(t->profile))
+        bluez5_transport_set_volume(t, gain);
+}
+
+static void request_volume_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    DBusMessageIter iter, variant;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+    pa_bluetooth_transport *t;
+    uint16_t gain;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(t = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_error(DBUS_INTERFACE_PROPERTIES ".Get %s Volume failed: %s: %s",
+                     dbus_message_get_path(p->message),
+                     dbus_message_get_error_name(r),
+                     pa_dbus_get_error_message(r));
+        goto finish;
     }
+    dbus_message_iter_init(r, &iter);
+    pa_assert(dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_VARIANT);
+    dbus_message_iter_recurse(&iter, &variant);
+    pa_assert(dbus_message_iter_get_arg_type(&variant) == DBUS_TYPE_UINT16);
+    dbus_message_iter_get_basic(&variant, &gain);
 
-    if (dbus_error_is_set(&err)) {
-        pa_log_error("Failed to release transport %s: %s", t->path, err.message);
-        dbus_error_free(&err);
-    } else
-        pa_log_info("Transport %s released", t->path);
+    if (gain > A2DP_MAX_GAIN)
+        gain = A2DP_MAX_GAIN;
+
+    pa_log_debug("Received A2DP Absolute Volume %d", gain);
+
+    pa_bluetooth_transport_remote_volume_changed(t, gain);
+
+finish:
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+}
+
+static void bluez5_transport_request_volume(pa_bluetooth_transport *t) {
+    static const char *volume_str = "Volume";
+    static const char *mediatransport_str = BLUEZ_MEDIA_TRANSPORT_INTERFACE;
+    DBusMessage *m;
+
+    pa_assert(t);
+    pa_assert(t->device);
+    pa_assert(t->device->discovery);
+
+    pa_assert(pa_bluetooth_profile_is_a2dp(t->profile));
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, t->path, DBUS_INTERFACE_PROPERTIES, "Get"));
+    pa_assert_se(dbus_message_append_args(m,
+        DBUS_TYPE_STRING, &mediatransport_str,
+        DBUS_TYPE_STRING, &volume_str,
+        DBUS_TYPE_INVALID));
+
+    send_and_add_to_pending(t->device->discovery, m, request_volume_reply, t);
 }
 
 bool pa_bluetooth_device_any_transport_connected(const pa_bluetooth_device *d) {
-    unsigned i;
+    unsigned i, bluetooth_profile_count;
 
     pa_assert(d);
 
     if (!d->valid)
         return false;
 
-    for (i = 0; i < PA_BLUETOOTH_PROFILE_COUNT; i++)
+    bluetooth_profile_count = pa_bluetooth_profile_count();
+    for (i = 0; i < bluetooth_profile_count; i++)
         if (d->transports[i] && d->transports[i]->state != PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED)
             return true;
 
     return false;
 }
 
+bool pa_bluetooth_device_a2dp_sink_transport_connected(const pa_bluetooth_device *d) {
+    unsigned i, bluetooth_profile_count;
+
+    pa_assert(d);
+
+    if (!d->valid)
+        return false;
+
+    bluetooth_profile_count = pa_bluetooth_profile_count();
+    for (i = 0; i < bluetooth_profile_count; i++)
+        if (pa_bluetooth_profile_is_a2dp_sink(i) && d->transports[i] && d->transports[i]->state != PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED)
+            return true;
+
+    return false;
+}
+
+bool pa_bluetooth_device_a2dp_source_transport_connected(const pa_bluetooth_device *d) {
+    unsigned i, bluetooth_profile_count;
+
+    pa_assert(d);
+
+    if (!d->valid)
+        return false;
+
+    bluetooth_profile_count = pa_bluetooth_profile_count();
+    for (i = 0; i < bluetooth_profile_count; i++)
+        if (pa_bluetooth_profile_is_a2dp_source(i) && d->transports[i] && d->transports[i]->state != PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED)
+            return true;
+
+    return false;
+}
+
 static int transport_state_from_string(const char* value, pa_bluetooth_transport_state_t *state) {
     pa_assert(value);
     pa_assert(state);
@@ -465,6 +790,8 @@ static void parse_transport_property(pa_bluetooth_transport *t, DBusMessageIter
     if (key == NULL)
         return;
 
+    pa_log_debug("Transport property %s changed", key);
+
     dbus_message_iter_recurse(i, &variant_i);
 
     switch (dbus_message_iter_get_arg_type(&variant_i)) {
@@ -487,6 +814,16 @@ static void parse_transport_property(pa_bluetooth_transport *t, DBusMessageIter
 
             break;
         }
+
+        case DBUS_TYPE_UINT16: {
+            uint16_t value;
+            dbus_message_iter_get_basic(&variant_i, &value);
+
+            if (pa_streq(key, "Volume"))
+                pa_bluetooth_transport_remote_volume_changed(t, value);
+
+            break;
+        }
     }
 
     return;
@@ -510,6 +847,42 @@ static int parse_transport_properties(pa_bluetooth_transport *t, DBusMessageIter
     return 0;
 }
 
+static unsigned pa_a2dp_codec_id_hash_func(const void *_p) {
+    unsigned hash;
+    const pa_a2dp_codec_id *p = _p;
+
+    hash = p->codec_id;
+    hash = 31 * hash + ((p->vendor_id >>  0) & 0xFF);
+    hash = 31 * hash + ((p->vendor_id >>  8) & 0xFF);
+    hash = 31 * hash + ((p->vendor_id >> 16) & 0xFF);
+    hash = 31 * hash + ((p->vendor_id >> 24) & 0xFF);
+    hash = 31 * hash + ((p->vendor_codec_id >> 0) & 0xFF);
+    hash = 31 * hash + ((p->vendor_codec_id >> 8) & 0xFF);
+    return hash;
+}
+
+static int pa_a2dp_codec_id_compare_func(const void *_a, const void *_b) {
+    const pa_a2dp_codec_id *a = _a;
+    const pa_a2dp_codec_id *b = _b;
+
+    if (a->codec_id < b->codec_id)
+        return -1;
+    if (a->codec_id > b->codec_id)
+        return 1;
+
+    if (a->vendor_id < b->vendor_id)
+        return -1;
+    if (a->vendor_id > b->vendor_id)
+        return 1;
+
+    if (a->vendor_codec_id < b->vendor_codec_id)
+        return -1;
+    if (a->vendor_codec_id > b->vendor_codec_id)
+        return 1;
+
+    return 0;
+}
+
 static pa_bluetooth_device* device_create(pa_bluetooth_discovery *y, const char *path) {
     pa_bluetooth_device *d;
 
@@ -520,6 +893,9 @@ static pa_bluetooth_device* device_create(pa_bluetooth_discovery *y, const char
     d->discovery = y;
     d->path = pa_xstrdup(path);
     d->uuids = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL, pa_xfree);
+    d->a2dp_sink_endpoints = pa_hashmap_new_full(pa_a2dp_codec_id_hash_func, pa_a2dp_codec_id_compare_func, pa_xfree, (pa_free_cb_t)pa_hashmap_free);
+    d->a2dp_source_endpoints = pa_hashmap_new_full(pa_a2dp_codec_id_hash_func, pa_a2dp_codec_id_compare_func, pa_xfree, (pa_free_cb_t)pa_hashmap_free);
+    d->transports = pa_xnew0(pa_bluetooth_transport *, pa_bluetooth_profile_count());
 
     pa_hashmap_put(y->devices, d->path, d);
 
@@ -555,8 +931,25 @@ pa_bluetooth_device* pa_bluetooth_discovery_get_device_by_address(pa_bluetooth_d
     return NULL;
 }
 
+static void remote_endpoint_remove(pa_bluetooth_discovery *y, const char *path) {
+    pa_bluetooth_device *device;
+    pa_hashmap *endpoints;
+    void *devices_state;
+    void *state;
+
+    PA_HASHMAP_FOREACH(device, y->devices, devices_state) {
+        PA_HASHMAP_FOREACH(endpoints, device->a2dp_sink_endpoints, state)
+            pa_hashmap_remove_and_free(endpoints, path);
+
+        PA_HASHMAP_FOREACH(endpoints, device->a2dp_source_endpoints, state)
+            pa_hashmap_remove_and_free(endpoints, path);
+    }
+
+    pa_log_debug("Remote endpoint %s was removed", path);
+}
+
 static void device_free(pa_bluetooth_device *d) {
-    unsigned i;
+    unsigned i, bluetooth_profile_count;
 
     pa_assert(d);
 
@@ -564,7 +957,8 @@ static void device_free(pa_bluetooth_device *d) {
 
     pa_hook_fire(&d->discovery->hooks[PA_BLUETOOTH_HOOK_DEVICE_UNLINK], d);
 
-    for (i = 0; i < PA_BLUETOOTH_PROFILE_COUNT; i++) {
+    bluetooth_profile_count = pa_bluetooth_profile_count();
+    for (i = 0; i < bluetooth_profile_count; i++) {
         pa_bluetooth_transport *t;
 
         if (!(t = d->transports[i]))
@@ -573,9 +967,11 @@ static void device_free(pa_bluetooth_device *d) {
         pa_bluetooth_transport_free(t);
     }
 
-    if (d->uuids)
-        pa_hashmap_free(d->uuids);
+    pa_hashmap_free(d->uuids);
+    pa_hashmap_free(d->a2dp_sink_endpoints);
+    pa_hashmap_free(d->a2dp_source_endpoints);
 
+    pa_xfree(d->transports);
     pa_xfree(d->path);
     pa_xfree(d->alias);
     pa_xfree(d->address);
@@ -814,6 +1210,149 @@ static void parse_device_properties(pa_bluetooth_device *d, DBusMessageIter *i)
     }
 }
 
+static void parse_remote_endpoint_properties(pa_bluetooth_discovery *y, const char *endpoint, DBusMessageIter *i) {
+    DBusMessageIter element_i;
+    pa_bluetooth_device *device;
+    pa_hashmap *codec_endpoints;
+    pa_hashmap *endpoints;
+    pa_a2dp_codec_id *a2dp_codec_id;
+    struct a2dp_codec_capabilities *a2dp_codec_capabilities;
+    const char *uuid = NULL;
+    const char *device_path = NULL;
+    uint8_t codec_id = 0;
+    bool have_codec_id = false;
+    const uint8_t *capabilities = NULL;
+    int capabilities_size = 0;
+
+    pa_log_debug("Parsing remote endpoint %s", endpoint);
+
+    dbus_message_iter_recurse(i, &element_i);
+
+    while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
+        DBusMessageIter dict_i, variant_i;
+        const char *key;
+
+        dbus_message_iter_recurse(&element_i, &dict_i);
+
+        key = check_variant_property(&dict_i);
+        if (key == NULL) {
+            pa_log_error("Received invalid property for remote endpoint %s", endpoint);
+            return;
+        }
+
+        dbus_message_iter_recurse(&dict_i, &variant_i);
+
+        if (pa_streq(key, "UUID")) {
+            if (dbus_message_iter_get_arg_type(&variant_i) != DBUS_TYPE_STRING) {
+                pa_log_warn("Remote endpoint %s property 'UUID' is not string, ignoring", endpoint);
+                return;
+            }
+
+            dbus_message_iter_get_basic(&variant_i, &uuid);
+        } else if (pa_streq(key, "Codec")) {
+            if (dbus_message_iter_get_arg_type(&variant_i) != DBUS_TYPE_BYTE) {
+                pa_log_warn("Remote endpoint %s property 'Codec' is not byte, ignoring", endpoint);
+                return;
+            }
+
+            dbus_message_iter_get_basic(&variant_i, &codec_id);
+            have_codec_id = true;
+        } else if (pa_streq(key, "Capabilities")) {
+            DBusMessageIter array;
+
+            if (dbus_message_iter_get_arg_type(&variant_i) != DBUS_TYPE_ARRAY) {
+                pa_log_warn("Remote endpoint %s property 'Capabilities' is not array, ignoring", endpoint);
+                return;
+            }
+
+            dbus_message_iter_recurse(&variant_i, &array);
+            if (dbus_message_iter_get_arg_type(&array) != DBUS_TYPE_BYTE) {
+                pa_log_warn("Remote endpoint %s property 'Capabilities' is not array of bytes, ignoring", endpoint);
+                return;
+            }
+
+            dbus_message_iter_get_fixed_array(&array, &capabilities, &capabilities_size);
+        } else if (pa_streq(key, "Device")) {
+            if (dbus_message_iter_get_arg_type(&variant_i) != DBUS_TYPE_OBJECT_PATH) {
+                pa_log_warn("Remote endpoint %s property 'Device' is not path, ignoring", endpoint);
+                return;
+            }
+
+            dbus_message_iter_get_basic(&variant_i, &device_path);
+        }
+
+        dbus_message_iter_next(&element_i);
+    }
+
+    if (!uuid) {
+        pa_log_warn("Remote endpoint %s does not have property 'UUID', ignoring", endpoint);
+        return;
+    }
+
+    if (!have_codec_id) {
+        pa_log_warn("Remote endpoint %s does not have property 'Codec', ignoring", endpoint);
+        return;
+    }
+
+    if (!capabilities || !capabilities_size) {
+        pa_log_warn("Remote endpoint %s does not have property 'Capabilities', ignoring", endpoint);
+        return;
+    }
+
+    if (!device_path) {
+        pa_log_warn("Remote endpoint %s does not have property 'Device', ignoring", endpoint);
+        return;
+    }
+
+    device = pa_hashmap_get(y->devices, device_path);
+    if (!device) {
+        pa_log_warn("Device for remote endpoint %s was not found", endpoint);
+        return;
+    }
+
+    if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK)) {
+        codec_endpoints = device->a2dp_sink_endpoints;
+    } else if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE)) {
+        codec_endpoints = device->a2dp_source_endpoints;
+    } else {
+        pa_log_warn("Remote endpoint %s does not have valid property 'UUID', ignoring", endpoint);
+        return;
+    }
+
+    if (capabilities_size < 0 || capabilities_size > MAX_A2DP_CAPS_SIZE) {
+        pa_log_warn("Remote endpoint %s does not have valid property 'Capabilities', ignoring", endpoint);
+        return;
+    }
+
+    a2dp_codec_id = pa_xmalloc0(sizeof(*a2dp_codec_id));
+    a2dp_codec_id->codec_id = codec_id;
+    if (codec_id == A2DP_CODEC_VENDOR) {
+        if ((size_t)capabilities_size < sizeof(a2dp_vendor_codec_t)) {
+            pa_log_warn("Remote endpoint %s does not have valid property 'Capabilities', ignoring", endpoint);
+            return;
+        }
+        a2dp_codec_id->vendor_id = A2DP_GET_VENDOR_ID(*(a2dp_vendor_codec_t *)capabilities);
+        a2dp_codec_id->vendor_codec_id = A2DP_GET_CODEC_ID(*(a2dp_vendor_codec_t *)capabilities);
+    } else {
+        a2dp_codec_id->vendor_id = 0;
+        a2dp_codec_id->vendor_codec_id = 0;
+    }
+
+    a2dp_codec_capabilities = pa_xmalloc0(sizeof(*a2dp_codec_capabilities) + capabilities_size);
+    a2dp_codec_capabilities->size = capabilities_size;
+    memcpy(a2dp_codec_capabilities->buffer, capabilities, capabilities_size);
+
+    endpoints = pa_hashmap_get(codec_endpoints, a2dp_codec_id);
+    if (!endpoints) {
+        endpoints = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, pa_xfree, pa_xfree);
+        pa_hashmap_put(codec_endpoints, a2dp_codec_id, endpoints);
+    }
+
+    if (pa_hashmap_remove_and_free(endpoints, endpoint) >= 0)
+        pa_log_debug("Replacing existing remote endpoint %s", endpoint);
+    pa_hashmap_put(endpoints, pa_xstrdup(endpoint), a2dp_codec_capabilities);
+}
+
 static void parse_adapter_properties(pa_bluetooth_adapter *a, DBusMessageIter *i, bool is_property_change) {
     DBusMessageIter element_i;
 
@@ -857,7 +1396,7 @@ static void parse_adapter_properties(pa_bluetooth_adapter *a, DBusMessageIter *i
     }
 }
 
-static void register_endpoint_reply(DBusPendingCall *pending, void *userdata) {
+static void register_legacy_sbc_endpoint_reply(DBusPendingCall *pending, void *userdata) {
     DBusMessage *r;
     pa_dbus_pending *p;
     pa_bluetooth_discovery *y;
@@ -870,7 +1409,7 @@ static void register_endpoint_reply(DBusPendingCall *pending, void *userdata) {
     pa_assert_se(r = dbus_pending_call_steal_reply(pending));
 
     if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_SUPPORTED)) {
-        pa_log_info("Couldn't register endpoint %s because it is disabled in BlueZ", endpoint);
+        pa_log_info("Couldn't register legacy sbc endpoint %s because it is disabled in BlueZ", endpoint);
         goto finish;
     }
 
@@ -886,35 +1425,111 @@ finish:
     PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
     pa_dbus_pending_free(p);
 
-    pa_xfree(endpoint);
+    pa_xfree(endpoint);
+}
+
+static void register_legacy_sbc_endpoint(pa_bluetooth_discovery *y, const char *path, bool is_sink) {
+    DBusMessage *m;
+    DBusMessageIter i, d;
+    const pa_a2dp_codec *a2dp_codec_sbc;
+    const char *endpoint;
+    const char *uuid;
+    uint8_t codec_id;
+    uint8_t capabilities_size;
+    uint8_t capabilities[MAX_A2DP_CAPS_SIZE];
+
+    pa_assert_se(a2dp_codec_sbc = pa_bluetooth_get_a2dp_codec("sbc"));
+    uuid = is_sink ? PA_BLUETOOTH_UUID_A2DP_SINK : PA_BLUETOOTH_UUID_A2DP_SOURCE;
+    endpoint = is_sink ? A2DP_SINK_ENDPOINT "/sbc" : A2DP_SOURCE_ENDPOINT "/sbc";
+
+    pa_log_debug("Registering legacy sbc endpoint %s on adapter %s", endpoint, path);
+
+    codec_id = a2dp_codec_sbc->id.codec_id;
+    capabilities_size = a2dp_codec_sbc->fill_capabilities(capabilities);
+    pa_assert(capabilities_size != 0);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, path, BLUEZ_MEDIA_INTERFACE, "RegisterEndpoint"));
+
+    dbus_message_iter_init_append(m, &i);
+    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &endpoint));
+    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
+                                         DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
+    pa_dbus_append_basic_variant_dict_entry(&d, "UUID", DBUS_TYPE_STRING, &uuid);
+    pa_dbus_append_basic_variant_dict_entry(&d, "Codec", DBUS_TYPE_BYTE, &codec_id);
+    pa_dbus_append_basic_array_variant_dict_entry(&d, "Capabilities", DBUS_TYPE_BYTE, &capabilities, capabilities_size);
+
+    dbus_message_iter_close_container(&i, &d);
+
+    send_and_add_to_pending(y, m, register_legacy_sbc_endpoint_reply, pa_xstrdup(endpoint));
+}
+
+static void register_application_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_adapter *a;
+    pa_bluetooth_discovery *y;
+    char *path;
+    bool fallback = true;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(path = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_SUPPORTED)) {
+        pa_log_info("Couldn't register media application for adapter %s because it is disabled in BlueZ", path);
+        goto finish;
+    }
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_warn(BLUEZ_MEDIA_INTERFACE ".RegisterApplication() failed: %s: %s", dbus_message_get_error_name(r),
+                     pa_dbus_get_error_message(r));
+        pa_log_warn("Couldn't register media application for adapter %s because of probably old BlueZ version which does not support additional A2DP codecs", path);
+        goto finish;
+    }
+
+    a = pa_hashmap_get(y->adapters, path);
+    if (!a) {
+        pa_log_error("Couldn't register media application for adapter %s because it does not exist anymore", path);
+        goto finish;
+    }
+
+    fallback = false;
+    a->media_application_registered = true;
+    pa_log_debug("Media application for adapter %s was successfully registered", path);
+
+finish:
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+
+    if (fallback) {
+        /* If bluez does not support RegisterApplication, fallback to old legacy API with just one SBC codec */
+        register_legacy_sbc_endpoint(y, path, true);
+        register_legacy_sbc_endpoint(y, path, false);
+        pa_log_warn("Only SBC codec is available for A2DP profiles");
+    }
+
+    pa_xfree(path);
 }
 
-static void register_endpoint(pa_bluetooth_discovery *y, const pa_a2dp_codec *a2dp_codec, const char *path, const char *endpoint, const char *uuid) {
+static void register_application(pa_bluetooth_adapter *a) {
     DBusMessage *m;
     DBusMessageIter i, d;
-    uint8_t capabilities[MAX_A2DP_CAPS_SIZE];
-    size_t capabilities_size;
-    uint8_t codec_id;
-
-    pa_log_debug("Registering %s on adapter %s", endpoint, path);
+    const char *object_manager_path = A2DP_OBJECT_MANAGER_PATH;
 
-    codec_id = a2dp_codec->id.codec_id;
-    capabilities_size = a2dp_codec->fill_capabilities(capabilities);
-    pa_assert(capabilities_size != 0);
+    pa_log_debug("Registering media application for adapter %s", a->path);
 
-    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, path, BLUEZ_MEDIA_INTERFACE, "RegisterEndpoint"));
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, a->path, BLUEZ_MEDIA_INTERFACE, "RegisterApplication"));
 
     dbus_message_iter_init_append(m, &i);
-    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &endpoint));
-    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
-                                         DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
-    pa_dbus_append_basic_variant_dict_entry(&d, "UUID", DBUS_TYPE_STRING, &uuid);
-    pa_dbus_append_basic_variant_dict_entry(&d, "Codec", DBUS_TYPE_BYTE, &codec_id);
-    pa_dbus_append_basic_array_variant_dict_entry(&d, "Capabilities", DBUS_TYPE_BYTE, &capabilities, capabilities_size);
-
+    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &object_manager_path));
+    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
     dbus_message_iter_close_container(&i, &d);
 
-    send_and_add_to_pending(y, m, register_endpoint_reply, pa_xstrdup(endpoint));
+    send_and_add_to_pending(a->discovery, m, register_application_reply, pa_xstrdup(a->path));
 }
 
 static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessageIter *dict_i) {
@@ -1560,7 +1560,6 @@
 
         if (pa_streq(interface, BLUEZ_ADAPTER_INTERFACE)) {
             pa_bluetooth_adapter *a;
-            unsigned a2dp_codec_i;
 
             if ((a = pa_hashmap_get(y->adapters, path))) {
                 pa_log_error("Found duplicated D-Bus path for adapter %s", path);
@@ -1575,20 +1574,7 @@
             if (!a->valid)
                 return;
 
-            /* Order is important. bluez prefers endpoints registered earlier.
-             * And codec with higher number has higher priority. So iterate in reverse order. */
-            for (a2dp_codec_i = pa_bluetooth_a2dp_codec_count(); a2dp_codec_i > 0; a2dp_codec_i--) {
-                const pa_a2dp_codec *a2dp_codec = pa_bluetooth_a2dp_codec_iter(a2dp_codec_i-1);
-                char *endpoint;
-
-                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, a2dp_codec->name);
-                register_endpoint(y, a2dp_codec, path, endpoint, PA_BLUETOOTH_UUID_A2DP_SINK);
-                pa_xfree(endpoint);
-
-                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, a2dp_codec->name);
-                register_endpoint(y, a2dp_codec, path, endpoint, PA_BLUETOOTH_UUID_A2DP_SOURCE);
-                pa_xfree(endpoint);
-            }
+            register_application(a);
 
         } else if (pa_streq(interface, BLUEZ_DEVICE_INTERFACE)) { 
 
@@ -983,7 +1591,9 @@ static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessa
 
             parse_device_properties(d, &iface_i);
 
-        } else
+        } else if (pa_streq(interface, BLUEZ_MEDIA_ENDPOINT_INTERFACE))
+            parse_remote_endpoint_properties(y, path, &iface_i);
+        else
             pa_log_debug("Unknown interface %s found, skipping", interface);
 
         dbus_message_iter_next(&element_i);
@@ -1007,34 +1617,6 @@ static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessa
     return;
 }
 
-void pa_bluetooth_discovery_set_ofono_running(pa_bluetooth_discovery *y, bool is_running) {
-    pa_assert(y);
-
-    pa_log_debug("oFono is running: %s", pa_yes_no(is_running));
-    if (y->headset_backend != HEADSET_BACKEND_AUTO)
-        return;
-
-    /* If ofono starts running, all devices that might be connected to the HS role
-     * need to be disconnected, so that the devices can be handled by ofono */
-    if (is_running) {
-        void *state;
-        pa_bluetooth_device *d;
-
-        PA_HASHMAP_FOREACH(d, y->devices, state) {
-            if (device_supports_profile(d, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)) {
-                DBusMessage *m;
-
-                pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, d->path, "org.bluez.Device1", "Disconnect"));
-                dbus_message_set_no_reply(m, true);
-                pa_assert_se(dbus_connection_send(pa_dbus_connection_get(y->connection), m, NULL));
-                dbus_message_unref(m);
-            }
-        }
-    }
-
-    pa_bluetooth_native_backend_enable_hs_role(y->native_backend, !is_running);
-}
-
 static void get_managed_objects_reply(DBusPendingCall *pending, void *userdata) {
     pa_dbus_pending *p;
     pa_bluetooth_discovery *y;
@@ -1073,10 +1655,8 @@ static void get_managed_objects_reply(DBusPendingCall *pending, void *userdata)
 
     y->objects_listed = true;
 
-    if (!y->native_backend && y->headset_backend != HEADSET_BACKEND_OFONO)
-        y->native_backend = pa_bluetooth_native_backend_new(y->core, y, (y->headset_backend == HEADSET_BACKEND_NATIVE));
-    if (!y->ofono_backend && y->headset_backend != HEADSET_BACKEND_NATIVE)
-        y->ofono_backend = pa_bluetooth_ofono_backend_new(y->core, y);
+    if (!y->hsphfpd)
+        y->hsphfpd = pa_bluetooth_hsphfpd_new(y->core, y);
 
 finish:
     dbus_message_unref(r);
@@ -1130,13 +1710,9 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
                 pa_hashmap_remove_all(y->devices);
                 pa_hashmap_remove_all(y->adapters);
                 y->objects_listed = false;
-                if (y->ofono_backend) {
-                    pa_bluetooth_ofono_backend_free(y->ofono_backend);
-                    y->ofono_backend = NULL;
-                }
-                if (y->native_backend) {
-                    pa_bluetooth_native_backend_free(y->native_backend);
-                    y->native_backend = NULL;
+                if (y->hsphfpd) {
+                    pa_bluetooth_hsphfpd_free(y->hsphfpd);
+                    y->hsphfpd = NULL;
                 }
             }
 
@@ -1188,6 +1764,8 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
 
             if (pa_streq(iface, BLUEZ_DEVICE_INTERFACE))
                 device_remove(y, p);
+            else if (pa_streq(iface, BLUEZ_MEDIA_ENDPOINT_INTERFACE))
+                remote_endpoint_remove(y, p);
             else if (pa_streq(iface, BLUEZ_ADAPTER_INTERFACE))
                 adapter_remove(y, p);
 
@@ -1239,6 +1817,10 @@ static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *us
                 return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
             parse_device_properties(d, &arg_i);
+        } else if (pa_streq(iface, BLUEZ_MEDIA_ENDPOINT_INTERFACE)) {
+            pa_log_info("Properties changed in remote endpoint %s", dbus_message_get_path(m));
+
+            parse_remote_endpoint_properties(y, dbus_message_get_path(m), &arg_i);
         } else if (pa_streq(iface, BLUEZ_MEDIA_TRANSPORT_INTERFACE)) {
             pa_bluetooth_transport *t;
 
@@ -1259,21 +1841,450 @@ fail:
     return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
+/* A2DP bluez endpoint name ends with /sep<num_id> string */
+static int a2dp_endpoint_to_id(const char *endpoint) {
+    int end = strlen(endpoint)-1;
+    int pos = end;
+
+    while (pos >= 0 && endpoint[pos] >= '0' && endpoint[pos] <= '9')
+        pos--;
+
+    if (pos == end)
+        return -1;
+
+    if (pos < 3 || memcmp(endpoint+pos-3, "/sep", 4) != 0)
+        return -1;
+
+    return atoi(endpoint+pos+1);
+}
+
+struct cmp_arg {
+    const pa_a2dp_codec *a2dp_codec;
+    const pa_hashmap *capabilities_hashmap;
+    const pa_sample_spec *default_sample_spec;
+    bool for_encoding;
+};
+
+static int cmp_endpoints(const void *p1, const void *p2, void *arg) {
+    const char *endpoint1 = *(const char * const *)p1;
+    const char *endpoint2 = *(const char * const *)p2;
+    const struct cmp_arg *cmp_arg = (struct cmp_arg *)arg;
+    const struct a2dp_codec_capabilities *capabilities1;
+    const struct a2dp_codec_capabilities *capabilities2;
+    int cmp, id1, id2;
+
+    pa_assert_se(capabilities1 = pa_hashmap_get(cmp_arg->capabilities_hashmap, endpoint1));
+    pa_assert_se(capabilities2 = pa_hashmap_get(cmp_arg->capabilities_hashmap, endpoint2));
+
+    cmp = cmp_arg->a2dp_codec->cmp_endpoints(capabilities1->buffer, capabilities1->size, capabilities2->buffer, capabilities2->size, cmp_arg->default_sample_spec, cmp_arg->for_encoding);
+    if (cmp != 0)
+        return cmp;
+
+    /* Prefer endpoint with smaller SEP id (endpoint which should be tried first) */
+    id1 = a2dp_endpoint_to_id(endpoint1);
+    id2 = a2dp_endpoint_to_id(endpoint2);
+    if (id1 < id2)
+        return -1;
+    if (id1 > id2)
+        return 1;
+
+    return 0;
+}
+
+size_t pa_bluetooth_device_find_a2dp_endpoints_for_codec(const pa_bluetooth_device *device, const pa_a2dp_codec *a2dp_codec, bool is_a2dp_sink, const char **endpoints, size_t endpoints_max_count) {
+    pa_hashmap *capabilities_hashmap;
+    const struct a2dp_codec_capabilities *a2dp_capabilities;
+    const char *key;
+    void *state;
+    size_t count;
+
+    capabilities_hashmap = pa_hashmap_get(is_a2dp_sink ? device->a2dp_sink_endpoints : device->a2dp_source_endpoints, &a2dp_codec->id);
+    if (!capabilities_hashmap)
+        return 0;
+
+    count = 0;
+    /* Filter endpoints which are not compatible */
+    PA_HASHMAP_FOREACH_KV(key, a2dp_capabilities, capabilities_hashmap, state) {
+        if (!a2dp_codec->can_accept_capabilities(a2dp_capabilities->buffer, a2dp_capabilities->size, is_a2dp_sink))
+            continue;
+        if (count < endpoints_max_count)
+            endpoints[count] = key;
+        count++;
+    }
+
+    /* Change order of capabilities according to preference */
+    qsort_r(endpoints, (count <= endpoints_max_count) ? count : endpoints_max_count, sizeof(endpoints[0]), cmp_endpoints, &(struct cmp_arg){ a2dp_codec, capabilities_hashmap, &device->discovery->core->default_sample_spec, is_a2dp_sink });
+
+    return count;
+}
+
+struct change_a2dp_profile_data {
+    char *pa_endpoint;
+    char *device_path;
+    pa_bluetooth_profile_t profile;
+    const char **codec_endpoints;
+    size_t codec_endpoints_i;
+    size_t codec_endpoints_count;
+};
+
+static bool change_a2dp_profile_next(pa_bluetooth_device *device, pa_bluetooth_profile_t profile, const char **codec_endpoints, size_t codec_endpoints_i, size_t codec_endpoints_count);
+
+static void change_a2dp_profile_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+    pa_bluetooth_device *device;
+    struct change_a2dp_profile_data *data;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(data = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+
+    device = pa_hashmap_get(y->devices, data->device_path);
+
+    if (!device) {
+        pa_log_error("Changing a2dp profile for %s to %s failed: Device is not connected anymore", data->device_path, pa_bluetooth_profile_to_string(data->profile));
+        pa_xfree(data->codec_endpoints);
+    } else if (dbus_message_get_type(r) != DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_info("Changing a2dp profile for %s to %s via endpoint %s succeeded", data->device_path, pa_bluetooth_profile_to_string(data->profile), data->codec_endpoints[data->codec_endpoints_i-1]);
+        pa_hook_fire(&y->hooks[PA_BLUETOOTH_HOOK_PROFILE_CONNECTION_CHANGED], &(struct pa_bluetooth_device_and_profile){ device, data->profile, PA_BLUETOOTH_STATUS_SUCCESS });
+        pa_xfree(data->codec_endpoints);
+    } else {
+        pa_log_warn("Changing a2dp profile for %s to %s via endpoint %s failed: %s: %s", data->device_path, pa_bluetooth_profile_to_string(data->profile), data->codec_endpoints[data->codec_endpoints_i-1], dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
+        change_a2dp_profile_next(device, data->profile, data->codec_endpoints, data->codec_endpoints_i, data->codec_endpoints_count);
+    }
+
+    dbus_message_unref(r);
+
+    pa_xfree(data->pa_endpoint);
+    pa_xfree(data->device_path);
+    pa_xfree(data);
+}
+
+static bool change_a2dp_profile_next(pa_bluetooth_device *device, pa_bluetooth_profile_t profile, const char **codec_endpoints, size_t codec_endpoints_i, size_t codec_endpoints_count) {
+    const pa_a2dp_codec *a2dp_codec;
+    bool is_a2dp_sink;
+    const char *endpoint;
+    char *pa_endpoint;
+    struct change_a2dp_profile_data *data;
+    uint8_t config[MAX_A2DP_CAPS_SIZE];
+    uint8_t config_size;
+    pa_hashmap *all_endpoints;
+    struct a2dp_codec_capabilities *capabilities;
+    DBusMessage *m;
+    DBusMessageIter iter, dict;
+
+    a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(profile);
+    is_a2dp_sink = pa_bluetooth_profile_is_a2dp_sink(profile);
+
+    pa_assert_se(all_endpoints = pa_hashmap_get(is_a2dp_sink ? device->a2dp_sink_endpoints : device->a2dp_source_endpoints, &a2dp_codec->id));
+
+next:
+    if (codec_endpoints_i >= codec_endpoints_count) {
+        pa_log_error("Changing a2dp profile for %s to %s failed: No endpoint accepted connection", device->path, pa_bluetooth_profile_to_string(profile));
+        pa_hook_fire(&device->discovery->hooks[PA_BLUETOOTH_HOOK_PROFILE_CONNECTION_CHANGED], &(struct pa_bluetooth_device_and_profile){ device, profile, PA_BLUETOOTH_STATUS_NOTAVAILABLE });
+        pa_xfree(codec_endpoints);
+        return false;
+    }
+
+    pa_assert_se(endpoint = codec_endpoints[codec_endpoints_i++]);
+    pa_assert_se(capabilities = pa_hashmap_get(all_endpoints, endpoint));
+
+    config_size = a2dp_codec->fill_preferred_configuration(&device->discovery->core->default_sample_spec, capabilities->buffer, capabilities->size, config);
+    if (config_size == 0)
+        goto next;
+
+    pa_endpoint = pa_sprintf_malloc("%s/%s", is_a2dp_sink ? A2DP_SOURCE_ENDPOINT : A2DP_SINK_ENDPOINT, a2dp_codec->name);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, endpoint, BLUEZ_MEDIA_ENDPOINT_INTERFACE, "SetConfiguration"));
+
+    dbus_message_iter_init_append(m, &iter);
+    pa_assert_se(dbus_message_iter_append_basic(&iter, DBUS_TYPE_OBJECT_PATH, &pa_endpoint));
+    dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
+                                         DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &dict);
+    pa_dbus_append_basic_array_variant_dict_entry(&dict, "Capabilities", DBUS_TYPE_BYTE, &config, config_size);
+    dbus_message_iter_close_container(&iter, &dict);
+
+    pa_log_debug("Changing a2dp profile for %s to %s via endpoint %s with codec %s using local endpoint %s", device->path, pa_bluetooth_profile_to_string(profile), endpoint, a2dp_codec->name, pa_endpoint);
+
+    data = pa_xnew0(struct change_a2dp_profile_data, 1);
+    data->pa_endpoint = pa_endpoint;
+    data->device_path = pa_xstrdup(device->path);
+    data->profile = profile;
+    data->codec_endpoints = codec_endpoints;
+    data->codec_endpoints_i = codec_endpoints_i;
+    data->codec_endpoints_count = codec_endpoints_count;
+    send_and_add_to_pending(device->discovery, m, change_a2dp_profile_reply, data);
+    return true;
+}
+
+bool pa_bluetooth_device_change_a2dp_profile(pa_bluetooth_device *device, pa_bluetooth_profile_t profile) {
+    const pa_a2dp_codec *a2dp_codec;
+    bool is_a2dp_sink;
+    size_t codec_endpoints_count;
+    const char **codec_endpoints;
+
+    a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(profile);
+    is_a2dp_sink = pa_bluetooth_profile_is_a2dp_sink(profile);
+
+    codec_endpoints_count = pa_bluetooth_device_find_a2dp_endpoints_for_codec(device, a2dp_codec, is_a2dp_sink, NULL, 0);
+    if (!codec_endpoints_count) {
+        pa_log_error("Changing a2dp profile for %s to %s failed: No endpoint for codec %s", device->path, pa_bluetooth_profile_to_string(profile), a2dp_codec->name);
+        return false;
+    }
+
+    codec_endpoints = pa_xnew0(const char *, codec_endpoints_count);
+    pa_assert_se(pa_bluetooth_device_find_a2dp_endpoints_for_codec(device, a2dp_codec, is_a2dp_sink, codec_endpoints, codec_endpoints_count) == codec_endpoints_count);
+    return change_a2dp_profile_next(device, profile, codec_endpoints, 0, codec_endpoints_count);
+}
+
+static const char *pa_bluetooth_profile_to_uuid(pa_bluetooth_device *device, pa_bluetooth_profile_t profile) {
+    if (profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY)
+        return PA_BLUETOOTH_UUID_HSP_AG;
+    else if (profile == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY)
+        return PA_BLUETOOTH_UUID_HFP_AG;
+    else if (profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT)
+        return pa_hashmap_get(device->uuids, PA_BLUETOOTH_UUID_HSP_HS_ALT) ? PA_BLUETOOTH_UUID_HSP_HS_ALT : PA_BLUETOOTH_UUID_HSP_HS;
+    else if (profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT)
+        return PA_BLUETOOTH_UUID_HFP_HF;
+    else if (pa_bluetooth_profile_is_a2dp_sink(profile))
+        return PA_BLUETOOTH_UUID_A2DP_SINK;
+    else if (pa_bluetooth_profile_is_a2dp_source(profile))
+        return PA_BLUETOOTH_UUID_A2DP_SOURCE;
+    else
+        pa_assert_not_reached();
+}
+
+struct connect_profile_data {
+    char *device_path;
+    const char *profile_uuid;
+    pa_bluetooth_profile_t profile;
+};
+
+static void pa_bluetooth_device_connect_profile_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+    pa_bluetooth_device *device;
+    pa_bluetooth_status status;
+    struct connect_profile_data *data;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(data = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    device = pa_hashmap_get(y->devices, data->device_path);
+    if (!device)
+        pa_log_warn("Connecting device %s to profile %s (%s) failed: Device is not connected anymore", data->device_path, pa_bluetooth_profile_to_string(data->profile), data->profile_uuid);
+    else if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR)
+        pa_log_warn("Connecting device %s to profile %s (%s) failed: %s: %s", data->device_path, pa_bluetooth_profile_to_string(data->profile), data->profile_uuid, dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
+    else
+        pa_log_info("Connecting device %s to profile %s (%s) succeeded", data->device_path, pa_bluetooth_profile_to_string(data->profile), data->profile_uuid);
+
+    if (device) {
+        if (dbus_message_get_type(r) != DBUS_MESSAGE_TYPE_ERROR)
+            status = PA_BLUETOOTH_STATUS_SUCCESS;
+        else if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_AVAILABLE))
+            status = PA_BLUETOOTH_STATUS_NOTAVAILABLE;
+        else
+            status = PA_BLUETOOTH_STATUS_FAILED;
+        pa_hook_fire(&y->hooks[PA_BLUETOOTH_HOOK_PROFILE_CONNECTION_CHANGED], &(struct pa_bluetooth_device_and_profile){ device, data->profile, status });
+    }
+
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+
+    pa_xfree(data->device_path);
+    pa_xfree(data);
+}
+
+void pa_bluetooth_device_connect_profile(pa_bluetooth_device *device, pa_bluetooth_profile_t profile) {
+    DBusMessage *m;
+    const char *profile_uuid;
+    struct connect_profile_data *data;
+
+    profile_uuid = pa_bluetooth_profile_to_uuid(device, profile);
+
+    pa_log_info("Connecting device %s to profile %s (%s)", device->path, pa_bluetooth_profile_to_string(profile), profile_uuid);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, device->path, BLUEZ_DEVICE_INTERFACE, "ConnectProfile"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_STRING, &profile_uuid, DBUS_TYPE_INVALID));
+
+    data = pa_xnew0(struct connect_profile_data, 1);
+    data->device_path = pa_xstrdup(device->path);
+    data->profile_uuid = profile_uuid;
+    data->profile = profile;
+    send_and_add_to_pending(device->discovery, m, pa_bluetooth_device_connect_profile_reply, data);
+}
+
+struct connect_and_disconnect_profile_data {
+    char *device_path;
+    const char *disconnect_uuid;
+    pa_bluetooth_profile_t disconnect_profile;
+    pa_bluetooth_profile_t connect_profile;
+};
+
+static void pa_bluetooth_device_disconnect_profile_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_discovery *y;
+    pa_bluetooth_device *device;
+    struct connect_and_disconnect_profile_data *data;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(y = p->context_data);
+    pa_assert_se(data = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    device = pa_hashmap_get(y->devices, data->device_path);
+    if (!device)
+        pa_log_warn("Disconnecting device %s from profile %s (%s) failed: Device is not connected anymore", data->device_path, pa_bluetooth_profile_to_string(data->disconnect_profile), data->disconnect_uuid);
+    else if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR)
+        pa_log_warn("Disconnecting device %s from profile %s (%s) failed: %s: %s", data->device_path, pa_bluetooth_profile_to_string(data->disconnect_profile), data->disconnect_uuid, dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
+    else {
+        pa_log_info("Disconnecting device %s from profile %s (%s) succeeded", data->device_path, pa_bluetooth_profile_to_string(data->disconnect_profile), data->disconnect_uuid);
+        pa_bluetooth_device_connect_profile(device, data->connect_profile);
+    }
+
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
+    pa_dbus_pending_free(p);
+
+    pa_xfree(data->device_path);
+    pa_xfree(data);
+}
+
+void pa_bluetooth_device_disconnect_and_connect_profile(pa_bluetooth_device *device, pa_bluetooth_profile_t disconnect_profile, pa_bluetooth_profile_t connect_profile) {
+    DBusMessage *m;
+    const char *disconnect_uuid;
+    struct connect_and_disconnect_profile_data *data;
+
+    disconnect_uuid = pa_bluetooth_profile_to_uuid(device, disconnect_profile);
+
+    pa_log_info("Disconnecting device %s from profile %s (%s)", device->path, pa_bluetooth_profile_to_string(disconnect_profile), disconnect_uuid);
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, device->path, BLUEZ_DEVICE_INTERFACE, "DisconnectProfile"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_STRING, &disconnect_uuid, DBUS_TYPE_INVALID));
+
+    data = pa_xnew0(struct connect_and_disconnect_profile_data, 1);
+    data->device_path = pa_xstrdup(device->path);
+    data->disconnect_uuid = disconnect_uuid;
+    data->disconnect_profile = disconnect_profile;
+    data->connect_profile = connect_profile;
+    send_and_add_to_pending(device->discovery, m, pa_bluetooth_device_disconnect_profile_reply, data);
+}
+
+unsigned pa_bluetooth_profile_count(void) {
+    return PA_BLUETOOTH_PROFILE_A2DP_START_INDEX + 2 * pa_bluetooth_a2dp_codec_count();
+}
+
+bool pa_bluetooth_profile_is_a2dp(pa_bluetooth_profile_t profile) {
+    pa_assert(profile < pa_bluetooth_profile_count());
+    return profile >= PA_BLUETOOTH_PROFILE_A2DP_START_INDEX;
+}
+
+bool pa_bluetooth_profile_is_a2dp_source(pa_bluetooth_profile_t profile) {
+    unsigned source_start_index = PA_BLUETOOTH_PROFILE_A2DP_START_INDEX;
+    unsigned sink_start_index = PA_BLUETOOTH_PROFILE_A2DP_START_INDEX + pa_bluetooth_a2dp_codec_count();
+
+    pa_assert(profile < pa_bluetooth_profile_count());
+
+    return profile >= source_start_index && profile < sink_start_index;
+}
+
+bool pa_bluetooth_profile_is_a2dp_sink(pa_bluetooth_profile_t profile) {
+    unsigned sink_start_index = PA_BLUETOOTH_PROFILE_A2DP_START_INDEX + pa_bluetooth_a2dp_codec_count();
+
+    pa_assert(profile < pa_bluetooth_profile_count());
+
+    return profile >= sink_start_index;
+}
+
+const pa_a2dp_codec *pa_bluetooth_profile_to_a2dp_codec(pa_bluetooth_profile_t profile) {
+    unsigned source_start_index = PA_BLUETOOTH_PROFILE_A2DP_START_INDEX;
+    unsigned sink_start_index = PA_BLUETOOTH_PROFILE_A2DP_START_INDEX + pa_bluetooth_a2dp_codec_count();
+
+    pa_assert(profile >= source_start_index && profile < pa_bluetooth_profile_count());
+
+    if (profile < sink_start_index)
+        return pa_bluetooth_a2dp_codec_iter(profile - source_start_index);
+    else
+        return pa_bluetooth_a2dp_codec_iter(profile - sink_start_index);
+}
+
+pa_bluetooth_profile_t pa_bluetooth_profile_for_a2dp_codec(const char *codec_name, bool is_a2dp_sink) {
+    unsigned source_start_index = PA_BLUETOOTH_PROFILE_A2DP_START_INDEX;
+    unsigned sink_start_index = PA_BLUETOOTH_PROFILE_A2DP_START_INDEX + pa_bluetooth_a2dp_codec_count();
+    unsigned count = pa_bluetooth_a2dp_codec_count();
+    const pa_a2dp_codec *a2dp_codec;
+    unsigned i;
+
+    for (i = 0; i < count; i++) {
+        a2dp_codec = pa_bluetooth_a2dp_codec_iter(i);
+        if (pa_streq(a2dp_codec->name, codec_name))
+            return i + (is_a2dp_sink ? sink_start_index : source_start_index);
+    }
+
+    return PA_BLUETOOTH_PROFILE_OFF;
+}
+
 const char *pa_bluetooth_profile_to_string(pa_bluetooth_profile_t profile) {
+    static __thread char profile_string[128];
+    const pa_a2dp_codec *a2dp_codec;
+    bool is_a2dp_sink;
+
     switch(profile) {
-        case PA_BLUETOOTH_PROFILE_A2DP_SINK:
-            return "a2dp_sink";
-        case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-            return "a2dp_source";
-        case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
+        case PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT:
             return "headset_head_unit";
-        case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
+        case PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT:
+            return "handsfree_head_unit";
+        case PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY:
             return "headset_audio_gateway";
+        case PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY:
+            return "handsfree_audio_gateway";
         case PA_BLUETOOTH_PROFILE_OFF:
             return "off";
+        default:
+            break;
     }
 
-    return NULL;
+    a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(profile);
+    is_a2dp_sink = pa_bluetooth_profile_is_a2dp_sink(profile);
+
+    /* backward compatible profile names for SBC codec */
+    if (pa_streq(a2dp_codec->name, "sbc"))
+        return is_a2dp_sink ? "a2dp_sink" : "a2dp_source";
+
+    pa_snprintf(profile_string, sizeof(profile_string), "a2dp_%s_%s", is_a2dp_sink ? "sink" : "source", a2dp_codec->name);
+    return profile_string;
+}
+
+static pa_bluetooth_profile_t a2dp_endpoint_to_bluetooth_profile(const char *endpoint) {
+    const char *codec_name;
+    bool is_a2dp_sink;
+
+    if (pa_startswith(endpoint, A2DP_SINK_ENDPOINT "/")) {
+        codec_name = endpoint + strlen(A2DP_SINK_ENDPOINT "/");
+        is_a2dp_sink = false;
+    } else if (pa_startswith(endpoint, A2DP_SOURCE_ENDPOINT "/")) {
+        codec_name = endpoint + strlen(A2DP_SOURCE_ENDPOINT "/");
+        is_a2dp_sink = true;
+    } else {
+        return PA_BLUETOOTH_PROFILE_OFF;
+    }
+
+    return pa_bluetooth_profile_for_a2dp_codec(codec_name, is_a2dp_sink);
 }
 
 static const pa_a2dp_codec *a2dp_endpoint_to_a2dp_codec(const char *endpoint) {
@@ -1343,13 +2354,9 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
 
             dbus_message_iter_get_basic(&value, &uuid);
 
-            if (pa_startswith(endpoint_path, A2DP_SINK_ENDPOINT "/"))
-                p = PA_BLUETOOTH_PROFILE_A2DP_SOURCE;
-            else if (pa_startswith(endpoint_path, A2DP_SOURCE_ENDPOINT "/"))
-                p = PA_BLUETOOTH_PROFILE_A2DP_SINK;
-
-            if ((pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE) && p != PA_BLUETOOTH_PROFILE_A2DP_SINK) ||
-                (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK) && p != PA_BLUETOOTH_PROFILE_A2DP_SOURCE)) {
+            p = a2dp_endpoint_to_bluetooth_profile(endpoint_path);
+            if ((pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE) && !pa_bluetooth_profile_is_a2dp_sink(p)) ||
+                (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK) && !pa_bluetooth_profile_is_a2dp_source(p))) {
                 pa_log_error("UUID %s of transport %s incompatible with endpoint %s", uuid, path, endpoint_path);
                 goto fail;
             }
@@ -1413,9 +2420,16 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
     dbus_message_unref(r);
 
     t = pa_bluetooth_transport_new(d, sender, path, p, config, size);
-    t->a2dp_codec = a2dp_codec;
+    /* AVRCP Absolute Volume is dynamically detected and enabled as soon as the
+     * Volume property becomes available */
+    t->rx_soft_volume = true;
+    t->tx_soft_volume = true;
+    t->max_rx_volume_gain = A2DP_MAX_GAIN;
+    t->max_tx_volume_gain = A2DP_MAX_GAIN;
     t->acquire = bluez5_transport_acquire_cb;
     t->release = bluez5_transport_release_cb;
+    t->set_rx_volume_gain = bluez5_transport_set_source_volume;
+    t->set_tx_volume_gain = bluez5_transport_set_sink_volume;
     pa_bluetooth_transport_put(t);
 
     pa_log_debug("Transport %s available for profile %s", t->path, pa_bluetooth_profile_to_string(t->profile));
@@ -1582,7 +2596,131 @@ static void endpoint_done(pa_bluetooth_discovery *y, const char *endpoint) {
     dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), endpoint);
 }
 
-pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backend) {
+static void append_a2dp_object(DBusMessageIter *iter, const char *endpoint, const char *uuid, uint8_t codec_id, uint8_t *capabilities, uint8_t capabilities_size) {
+    const char *interface_name = BLUEZ_MEDIA_ENDPOINT_INTERFACE;
+    DBusMessageIter object, array, entry, dict;
+
+    dbus_message_iter_open_container(iter, DBUS_TYPE_DICT_ENTRY, NULL, &object);
+    pa_assert_se(dbus_message_iter_append_basic(&object, DBUS_TYPE_OBJECT_PATH, &endpoint));
+
+    dbus_message_iter_open_container(&object, DBUS_TYPE_ARRAY,
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_ARRAY_AS_STRING
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_VARIANT_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                     DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                     &array);
+
+    dbus_message_iter_open_container(&array, DBUS_TYPE_DICT_ENTRY, NULL, &entry);
+    pa_assert_se(dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &interface_name));
+
+    dbus_message_iter_open_container(&entry, DBUS_TYPE_ARRAY,
+                                     DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                     DBUS_TYPE_STRING_AS_STRING
+                                     DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                     &dict);
+
+    pa_dbus_append_basic_variant_dict_entry(&dict, "UUID", DBUS_TYPE_STRING, &uuid);
+    pa_dbus_append_basic_variant_dict_entry(&dict, "Codec", DBUS_TYPE_BYTE, &codec_id);
+    pa_dbus_append_basic_array_variant_dict_entry(&dict, "Capabilities", DBUS_TYPE_BYTE, capabilities, capabilities_size);
+
+    dbus_message_iter_close_container(&entry, &dict);
+    dbus_message_iter_close_container(&array, &entry);
+    dbus_message_iter_close_container(&object, &array);
+    dbus_message_iter_close_container(iter, &object);
+}
+
+static DBusHandlerResult object_manager_handler(DBusConnection *c, DBusMessage *m, void *userdata) {
+    struct pa_bluetooth_discovery *y = userdata;
+    DBusMessage *r;
+    const char *path, *interface, *member;
+
+    pa_assert(y);
+
+    path = dbus_message_get_path(m);
+    interface = dbus_message_get_interface(m);
+    member = dbus_message_get_member(m);
+
+    pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
+
+    if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
+        const char *xml = OBJECT_MANAGER_INTROSPECT_XML;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+        pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_STRING, &xml, DBUS_TYPE_INVALID));
+    } else if (dbus_message_is_method_call(m, "org.freedesktop.DBus.ObjectManager", "GetManagedObjects")) {
+        DBusMessageIter iter, array;
+        unsigned a2dp_codec_i;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+
+        dbus_message_iter_init_append(r, &iter);
+        dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
+                                         DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                         DBUS_TYPE_OBJECT_PATH_AS_STRING
+                                         DBUS_TYPE_ARRAY_AS_STRING
+                                         DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                         DBUS_TYPE_STRING_AS_STRING
+                                         DBUS_TYPE_ARRAY_AS_STRING
+                                         DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
+                                         DBUS_TYPE_STRING_AS_STRING
+                                         DBUS_TYPE_VARIANT_AS_STRING
+                                         DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                         DBUS_DICT_ENTRY_END_CHAR_AS_STRING
+                                         DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
+                                         &array);
+
+        /* Order is important. bluez prefers endpoints registered earlier.
+         * And codec with higher number has higher priority. So iterate in reverse order. */
+        for (a2dp_codec_i = pa_bluetooth_a2dp_codec_count(); a2dp_codec_i > 0; a2dp_codec_i--) {
+            const pa_a2dp_codec *a2dp_codec;
+            uint8_t capabilities[MAX_A2DP_CAPS_SIZE];
+            uint8_t capabilities_size;
+            uint8_t codec_id;
+            char *endpoint;
+
+            a2dp_codec = pa_bluetooth_a2dp_codec_iter(a2dp_codec_i-1);
+            codec_id = a2dp_codec->id.codec_id;
+            capabilities_size = a2dp_codec->fill_capabilities(capabilities);
+            pa_assert(capabilities_size != 0);
+
+            endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, a2dp_codec->name);
+            append_a2dp_object(&array, endpoint, PA_BLUETOOTH_UUID_A2DP_SINK, codec_id, capabilities, capabilities_size);
+            pa_xfree(endpoint);
+
+            endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, a2dp_codec->name);
+            append_a2dp_object(&array, endpoint, PA_BLUETOOTH_UUID_A2DP_SOURCE, codec_id, capabilities, capabilities_size);
+            pa_xfree(endpoint);
+        }
+
+        dbus_message_iter_close_container(&iter, &array);
+    } else
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(y->connection), r, NULL));
+    dbus_message_unref(r);
+
+    return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+static void object_manager_init(pa_bluetooth_discovery *y) {
+    static const DBusObjectPathVTable vtable = {
+        .message_function = object_manager_handler,
+    };
+
+    pa_assert(y);
+    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(y->connection), A2DP_OBJECT_MANAGER_PATH, &vtable, y));
+}
+
+static void object_manager_done(pa_bluetooth_discovery *y) {
+    pa_assert(y);
+    dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), A2DP_OBJECT_MANAGER_PATH);
+}
+
+pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c) {
     pa_bluetooth_discovery *y;
     DBusError err;
     DBusConnection *conn;
@@ -1593,12 +2731,13 @@ pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backe
     y = pa_xnew0(pa_bluetooth_discovery, 1);
     PA_REFCNT_INIT(y);
     y->core = c;
-    y->headset_backend = headset_backend;
     y->adapters = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL,
                                       (pa_free_cb_t) adapter_free);
     y->devices = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL,
                                      (pa_free_cb_t) device_free);
     y->transports = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
+    y->pending_transport_fds = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func,
+                                                   NULL, (pa_free_cb_t) bluez5_transport_release_staled_pending_fd);
     PA_LLIST_HEAD_INIT(pa_dbus_pending, y->pending);
 
     for (i = 0; i < PA_BLUETOOTH_HOOK_MAX; i++)
@@ -1633,6 +2772,8 @@ pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backe
             "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',member='PropertiesChanged'"
             ",arg0='" BLUEZ_DEVICE_INTERFACE "'",
             "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',member='PropertiesChanged'"
+            ",arg0='" BLUEZ_MEDIA_ENDPOINT_INTERFACE "'",
+            "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',member='PropertiesChanged'"
             ",arg0='" BLUEZ_MEDIA_TRANSPORT_INTERFACE "'",
             NULL) < 0) {
         pa_log_error("Failed to add D-Bus matches: %s", err.message);
@@ -1640,6 +2781,8 @@ pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backe
     }
     y->matches_added = true;
 
+    object_manager_init(y);
+
     count = pa_bluetooth_a2dp_codec_count();
     for (i = 0; i < count; i++) {
         a2dp_codec = pa_bluetooth_a2dp_codec_iter(i);
@@ -1686,10 +2829,11 @@ void pa_bluetooth_discovery_unref(pa_bluetooth_discovery *y) {
 
     pa_dbus_free_pending_list(&y->pending);
 
-    if (y->ofono_backend)
-        pa_bluetooth_ofono_backend_free(y->ofono_backend);
-    if (y->native_backend)
-        pa_bluetooth_native_backend_free(y->native_backend);
+    if (y->hsphfpd)
+        pa_bluetooth_hsphfpd_free(y->hsphfpd);
+
+    if (y->pending_transport_fds)
+        pa_hashmap_free(y->pending_transport_fds);
 
     if (y->adapters)
         pa_hashmap_free(y->adapters);
@@ -1717,12 +2861,16 @@ void pa_bluetooth_discovery_unref(pa_bluetooth_discovery *y) {
                 "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',"
                 "member='PropertiesChanged',arg0='" BLUEZ_DEVICE_INTERFACE "'",
                 "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',"
+                "member='PropertiesChanged',arg0='" BLUEZ_MEDIA_ENDPOINT_INTERFACE "'",
+                "type='signal',sender='" BLUEZ_SERVICE "',interface='org.freedesktop.DBus.Properties',"
                 "member='PropertiesChanged',arg0='" BLUEZ_MEDIA_TRANSPORT_INTERFACE "'",
                 NULL);
 
         if (y->filter_added)
             dbus_connection_remove_filter(pa_dbus_connection_get(y->connection), filter_cb, y);
 
+        object_manager_done(y);
+
         count = pa_bluetooth_a2dp_codec_count();
         for (i = 0; i < count; i++) {
             a2dp_codec = pa_bluetooth_a2dp_codec_iter(i);
diff --git a/src/modules/bluetooth/bluez5-util.h b/src/modules/bluetooth/bluez5-util.h
index ff172e025..e9885367d 100644
--- a/src/modules/bluetooth/bluez5-util.h
+++ b/src/modules/bluetooth/bluez5-util.h
@@ -43,25 +43,39 @@ typedef struct pa_bluetooth_transport pa_bluetooth_transport;
 typedef struct pa_bluetooth_device pa_bluetooth_device;
 typedef struct pa_bluetooth_adapter pa_bluetooth_adapter;
 typedef struct pa_bluetooth_discovery pa_bluetooth_discovery;
-typedef struct pa_bluetooth_backend pa_bluetooth_backend;
 
 typedef enum pa_bluetooth_hook {
     PA_BLUETOOTH_HOOK_DEVICE_CONNECTION_CHANGED,          /* Call data: pa_bluetooth_device */
+    PA_BLUETOOTH_HOOK_PROFILE_CONNECTION_CHANGED,         /* Call data: pa_bluetooth_device_and_profile */
     PA_BLUETOOTH_HOOK_DEVICE_UNLINK,                      /* Call data: pa_bluetooth_device */
     PA_BLUETOOTH_HOOK_TRANSPORT_STATE_CHANGED,            /* Call data: pa_bluetooth_transport */
-    PA_BLUETOOTH_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED,  /* Call data: pa_bluetooth_transport */
-    PA_BLUETOOTH_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED,     /* Call data: pa_bluetooth_transport */
+    PA_BLUETOOTH_HOOK_TRANSPORT_RX_VOLUME_GAIN_CHANGED,   /* Call data: pa_bluetooth_transport */
+    PA_BLUETOOTH_HOOK_TRANSPORT_TX_VOLUME_GAIN_CHANGED,   /* Call data: pa_bluetooth_transport */
     PA_BLUETOOTH_HOOK_MAX
 } pa_bluetooth_hook_t;
 
-typedef enum profile {
-    PA_BLUETOOTH_PROFILE_A2DP_SINK,
-    PA_BLUETOOTH_PROFILE_A2DP_SOURCE,
-    PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT,
-    PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY,
-    PA_BLUETOOTH_PROFILE_OFF
-} pa_bluetooth_profile_t;
-#define PA_BLUETOOTH_PROFILE_COUNT PA_BLUETOOTH_PROFILE_OFF
+/* Profile index is used also for card profile priority. Higher number has higher priority.
+ * All A2DP profiles have higher priority as all non-A2DP profiles.
+ * And all A2DP sink profiles have higher priority as all A2DP source profiles. */
+#define PA_BLUETOOTH_PROFILE_OFF                    0
+#define PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY      1
+#define PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY      2
+#define PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT          3
+#define PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT          4
+#define PA_BLUETOOTH_PROFILE_A2DP_START_INDEX       5
+typedef unsigned pa_bluetooth_profile_t;
+
+typedef enum {
+    PA_BLUETOOTH_STATUS_SUCCESS,
+    PA_BLUETOOTH_STATUS_FAILED,
+    PA_BLUETOOTH_STATUS_NOTAVAILABLE,
+} pa_bluetooth_status;
+
+struct pa_bluetooth_device_and_profile {
+    pa_bluetooth_device *device;
+    pa_bluetooth_profile_t profile;
+    pa_bluetooth_status status;
+};
 
 typedef enum pa_bluetooth_transport_state {
     PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED,
@@ -69,11 +83,11 @@ typedef enum pa_bluetooth_transport_state {
     PA_BLUETOOTH_TRANSPORT_STATE_PLAYING
 } pa_bluetooth_transport_state_t;
 
-typedef int (*pa_bluetooth_transport_acquire_cb)(pa_bluetooth_transport *t, bool optional, size_t *imtu, size_t *omtu);
+typedef int (*pa_bluetooth_transport_acquire_cb)(pa_bluetooth_transport *t, size_t *imtu, size_t *omtu);
 typedef void (*pa_bluetooth_transport_release_cb)(pa_bluetooth_transport *t);
 typedef void (*pa_bluetooth_transport_destroy_cb)(pa_bluetooth_transport *t);
-typedef void (*pa_bluetooth_transport_set_speaker_gain_cb)(pa_bluetooth_transport *t, uint16_t gain);
-typedef void (*pa_bluetooth_transport_set_microphone_gain_cb)(pa_bluetooth_transport *t, uint16_t gain);
+typedef void (*pa_bluetooth_transport_set_rx_volume_gain_cb)(pa_bluetooth_transport *t, uint16_t gain);
+typedef void (*pa_bluetooth_transport_set_tx_volume_gain_cb)(pa_bluetooth_transport *t, uint16_t gain);
 
 struct pa_bluetooth_transport {
     pa_bluetooth_device *device;
@@ -82,22 +96,23 @@ struct pa_bluetooth_transport {
     char *path;
     pa_bluetooth_profile_t profile;
 
-    uint8_t codec;
     uint8_t *config;
     size_t config_size;
 
-    const pa_a2dp_codec *a2dp_codec;
-
-    uint16_t microphone_gain;
-    uint16_t speaker_gain;
+    bool rx_soft_volume;
+    bool tx_soft_volume;
+    pa_volume_t rx_volume_gain;
+    pa_volume_t tx_volume_gain;
+    pa_volume_t max_rx_volume_gain;
+    pa_volume_t max_tx_volume_gain;
 
     pa_bluetooth_transport_state_t state;
 
     pa_bluetooth_transport_acquire_cb acquire;
     pa_bluetooth_transport_release_cb release;
     pa_bluetooth_transport_destroy_cb destroy;
-    pa_bluetooth_transport_set_speaker_gain_cb set_speaker_gain;
-    pa_bluetooth_transport_set_microphone_gain_cb set_microphone_gain;
+    pa_bluetooth_transport_set_rx_volume_gain_cb set_rx_volume_gain;
+    pa_bluetooth_transport_set_tx_volume_gain_cb set_tx_volume_gain;
     void *userdata;
 };
 
@@ -108,7 +123,7 @@ struct pa_bluetooth_device {
     bool properties_received;
     bool tried_to_link_with_adapter;
     bool valid;
-    bool autodetect_mtu;
+    pa_bluetooth_profile_t new_profile_in_progress;
 
     /* Device information */
     char *path;
@@ -117,8 +132,10 @@ struct pa_bluetooth_device {
     char *address;
     uint32_t class_of_device;
     pa_hashmap *uuids; /* char* -> char* (hashmap-as-a-set) */
+    pa_hashmap *a2dp_sink_endpoints; /* pa_a2dp_codec_id* -> pa_hashmap ( char* (remote endpoint) -> struct a2dp_codec_capabilities* ) */
+    pa_hashmap *a2dp_source_endpoints; /* pa_a2dp_codec_id* -> pa_hashmap ( char* (remote endpoint) -> struct a2dp_codec_capabilities* ) */
 
-    pa_bluetooth_transport *transports[PA_BLUETOOTH_PROFILE_COUNT];
+    pa_bluetooth_transport **transports;
 
     pa_time_event *wait_for_profiles_timer;
 };
@@ -129,57 +146,51 @@ struct pa_bluetooth_adapter {
     char *address;
 
     bool valid;
+    bool media_application_registered;
 };
 
-#ifdef HAVE_BLUEZ_5_OFONO_HEADSET
-pa_bluetooth_backend *pa_bluetooth_ofono_backend_new(pa_core *c, pa_bluetooth_discovery *y);
-void pa_bluetooth_ofono_backend_free(pa_bluetooth_backend *b);
-#else
-static inline pa_bluetooth_backend *pa_bluetooth_ofono_backend_new(pa_core *c, pa_bluetooth_discovery *y) {
-    return NULL;
-}
-static inline void pa_bluetooth_ofono_backend_free(pa_bluetooth_backend *b) {}
-#endif
-
-#ifdef HAVE_BLUEZ_5_NATIVE_HEADSET
-pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_hs_role);
-void pa_bluetooth_native_backend_free(pa_bluetooth_backend *b);
-void pa_bluetooth_native_backend_enable_hs_role(pa_bluetooth_backend *b, bool enable_hs_role);
-#else
-static inline pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_hs_role) {
-    return NULL;
-}
-static inline void pa_bluetooth_native_backend_free(pa_bluetooth_backend *b) {}
-static inline void pa_bluetooth_native_backend_enable_hs_role(pa_bluetooth_backend *b, bool enable_hs_role) {}
-#endif
-
 pa_bluetooth_transport *pa_bluetooth_transport_new(pa_bluetooth_device *d, const char *owner, const char *path,
                                                    pa_bluetooth_profile_t p, const uint8_t *config, size_t size);
 
 void pa_bluetooth_transport_set_state(pa_bluetooth_transport *t, pa_bluetooth_transport_state_t state);
+pa_bluetooth_transport *pa_bluetooth_transport_get(pa_bluetooth_discovery *y, const char *path);
+pa_hashmap *pa_bluetooth_transport_get_all(pa_bluetooth_discovery *y);
 void pa_bluetooth_transport_put(pa_bluetooth_transport *t);
-void pa_bluetooth_transport_unlink(pa_bluetooth_transport *t);
 void pa_bluetooth_transport_free(pa_bluetooth_transport *t);
+void pa_bluetooth_transport_setup_a2dp_absolute_volume(pa_bluetooth_transport *t);
+
+size_t pa_bluetooth_device_find_a2dp_endpoints_for_codec(const pa_bluetooth_device *device, const pa_a2dp_codec *a2dp_codec, bool is_a2dp_sink, const char **endpoints, size_t endpoints_max_count);
+bool pa_bluetooth_device_change_a2dp_profile(pa_bluetooth_device *d, pa_bluetooth_profile_t profile);
+
+void pa_bluetooth_device_connect_profile(pa_bluetooth_device *device, pa_bluetooth_profile_t profile);
+void pa_bluetooth_device_disconnect_and_connect_profile(pa_bluetooth_device *device, pa_bluetooth_profile_t disconnect_profile, pa_bluetooth_profile_t connect_profile);
 
 bool pa_bluetooth_device_any_transport_connected(const pa_bluetooth_device *d);
+bool pa_bluetooth_device_a2dp_sink_transport_connected(const pa_bluetooth_device *d);
+bool pa_bluetooth_device_a2dp_source_transport_connected(const pa_bluetooth_device *d);
 
 pa_bluetooth_device* pa_bluetooth_discovery_get_device_by_path(pa_bluetooth_discovery *y, const char *path);
 pa_bluetooth_device* pa_bluetooth_discovery_get_device_by_address(pa_bluetooth_discovery *y, const char *remote, const char *local);
 
 pa_hook* pa_bluetooth_discovery_hook(pa_bluetooth_discovery *y, pa_bluetooth_hook_t hook);
 
+unsigned pa_bluetooth_profile_count(void);
+bool pa_bluetooth_profile_is_a2dp(pa_bluetooth_profile_t profile);
+bool pa_bluetooth_profile_is_a2dp_sink(pa_bluetooth_profile_t profile);
+bool pa_bluetooth_profile_is_a2dp_source(pa_bluetooth_profile_t profile);
+const pa_a2dp_codec *pa_bluetooth_profile_to_a2dp_codec(pa_bluetooth_profile_t profile);
+pa_bluetooth_profile_t pa_bluetooth_profile_for_a2dp_codec(const char *codec_name, bool is_a2dp_sink);
 const char *pa_bluetooth_profile_to_string(pa_bluetooth_profile_t profile);
 
+static inline bool pa_bluetooth_profile_support_a2dp_backchannel(pa_bluetooth_profile_t profile) {
+    return pa_bluetooth_profile_to_a2dp_codec(profile)->support_backchannel;
+}
+
 static inline bool pa_bluetooth_uuid_is_hsp_hs(const char *uuid) {
     return pa_streq(uuid, PA_BLUETOOTH_UUID_HSP_HS) || pa_streq(uuid, PA_BLUETOOTH_UUID_HSP_HS_ALT);
 }
 
-#define HEADSET_BACKEND_OFONO 0
-#define HEADSET_BACKEND_NATIVE 1
-#define HEADSET_BACKEND_AUTO 2
-
-pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *core, int headset_backend);
+pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *core);
 pa_bluetooth_discovery* pa_bluetooth_discovery_ref(pa_bluetooth_discovery *y);
 void pa_bluetooth_discovery_unref(pa_bluetooth_discovery *y);
-void pa_bluetooth_discovery_set_ofono_running(pa_bluetooth_discovery *y, bool is_running);
 #endif
diff --git a/src/modules/bluetooth/hsphfpd-util.c b/src/modules/bluetooth/hsphfpd-util.c
new file mode 100644
index 000000000..6f6986321
--- /dev/null
+++ b/src/modules/bluetooth/hsphfpd-util.c
@@ -0,0 +1,1377 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2020 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+
+#include <pulsecore/shared.h>
+#include <pulsecore/core-error.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/dbus-shared.h>
+#include <pulsecore/log.h>
+
+#include "bluez5-util.h"
+#include "hsphfpd-util.h"
+#include "legacy-hsp.h"
+
+#define DBUS_INTERFACE_OBJECTMANAGER DBUS_SERVICE_DBUS ".ObjectManager"
+
+#define HSPHFPD_SERVICE "org.hsphfpd"
+#define HSPHFPD_APPLICATION_MANAGER_INTERFACE HSPHFPD_SERVICE ".ApplicationManager"
+#define HSPHFPD_ENDPOINT_INTERFACE HSPHFPD_SERVICE ".Endpoint"
+#define HSPHFPD_AUDIO_TRANSPORT_INTERFACE HSPHFPD_SERVICE ".AudioTransport"
+#define HSPHFPD_AUDIO_AGENT_INTERFACE HSPHFPD_SERVICE ".AudioAgent"
+
+#define APPLICATION_OBJECT_MANAGER_PATH "/SCOEndpoint"
+#define AUDIO_AGENT_ENDPOINT_PCM_S16LE_8KHZ APPLICATION_OBJECT_MANAGER_PATH "/PCM_s16le_8kHz"
+#define AUDIO_AGENT_ENDPOINT_MSBC APPLICATION_OBJECT_MANAGER_PATH "/mSBC"
+
+#define APPLICATION_OBJECT_MANAGER_INTROSPECT_XML                              \
+    DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                                  \
+    "<node>\n"                                                                 \
+    " <interface name=\"" DBUS_INTERFACE_OBJECTMANAGER "\">\n"                 \
+    "  <method name=\"GetManagedObjects\">\n"                                  \
+    "   <arg name=\"objects\" direction=\"out\" type=\"a{oa{sa{sv}}}\"/>\n"    \
+    "  </method>\n"                                                            \
+    "  <signal name=\"InterfacesAdded\">\n"                                    \
+    "   <arg name=\"object\" type=\"o\"/>\n"                                   \
+    "   <arg name=\"interfaces\" type=\"a{sa{sv}}\"/>\n"                       \
+    "  </signal>\n"                                                            \
+    "  <signal name=\"InterfacesRemoved\">\n"                                  \
+    "   <arg name=\"object\" type=\"o\"/>\n"                                   \
+    "   <arg name=\"interfaces\" type=\"as\"/>\n"                              \
+    "  </signal>\n"                                                            \
+    " </interface>\n"                                                          \
+    " <interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">\n"                \
+    "  <method name=\"Introspect\">\n"                                         \
+    "   <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"                   \
+    "  </method>\n"                                                            \
+    " </interface>\n"                                                          \
+    "</node>\n"
+
+#define AUDIO_AGENT_ENDPOINT_INTROSPECT_XML                                    \
+    DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                                  \
+    "<node>\n"                                                                 \
+    " <interface name=\"" HSPHFPD_AUDIO_AGENT_INTERFACE "\">\n"                \
+    "  <method name=\"NewConnection\">\n"                                      \
+    "   <arg name=\"audio_transport\" direction=\"in\" type=\"o\"/>\n"         \
+    "   <arg name=\"sco\" direction=\"in\" type=\"h\"/>\n"                     \
+    "   <arg name=\"properties\" direction=\"in\" type=\"a{sv}\"/>\n"          \
+    "  </method>\n"                                                            \
+    "  <property name=\"AgentCodec\" type=\"s\" access=\"read\"/>\n"           \
+    " </interface>\n"                                                          \
+    " <interface name=\"" DBUS_INTERFACE_INTROSPECTABLE "\">\n"                \
+    "  <method name=\"Introspect\">\n"                                         \
+    "   <arg name=\"data\" direction=\"out\" type=\"s\"/>\n"                   \
+    "  </method>\n"                                                            \
+    " </interface>\n"                                                          \
+    " <interface name=\"" DBUS_INTERFACE_PROPERTIES "\">\n"                    \
+    "  <method name=\"Get\">\n"                                                \
+    "   <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n"               \
+    "   <arg name=\"name\" direction=\"in\" type=\"s\"/>\n"                    \
+    "   <arg name=\"value\" direction=\"out\" type=\"v\"/>\n"                  \
+    "  </method>\n"                                                            \
+    "  <method name=\"GetAll\">\n"                                             \
+    "   <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n"               \
+    "   <arg name=\"properties\" direction=\"out\" type=\"a{sv}\"/>\n"         \
+    "  </method>\n"                                                            \
+    " </interface>\n"                                                          \
+    "</node>\n"
+
+enum hsphfpd_volume_control {
+    HSPHFPD_VOLUME_CONTROL_NONE = 1,
+    HSPHFPD_VOLUME_CONTROL_LOCAL,
+    HSPHFPD_VOLUME_CONTROL_REMOTE,
+};
+
+enum hsphfpd_profile {
+    HSPHFPD_PROFILE_HEADSET = 1,
+    HSPHFPD_PROFILE_HANDSFREE,
+};
+
+enum hsphfpd_role {
+    HSPHFPD_ROLE_CLIENT = 1,
+    HSPHFPD_ROLE_GATEWAY,
+};
+
+struct hsphfpd_transport_data {
+    pa_bluetooth_hsphfpd *hsphfpd;
+    int sco_fd;
+    char *transport_path;
+    char *agent_codec;
+    char *air_codec;
+    enum hsphfpd_volume_control rx_volume_control;
+    enum hsphfpd_volume_control tx_volume_control;
+    uint16_t mtu;
+};
+
+struct hsphfpd_endpoint {
+    char *path;
+    bool valid;
+    bool connected;
+    char *remote_address;
+    char *local_address;
+    enum hsphfpd_profile profile;
+    enum hsphfpd_role role;
+};
+
+struct pa_bluetooth_hsphfpd {
+    pa_core *core;
+    pa_bluetooth_legacy_hsp *legacy_hsp;
+    pa_bluetooth_discovery *discovery;
+    pa_dbus_connection *connection;
+    pa_hashmap *endpoints;
+    bool endpoints_listed;
+    char *hsphfpd_service_id;
+
+    PA_LLIST_HEAD(pa_dbus_pending, pending);
+};
+
+static void hsphfpd_endpoint_free(struct hsphfpd_endpoint *endpoint) {
+    pa_assert(endpoint);
+
+    pa_xfree(endpoint->path);
+    pa_xfree(endpoint->remote_address);
+    pa_xfree(endpoint->local_address);
+    pa_xfree(endpoint);
+}
+
+static pa_dbus_pending *send_and_add_to_pending(pa_bluetooth_hsphfpd *hsphfpd, DBusMessage *m, DBusPendingCallNotifyFunction func, void *call_data) {
+    pa_dbus_pending *p;
+    DBusPendingCall *call;
+
+    pa_assert(hsphfpd);
+    pa_assert(m);
+
+    pa_assert_se(dbus_connection_send_with_reply(pa_dbus_connection_get(hsphfpd->connection), m, &call, -1));
+
+    p = pa_dbus_pending_new(pa_dbus_connection_get(hsphfpd->connection), m, call, hsphfpd, call_data);
+    PA_LLIST_PREPEND(pa_dbus_pending, hsphfpd->pending, p);
+    dbus_pending_call_set_notify(call, func, p, NULL);
+
+    return p;
+}
+
+static void set_dbus_property_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_hsphfpd *hsphfpd;
+    char *error_message;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(hsphfpd = p->context_data);
+    pa_assert_se(error_message = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR)
+        pa_log_error("%s: %s: %s", error_message, dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
+
+    pa_xfree(error_message);
+
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, hsphfpd->pending, p);
+    pa_dbus_pending_free(p);
+}
+
+static void set_dbus_property(pa_bluetooth_hsphfpd *hsphfpd, const char *service, const char *path, const char *interface, const char *property, int type, void *value, char *error_message) {
+    DBusMessage *m;
+    DBusMessageIter iter;
+    pa_assert_se(m = dbus_message_new_method_call(service, path, DBUS_INTERFACE_PROPERTIES, "Set"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_STRING, &interface, DBUS_TYPE_STRING, &property, DBUS_TYPE_INVALID));
+    dbus_message_iter_init_append(m, &iter);
+    pa_dbus_append_basic_variant(&iter, type, value);
+    send_and_add_to_pending(hsphfpd, m, set_dbus_property_reply, error_message);
+}
+
+static inline void set_rx_volume_gain_property(const struct hsphfpd_transport_data *transport_data, uint16_t gain) {
+    if (transport_data->sco_fd < 0 || transport_data->rx_volume_control <= HSPHFPD_VOLUME_CONTROL_NONE)
+        return;
+    set_dbus_property(transport_data->hsphfpd, HSPHFPD_SERVICE, transport_data->transport_path, HSPHFPD_AUDIO_TRANSPORT_INTERFACE, "RxVolumeGain", DBUS_TYPE_UINT16, &gain, pa_sprintf_malloc("Changing rx volume gain to %u for transport %s failed", (unsigned)gain, transport_data->transport_path));
+}
+
+static inline void set_tx_volume_gain_property(const struct hsphfpd_transport_data *transport_data, uint16_t gain) {
+    if (transport_data->sco_fd < 0 || transport_data->tx_volume_control <= HSPHFPD_VOLUME_CONTROL_NONE)
+        return;
+    set_dbus_property(transport_data->hsphfpd, HSPHFPD_SERVICE, transport_data->transport_path, HSPHFPD_AUDIO_TRANSPORT_INTERFACE, "TxVolumeGain", DBUS_TYPE_UINT16, &gain, pa_sprintf_malloc("Changing tx volume gain to %u for transport %s failed", (unsigned)gain, transport_data->transport_path));
+}
+
+static void hsphfpd_transport_connect_audio_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    DBusError error;
+    pa_dbus_pending *p;
+    pa_bluetooth_hsphfpd *hsphfpd;
+    pa_bluetooth_transport *transport;
+    const char *error_name;
+    char *endpoint_path;
+    const char *transport_path;
+    const char *service_id;
+    const char *agent_path;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(hsphfpd = p->context_data);
+    pa_assert_se(endpoint_path = p->call_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    dbus_error_init(&error);
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        error_name = dbus_message_get_error_name(r);
+        if (pa_safe_streq(error_name, HSPHFPD_SERVICE ".AlreadyConnected"))
+            goto success;
+        if (pa_safe_streq(error_name, HSPHFPD_SERVICE ".InProgress"))
+            goto finish; /* Another ConnectAudio() call is in progress, so do not touch transport state */
+        pa_log_warn(HSPHFPD_ENDPOINT_INTERFACE ".ConnectAudio() failed: %s: %s", error_name, pa_dbus_get_error_message(r));
+        goto failed;
+    }
+
+    if (!pa_safe_streq(dbus_message_get_sender(r), hsphfpd->hsphfpd_service_id)) {
+        pa_log_error("Reply for " HSPHFPD_ENDPOINT_INTERFACE ".ConnectAudio() from invalid sender");
+        goto failed;
+    }
+
+    if (!pa_streq(dbus_message_get_signature(r), "oso")) {
+        pa_log_error("Invalid reply signature for " HSPHFPD_ENDPOINT_INTERFACE ".ConnectAudio()");
+        goto failed;
+    }
+
+    if (!dbus_message_get_args(r, &error, DBUS_TYPE_OBJECT_PATH, &transport_path, DBUS_TYPE_STRING, &service_id, DBUS_TYPE_OBJECT_PATH, &agent_path, DBUS_TYPE_INVALID) || dbus_error_is_set(&error)) {
+        pa_log_error("Failed to parse " HSPHFPD_ENDPOINT_INTERFACE ".ConnectAudio() reply: %s", error.message);
+        goto failed;
+    }
+
+    if (!pa_safe_streq(service_id, dbus_bus_get_unique_name(pa_dbus_connection_get(hsphfpd->connection)))) {
+        pa_log_warn(HSPHFPD_ENDPOINT_INTERFACE ".ConnectAudio() failed: Other audio application took audio socket");
+        goto failed;
+    }
+
+success:
+    /* On success hsphfpd daemon asynchronously should have called NewConnection() method
+     * prior sending reply for ConnectAudio() method. Our callback for NewConnection()
+     * changes transport state to playing on success, so check it if connection is really
+     * successfully established. */
+    transport = pa_bluetooth_transport_get(hsphfpd->discovery, endpoint_path);
+    if (transport && transport->state == PA_BLUETOOTH_TRANSPORT_STATE_PLAYING)
+        goto finish;
+
+failed:
+    /* If transport state is idle switch it to disconnected state and then back to idle state
+     * so sinks and sources are properly released and connection attempt is marked as failed,
+     * this also trigger profile change to off */
+    transport = pa_bluetooth_transport_get(hsphfpd->discovery, endpoint_path);
+    if (transport && transport->state == PA_BLUETOOTH_TRANSPORT_STATE_IDLE) {
+        pa_bluetooth_transport_set_state(transport, PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED);
+        pa_bluetooth_transport_set_state(transport, PA_BLUETOOTH_TRANSPORT_STATE_IDLE);
+    }
+
+finish:
+    pa_xfree(endpoint_path);
+
+    dbus_error_free(&error);
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, hsphfpd->pending, p);
+    pa_dbus_pending_free(p);
+}
+
+static void hsphfpd_connect_audio(pa_bluetooth_hsphfpd *hsphfpd, const char *endpoint_path) {
+    /* TODO: support for choosing codec is not implemented yet */
+    const char *air_codec = "CVSD";
+    const char *agent_codec = "PCM_s16le_8kHz";
+    DBusMessage *m;
+
+    pa_assert_se(m = dbus_message_new_method_call(HSPHFPD_SERVICE, endpoint_path, HSPHFPD_ENDPOINT_INTERFACE, "ConnectAudio"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_STRING, &air_codec, DBUS_TYPE_STRING, &agent_codec, DBUS_TYPE_INVALID));
+    send_and_add_to_pending(hsphfpd, m, hsphfpd_transport_connect_audio_reply, pa_xstrdup(endpoint_path));
+}
+
+static int hsphfpd_transport_acquire(pa_bluetooth_transport *transport, size_t *imtu, size_t *omtu) {
+    struct hsphfpd_transport_data *transport_data = transport->userdata;
+
+    if (transport_data->sco_fd < 0) {
+        hsphfpd_connect_audio(transport_data->hsphfpd, transport->path);
+        return -EAGAIN;
+    }
+
+    if (imtu) *imtu = transport_data->mtu;
+    if (omtu) *omtu = transport_data->mtu;
+    return transport_data->sco_fd;
+}
+
+static void hsphfpd_transport_release(pa_bluetooth_transport *transport) {
+    struct hsphfpd_transport_data *transport_data = transport->userdata;
+
+    if (transport_data->sco_fd < 0) {
+        pa_log_info("Transport for endpoint %s already released", transport->path);
+        return;
+    }
+
+    shutdown(transport_data->sco_fd, SHUT_RDWR);
+    transport_data->sco_fd = -1;
+    /* file descriptor is closed by teardown_stream() */
+
+    pa_xfree(transport_data->transport_path);
+    transport_data->transport_path = NULL;
+
+    pa_xfree(transport_data->agent_codec);
+    transport_data->agent_codec = NULL;
+
+    pa_xfree(transport_data->air_codec);
+    transport_data->air_codec = NULL;
+
+    transport_data->mtu = 0;
+}
+
+static void hsphfpd_transport_destroy(pa_bluetooth_transport *transport) {
+    struct hsphfpd_transport_data *transport_data = transport->userdata;
+
+    pa_xfree(transport_data->transport_path);
+    pa_xfree(transport_data->agent_codec);
+    pa_xfree(transport_data->air_codec);
+    pa_xfree(transport_data);
+}
+
+static void hsphfpd_transport_set_tx_volume_gain(pa_bluetooth_transport *transport, uint16_t gain) {
+    struct hsphfpd_transport_data *transport_data = transport->userdata;
+
+    if (transport->tx_volume_gain == gain)
+        return;
+
+    set_tx_volume_gain_property(transport_data, gain);
+    transport->tx_volume_gain = gain;
+}
+
+static void hsphfpd_transport_set_rx_volume_gain(pa_bluetooth_transport *transport, uint16_t gain) {
+    struct hsphfpd_transport_data *transport_data = transport->userdata;
+
+    if (transport->rx_volume_gain == gain)
+        return;
+
+    set_rx_volume_gain_property(transport_data, gain);
+    transport->rx_volume_gain = gain;
+}
+
+static void parse_transport_properties_values(pa_bluetooth_hsphfpd *hsphfpd, const char *transport_path, DBusMessageIter *i, const char **endpoint_path, const char **air_codec, enum hsphfpd_volume_control *rx_volume_control, enum hsphfpd_volume_control *tx_volume_control, uint16_t *rx_volume_gain, uint16_t *tx_volume_gain, uint16_t *mtu) {
+    DBusMessageIter element_i;
+
+    pa_assert(i);
+
+    dbus_message_iter_recurse(i, &element_i);
+
+    while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
+        DBusMessageIter dict_i, variant_i;
+        const char *key;
+
+        dbus_message_iter_recurse(&element_i, &dict_i);
+
+        if (dbus_message_iter_get_arg_type(&dict_i) != DBUS_TYPE_STRING) {
+            pa_log_error("Received invalid property for transport %s", transport_path);
+            return;
+        }
+
+        dbus_message_iter_get_basic(&dict_i, &key);
+
+        if (!dbus_message_iter_next(&dict_i)) {
+            pa_log_error("Received invalid property for transport %s", transport_path);
+            return;
+        }
+
+        if (dbus_message_iter_get_arg_type(&dict_i) != DBUS_TYPE_VARIANT) {
+            pa_log_error("Received invalid property for transport %s", transport_path);
+            return;
+        }
+
+        dbus_message_iter_recurse(&dict_i, &variant_i);
+
+        switch (dbus_message_iter_get_arg_type(&variant_i)) {
+            case DBUS_TYPE_STRING:
+                if (pa_streq(key, "RxVolumeControl") || pa_streq(key, "TxVolumeControl")) {
+                    const char *value;
+                    enum hsphfpd_volume_control volume_control;
+
+                    dbus_message_iter_get_basic(&variant_i, &value);
+                    if (pa_streq(value, "none"))
+                        volume_control = HSPHFPD_VOLUME_CONTROL_NONE;
+                    else if (pa_streq(value, "local"))
+                        volume_control = HSPHFPD_VOLUME_CONTROL_LOCAL;
+                    else if (pa_streq(value, "remote"))
+                        volume_control = HSPHFPD_VOLUME_CONTROL_REMOTE;
+                    else
+                        volume_control = 0;
+
+                    if (!volume_control)
+                        pa_log_warn("Transport %s received invalid '%s' property value '%s', ignoring", transport_path, key, value);
+                    else if (pa_streq(key, "RxVolumeControl"))
+                        *rx_volume_control = volume_control;
+                    else if (pa_streq(key, "TxVolumeControl"))
+                        *tx_volume_control = volume_control;
+                } else if (pa_streq(key, "AirCodec"))
+                    dbus_message_iter_get_basic(&variant_i, air_codec);
+                break;
+
+            case DBUS_TYPE_UINT16:
+                if (pa_streq(key, "MTU"))
+                    dbus_message_iter_get_basic(&variant_i, mtu);
+                else if (pa_streq(key, "RxVolumeGain"))
+                    dbus_message_iter_get_basic(&variant_i, rx_volume_gain);
+                else if (pa_streq(key, "TxVolumeGain"))
+                    dbus_message_iter_get_basic(&variant_i, tx_volume_gain);
+                break;
+
+            case DBUS_TYPE_OBJECT_PATH:
+                if (pa_streq(key, "Endpoint"))
+                    dbus_message_iter_get_basic(&variant_i, endpoint_path);
+                break;
+        }
+
+        dbus_message_iter_next(&element_i);
+    }
+}
+
+static void parse_transport_properties(pa_bluetooth_transport *transport, DBusMessageIter *i) {
+    struct hsphfpd_transport_data *transport_data = transport->userdata;
+    bool rx_volume_gain_changed = false;
+    bool tx_volume_gain_changed = false;
+    bool rx_volume_control_changed = false;
+    bool tx_volume_control_changed = false;
+    bool rx_soft_volume_changed = false;
+    bool tx_soft_volume_changed = false;
+    const char *endpoint_path = NULL;
+    const char *air_codec = NULL;
+    enum hsphfpd_volume_control rx_volume_control = 0;
+    enum hsphfpd_volume_control tx_volume_control = 0;
+    uint16_t rx_volume_gain = -1;
+    uint16_t tx_volume_gain = -1;
+    uint16_t mtu = 0;
+
+    parse_transport_properties_values(transport_data->hsphfpd, transport_data->transport_path, i, &endpoint_path, &air_codec, &rx_volume_control, &tx_volume_control, &rx_volume_gain, &tx_volume_gain, &mtu);
+
+    if (endpoint_path)
+        pa_log_warn("Transport %s received a duplicate '%s' property, ignoring", transport_data->transport_path, "Endpoint");
+
+    if (air_codec)
+        pa_log_warn("Transport %s received a duplicate '%s' property, ignoring", transport_data->transport_path, "AirCodec");
+
+    if (mtu)
+        pa_log_warn("Transport %s received a duplicate '%s' property, ignoring", transport_data->transport_path, "MTU");
+
+    if (rx_volume_control) {
+        if (!!transport->rx_soft_volume != !!(rx_volume_control != HSPHFPD_VOLUME_CONTROL_REMOTE)) {
+            pa_log_info("Transport %s changed rx soft volume from %s to %s", transport_data->transport_path, pa_yes_no(transport->rx_soft_volume), pa_yes_no(rx_volume_control != HSPHFPD_VOLUME_CONTROL_REMOTE));
+            transport->rx_soft_volume = (rx_volume_control != HSPHFPD_VOLUME_CONTROL_REMOTE);
+            rx_soft_volume_changed = true;
+        }
+        if (transport_data->rx_volume_control != rx_volume_control) {
+            transport_data->rx_volume_control = rx_volume_control;
+            rx_volume_control_changed = true;
+        }
+    }
+
+    if (tx_volume_control) {
+        if (!!transport->tx_soft_volume != !!(rx_volume_control != HSPHFPD_VOLUME_CONTROL_REMOTE)) {
+            pa_log_info("Transport %s changed tx soft volume from %s to %s", transport_data->transport_path, pa_yes_no(transport->rx_soft_volume), pa_yes_no(rx_volume_control != HSPHFPD_VOLUME_CONTROL_REMOTE));
+            transport->tx_soft_volume = (rx_volume_control != HSPHFPD_VOLUME_CONTROL_REMOTE);
+            tx_soft_volume_changed = true;
+        }
+        if (transport_data->rx_volume_control != rx_volume_control) {
+            transport_data->rx_volume_control = rx_volume_control;
+            rx_volume_control_changed = true;
+        }
+    }
+
+    if (rx_volume_gain != (uint16_t)-1) {
+        if (transport->rx_volume_gain != rx_volume_gain) {
+            pa_log_info("Transport %s changed rx volume gain from %u to %u", transport_data->transport_path, (unsigned)transport->rx_volume_gain, (unsigned)rx_volume_gain);
+            transport->rx_volume_gain = rx_volume_gain;
+            rx_volume_gain_changed = true;
+        }
+    }
+
+    if (tx_volume_gain != (uint16_t)-1) {
+        if (transport->tx_volume_gain != tx_volume_gain) {
+            pa_log_info("Transport %s changed tx volume gain from %u to %u", transport_data->transport_path, (unsigned)transport->tx_volume_gain, (unsigned)tx_volume_gain);
+            transport->tx_volume_gain = tx_volume_gain;
+            tx_volume_gain_changed = true;
+        }
+    }
+
+    if (rx_volume_gain_changed || rx_soft_volume_changed)
+        pa_hook_fire(pa_bluetooth_discovery_hook(transport_data->hsphfpd->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_RX_VOLUME_GAIN_CHANGED), transport);
+
+    if (tx_volume_gain_changed || tx_soft_volume_changed)
+        pa_hook_fire(pa_bluetooth_discovery_hook(transport_data->hsphfpd->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_TX_VOLUME_GAIN_CHANGED), transport);
+
+    if (rx_volume_control_changed)
+        set_rx_volume_gain_property(transport_data, transport->rx_volume_gain);
+
+    if (tx_volume_control_changed)
+        set_tx_volume_gain_property(transport_data, transport->tx_volume_gain);
+}
+
+static void parse_endpoint_properties(pa_bluetooth_hsphfpd *hsphfpd, struct hsphfpd_endpoint *endpoint, DBusMessageIter *i) {
+    DBusMessageIter element_i;
+
+    pa_assert(i);
+
+    dbus_message_iter_recurse(i, &element_i);
+
+    while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
+        DBusMessageIter dict_i, variant_i;
+        const char *key;
+
+        dbus_message_iter_recurse(&element_i, &dict_i);
+
+        if (dbus_message_iter_get_arg_type(&dict_i) != DBUS_TYPE_STRING) {
+            pa_log_error("Received invalid property for endpoint %s", endpoint->path);
+            return;
+        }
+
+        dbus_message_iter_get_basic(&dict_i, &key);
+
+        if (!dbus_message_iter_next(&dict_i)) {
+            pa_log_error("Received invalid property for endpoint %s", endpoint->path);
+            return;
+        }
+
+        if (dbus_message_iter_get_arg_type(&dict_i) != DBUS_TYPE_VARIANT) {
+            pa_log_error("Received invalid property for endpoint %s", endpoint->path);
+            return;
+        }
+
+        dbus_message_iter_recurse(&dict_i, &variant_i);
+
+        switch (dbus_message_iter_get_arg_type(&variant_i)) {
+            case DBUS_TYPE_STRING: {
+                const char *value;
+                dbus_message_iter_get_basic(&variant_i, &value);
+                if (pa_streq(key, "LocalAddress")) {
+                    if (endpoint->local_address)
+                        pa_log_warn("Endpoint %s received a duplicate '%s' property, ignoring", endpoint->path, key);
+                    else
+                        endpoint->local_address = pa_xstrdup(value);
+                } else if (pa_streq(key, "RemoteAddress")) {
+                    if (endpoint->remote_address)
+                        pa_log_warn("Endpoint %s received a duplicate '%s' property, ignoring", endpoint->path, key);
+                    else
+                        endpoint->remote_address = pa_xstrdup(value);
+                } else if (pa_streq(key, "Profile")) {
+                    if (endpoint->profile)
+                        pa_log_warn("Endpoint %s received a duplicate '%s' property, ignoring", endpoint->path, key);
+                    else if (pa_streq(value, "headset"))
+                        endpoint->profile = HSPHFPD_PROFILE_HEADSET;
+                    else if (pa_streq(value, "handsfree"))
+                        endpoint->profile = HSPHFPD_PROFILE_HANDSFREE;
+                    else
+                        pa_log_warn("Endpoint %s received invalid '%s' property value '%s', ignoring", endpoint->path, key, value);
+                } else if (pa_streq(key, "Role")) {
+                    if (endpoint->role)
+                        pa_log_warn("Endpoint %s received a duplicate '%s' property, ignoring", endpoint->path, key);
+                    else if (pa_streq(value, "client"))
+                        endpoint->role = HSPHFPD_ROLE_CLIENT;
+                    else if (pa_streq(value, "gateway"))
+                        endpoint->role = HSPHFPD_ROLE_GATEWAY;
+                    else
+                        pa_log_warn("Endpoint %s received invalid '%s' property value '%s', ignoring", endpoint->path, key, value);
+                }
+                break;
+            }
+
+            case DBUS_TYPE_BOOLEAN: {
+                bool value;
+                dbus_message_iter_get_basic(&variant_i, &value);
+                if (pa_streq(key, "Connected") && endpoint->connected != value) {
+                    endpoint->connected = value;
+                    if (!endpoint->connected) {
+                        pa_bluetooth_transport *transport = pa_bluetooth_transport_get(hsphfpd->discovery, endpoint->path);
+                        if (transport)
+                            pa_bluetooth_transport_free(transport);
+                    }
+                }
+                break;
+            }
+        }
+
+        dbus_message_iter_next(&element_i);
+    }
+
+    if (!endpoint->valid && endpoint->local_address && endpoint->remote_address && endpoint->profile && endpoint->role)
+        endpoint->valid = true;
+
+    if (endpoint->valid && endpoint->connected && !pa_bluetooth_transport_get(hsphfpd->discovery, endpoint->path)) {
+        struct hsphfpd_transport_data *transport_data;
+        pa_bluetooth_transport *transport;
+        pa_bluetooth_profile_t profile;
+        pa_bluetooth_device *device = pa_bluetooth_discovery_get_device_by_address(hsphfpd->discovery, endpoint->remote_address, endpoint->local_address);
+        if (!device) {
+            pa_log_error("Device does not exist for endpoint %s (remote addresses %s, local address %s)", endpoint->path, endpoint->remote_address, endpoint->local_address);
+        } else {
+            pa_log_debug("Creating a new transport for endpoint %s", endpoint->path);
+
+            if (endpoint->profile == HSPHFPD_PROFILE_HEADSET) {
+                if (endpoint->role == HSPHFPD_ROLE_CLIENT)
+                    profile = PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT;
+                else
+                    profile = PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY;
+            } else {
+                if (endpoint->role == HSPHFPD_ROLE_CLIENT)
+                    profile = PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT;
+                else
+                    profile = PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY;
+            }
+
+            transport_data = pa_xnew0(struct hsphfpd_transport_data, 1);
+            transport_data->hsphfpd = hsphfpd;
+            transport_data->sco_fd = -1;
+
+            /* By default we do not know if remote device supports hw volume control
+             * So use local softvol filter until remote device announce volume control support */
+            transport = pa_bluetooth_transport_new(device, hsphfpd->hsphfpd_service_id, endpoint->path, profile, NULL, 0);
+            transport->rx_soft_volume = true;
+            transport->tx_soft_volume = true;
+            transport->max_rx_volume_gain = 15;
+            transport->max_tx_volume_gain = 15;
+            transport->acquire = hsphfpd_transport_acquire;
+            transport->release = hsphfpd_transport_release;
+            transport->destroy = hsphfpd_transport_destroy;
+            transport->set_rx_volume_gain = hsphfpd_transport_set_rx_volume_gain;
+            transport->set_tx_volume_gain = hsphfpd_transport_set_tx_volume_gain;
+            transport->userdata = transport_data;
+
+            pa_bluetooth_transport_put(transport);
+        }
+    }
+}
+
+static void parse_interfaces(pa_bluetooth_hsphfpd *hsphfpd, DBusMessageIter *dict_i) {
+    DBusMessageIter element_i;
+    const char *path;
+
+    pa_assert(dbus_message_iter_get_arg_type(dict_i) == DBUS_TYPE_OBJECT_PATH);
+    dbus_message_iter_get_basic(dict_i, &path);
+
+    pa_assert_se(dbus_message_iter_next(dict_i));
+    pa_assert(dbus_message_iter_get_arg_type(dict_i) == DBUS_TYPE_ARRAY);
+
+    dbus_message_iter_recurse(dict_i, &element_i);
+
+    while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
+        DBusMessageIter iface_i;
+        const char *interface;
+
+        dbus_message_iter_recurse(&element_i, &iface_i);
+
+        pa_assert(dbus_message_iter_get_arg_type(&iface_i) == DBUS_TYPE_STRING);
+        dbus_message_iter_get_basic(&iface_i, &interface);
+
+        pa_assert_se(dbus_message_iter_next(&iface_i));
+        pa_assert(dbus_message_iter_get_arg_type(&iface_i) == DBUS_TYPE_ARRAY);
+
+        if (pa_streq(interface, HSPHFPD_ENDPOINT_INTERFACE)) {
+            struct hsphfpd_endpoint *endpoint;
+
+            endpoint = pa_hashmap_get(hsphfpd->endpoints, path);
+            if (!endpoint) {
+                endpoint = pa_xnew0(struct hsphfpd_endpoint, 1);
+                endpoint->path = pa_xstrdup(path);
+                pa_hashmap_put(hsphfpd->endpoints, endpoint->path, endpoint);
+                pa_log_debug("Found endpoint %s", path);
+            }
+
+            parse_endpoint_properties(hsphfpd, endpoint, &iface_i);
+        } else
+            pa_log_debug("Unknown interface %s found, skipping", interface);
+
+        dbus_message_iter_next(&element_i);
+    }
+}
+
+static void hsphfpd_get_endpoints_reply(DBusPendingCall *pending, void *userdata) {
+    pa_dbus_pending *p;
+    pa_bluetooth_hsphfpd *hsphfpd;
+    DBusMessage *r;
+    DBusMessageIter arg_i, element_i;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(hsphfpd = p->context_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_error("GetManagedObjects() failed: %s: %s", dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
+        goto finish;
+    }
+
+    if (!pa_safe_streq(dbus_message_get_sender(r), hsphfpd->hsphfpd_service_id)) {
+        pa_log_error("Reply for GetManagedObjects() from invalid sender");
+        goto finish;
+    }
+
+    if (!dbus_message_iter_init(r, &arg_i) || !pa_streq(dbus_message_get_signature(r), "a{oa{sa{sv}}}")) {
+        pa_log_error("Invalid reply signature for GetManagedObjects()");
+        goto finish;
+    }
+
+    dbus_message_iter_recurse(&arg_i, &element_i);
+    while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
+        DBusMessageIter dict_i;
+
+        dbus_message_iter_recurse(&element_i, &dict_i);
+
+        parse_interfaces(hsphfpd, &dict_i);
+
+        dbus_message_iter_next(&element_i);
+    }
+
+    hsphfpd->endpoints_listed = true;
+
+finish:
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, hsphfpd->pending, p);
+    pa_dbus_pending_free(p);
+}
+
+static void hsphfpd_get_endpoints(pa_bluetooth_hsphfpd *hsphfpd) {
+    DBusMessage *m;
+
+    pa_assert(hsphfpd);
+
+    pa_assert_se(m = dbus_message_new_method_call(HSPHFPD_SERVICE, "/", DBUS_INTERFACE_OBJECTMANAGER, "GetManagedObjects"));
+    send_and_add_to_pending(hsphfpd, m, hsphfpd_get_endpoints_reply, NULL);
+}
+
+static void hsphfpd_register_application_reply(DBusPendingCall *pending, void *userdata) {
+    DBusMessage *r;
+    pa_dbus_pending *p;
+    pa_bluetooth_hsphfpd *hsphfpd;
+
+    pa_assert(pending);
+    pa_assert_se(p = userdata);
+    pa_assert_se(hsphfpd = p->context_data);
+    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
+
+    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
+        pa_log_warn(HSPHFPD_APPLICATION_MANAGER_INTERFACE ".RegisterApplication() failed: %s: %s",
+                    dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
+        if (dbus_message_is_error(r, DBUS_ERROR_SERVICE_UNKNOWN)) {
+            pa_log_warn("hsphfpd daemon is not running!");
+            pa_log_warn("It is needed for HSP and HFP profile support");
+            if (!hsphfpd->legacy_hsp)
+                hsphfpd->legacy_hsp = pa_bluetooth_legacy_hsp_register(hsphfpd->core, hsphfpd->discovery);
+        }
+        goto finish;
+    }
+
+    pa_log_info("hsphfpd is now running and pulseaudio was registered");
+
+    hsphfpd->hsphfpd_service_id = pa_xstrdup(dbus_message_get_sender(r));
+
+    hsphfpd_get_endpoints(hsphfpd);
+
+finish:
+    dbus_message_unref(r);
+
+    PA_LLIST_REMOVE(pa_dbus_pending, hsphfpd->pending, p);
+    pa_dbus_pending_free(p);
+}
+
+static void hsphfpd_register_application(pa_bluetooth_hsphfpd *hsphfpd) {
+    DBusMessage *m;
+    const char *path = APPLICATION_OBJECT_MANAGER_PATH;
+
+    pa_assert(hsphfpd);
+
+    pa_assert_se(m = dbus_message_new_method_call(HSPHFPD_SERVICE, "/", HSPHFPD_APPLICATION_MANAGER_INTERFACE, "RegisterApplication"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_INVALID));
+
+    send_and_add_to_pending(hsphfpd, m, hsphfpd_register_application_reply, NULL);
+}
+
+static void hsphfpd_unregister_application(pa_bluetooth_hsphfpd *hsphfpd) {
+    DBusMessage *m;
+    const char *path = APPLICATION_OBJECT_MANAGER_PATH;
+
+    pa_assert(hsphfpd);
+    pa_assert(hsphfpd->connection);
+
+    pa_assert_se(m = dbus_message_new_method_call(HSPHFPD_SERVICE, "/", HSPHFPD_APPLICATION_MANAGER_INTERFACE, "UnregisterApplication"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_INVALID));
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(hsphfpd->connection), m, NULL));
+
+    pa_xfree(hsphfpd->hsphfpd_service_id);
+    hsphfpd->hsphfpd_service_id = NULL;
+    hsphfpd->endpoints_listed = false;
+    pa_hashmap_remove_all(hsphfpd->endpoints);
+}
+
+static DBusMessage *hsphfpd_new_connection(pa_bluetooth_hsphfpd *hsphfpd, DBusMessage *m) {
+    const char *agent_path;
+    const char *transport_path;
+    const char *endpoint_path = NULL;
+    const char *air_codec = NULL;
+    enum hsphfpd_volume_control rx_volume_control = 0;
+    enum hsphfpd_volume_control tx_volume_control = 0;
+    uint16_t rx_volume_gain = -1;
+    uint16_t tx_volume_gain = -1;
+    uint16_t mtu = 0;
+    const char *sender;
+    pa_bluetooth_transport *transport;
+    struct hsphfpd_endpoint *endpoint;
+    struct hsphfpd_transport_data *transport_data;
+    int sco_fd;
+    DBusMessage *r;
+    DBusMessageIter arg_i;
+
+    if (!dbus_message_iter_init(m, &arg_i) || !pa_streq(dbus_message_get_signature(m), "oha{sv}")) {
+        pa_log_error("Invalid signature for method NewConnection()");
+        return NULL;
+    }
+
+    agent_path = dbus_message_get_path(m);
+    if (!pa_streq(agent_path, AUDIO_AGENT_ENDPOINT_PCM_S16LE_8KHZ)) {
+        pa_log_error("Invalid handler for method NewConnection()");
+        return NULL;
+    }
+
+    pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_OBJECT_PATH);
+    dbus_message_iter_get_basic(&arg_i, &transport_path);
+
+    pa_assert_se(dbus_message_iter_next(&arg_i));
+
+    pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_UNIX_FD);
+    dbus_message_iter_get_basic(&arg_i, &sco_fd);
+
+    pa_log_debug("NewConnection path=%s, sco_fd=%d", transport_path, sco_fd);
+
+    sender = dbus_message_get_sender(m);
+    if (!pa_safe_streq(sender, hsphfpd->hsphfpd_service_id)) {
+        close(sco_fd);
+        pa_log_error("Sender '%s' is not authorized", sender);
+        pa_assert_se(r = dbus_message_new_error_printf(m, "org.hsphfpd.Error.Rejected", "Sender '%s' is not authorized", sender));
+        return r;
+    }
+
+    pa_assert_se(dbus_message_iter_next(&arg_i));
+    pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_ARRAY);
+    parse_transport_properties_values(hsphfpd, transport_path, &arg_i, &endpoint_path, &air_codec, &rx_volume_control, &tx_volume_control, &rx_volume_gain, &tx_volume_gain, &mtu);
+
+    if (!endpoint_path) {
+        close(sco_fd);
+        pa_log_error("Endpoint property was not specified");
+        pa_assert_se(r = dbus_message_new_error(m, "org.hsphfpd.Error.Rejected", "Endpoint property was not specified"));
+        return r;
+    }
+
+    if (!air_codec) {
+        close(sco_fd);
+        pa_log_error("AirCodec property was not specified");
+        pa_assert_se(r = dbus_message_new_error(m, "org.hsphfpd.Error.Rejected", "AirCodec property was not specified"));
+        return r;
+    }
+
+    if (!rx_volume_control) {
+        close(sco_fd);
+        pa_log_error("RxVolumeControl property was not specified");
+        pa_assert_se(r = dbus_message_new_error(m, "org.hsphfpd.Error.Rejected", "RxVolumeControl property was not specified"));
+        return r;
+    }
+
+    if (!tx_volume_control) {
+        close(sco_fd);
+        pa_log_error("TxVolumeControl property was not specified");
+        pa_assert_se(r = dbus_message_new_error(m, "org.hsphfpd.Error.Rejected", "TxVolumeControl property was not specified"));
+        return r;
+    }
+
+    if (rx_volume_control != HSPHFPD_VOLUME_CONTROL_NONE) {
+        if (rx_volume_gain == (uint16_t)-1) {
+            close(sco_fd);
+            pa_log_error("RxVolumeGain property was not specified, but VolumeControl is not none");
+            pa_assert_se(r = dbus_message_new_error(m, "org.hsphfpd.Error.Rejected", "RxVolumeGain property was not specified, but VolumeControl is not none"));
+            return r;
+        }
+    } else {
+        rx_volume_gain = 15; /* No volume control, so set maximal value */
+    }
+
+    if (tx_volume_control != HSPHFPD_VOLUME_CONTROL_NONE) {
+        if (tx_volume_gain == (uint16_t)-1) {
+            close(sco_fd);
+            pa_log_error("TxVolumeGain property was not specified, but VolumeControl is not none");
+            pa_assert_se(r = dbus_message_new_error(m, "org.hsphfpd.Error.Rejected", "TxVolumeGain property was not specified, but VolumeControl is not none"));
+            return r;
+        }
+    } else {
+        tx_volume_gain = 15; /* No volume control, so set maximal value */
+    }
+
+    if (!mtu) {
+        close(sco_fd);
+        pa_log_error("MTU property was not specified");
+        pa_assert_se(r = dbus_message_new_error(m, "org.hsphfpd.Error.Rejected", "MTU property was not specified"));
+        return r;
+    }
+
+    endpoint = pa_hashmap_get(hsphfpd->endpoints, endpoint_path);
+    if (!endpoint) {
+        close(sco_fd);
+        pa_log_error("Endpoint %s does not exist", endpoint_path);
+        pa_assert_se(r = dbus_message_new_error_printf(m, "org.hsphfpd.Error.Rejected", "Endpoint %s does not exist", endpoint_path));
+        return r;
+    }
+
+    if (!endpoint->valid) {
+        close(sco_fd);
+        pa_log_error("Endpoint %s is not valid", endpoint_path);
+        pa_assert_se(r = dbus_message_new_error_printf(m, "org.hsphfpd.Error.Rejected", "Endpoint %s is not valid", endpoint_path));
+        return r;
+    }
+
+    transport = pa_bluetooth_transport_get(hsphfpd->discovery, endpoint_path);
+    if (!transport) {
+        close(sco_fd);
+        pa_log_error("Endpoint %s is not connected", endpoint_path);
+        pa_assert_se(r = dbus_message_new_error_printf(m, "org.hsphfpd.Error.Rejected", "Endpoint %s is not connected", endpoint_path));
+        return r;
+    }
+
+    transport_data = transport->userdata;
+    if (transport_data->sco_fd >= 0) {
+        close(sco_fd);
+        pa_log_error("Endpoint %s has already active transport", endpoint_path);
+        pa_assert_se(r = dbus_message_new_error_printf(m, "org.hsphfpd.Error.Rejected", "Endpoint %s has already active transport", endpoint_path));
+        return r;
+    }
+
+    transport->rx_soft_volume = (rx_volume_control != HSPHFPD_VOLUME_CONTROL_REMOTE);
+    transport->tx_soft_volume = (tx_volume_control != HSPHFPD_VOLUME_CONTROL_REMOTE);
+    transport->rx_volume_gain = rx_volume_gain;
+    transport->tx_volume_gain = tx_volume_gain;
+
+    pa_hook_fire(pa_bluetooth_discovery_hook(hsphfpd->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_RX_VOLUME_GAIN_CHANGED), transport);
+    pa_hook_fire(pa_bluetooth_discovery_hook(hsphfpd->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_TX_VOLUME_GAIN_CHANGED), transport);
+
+    transport_data->transport_path = pa_xstrdup(transport_path);
+    transport_data->agent_codec = pa_xstrdup("PCM_s16le_8kHz");
+    transport_data->air_codec = pa_xstrdup(air_codec);
+    transport_data->rx_volume_control = rx_volume_control;
+    transport_data->tx_volume_control = tx_volume_control;
+    transport_data->mtu = mtu;
+    transport_data->sco_fd = sco_fd;
+
+    pa_bluetooth_transport_set_state(transport, PA_BLUETOOTH_TRANSPORT_STATE_PLAYING);
+
+    pa_log_debug("Transport %s with agent codec %s and air codec %s is active for profile %s on endpoint %s", transport_data->transport_path, transport_data->agent_codec, transport_data->air_codec, pa_bluetooth_profile_to_string(transport->profile), endpoint_path);
+
+    pa_assert_se(r = dbus_message_new_method_return(m));
+    return r;
+}
+
+static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *data) {
+    const char *sender;
+    DBusError err;
+    pa_bluetooth_hsphfpd *hsphfpd = data;
+
+    pa_assert(bus);
+    pa_assert(m);
+    pa_assert(hsphfpd);
+
+    dbus_error_init(&err);
+
+    sender = dbus_message_get_sender(m);
+
+    if (pa_streq(sender, DBUS_SERVICE_DBUS)) {
+
+        if (dbus_message_is_signal(m, DBUS_SERVICE_DBUS, "NameOwnerChanged")) {
+            const char *name, *old_owner, *new_owner;
+
+            if (!dbus_message_get_args(m, &err,
+                                       DBUS_TYPE_STRING, &name,
+                                       DBUS_TYPE_STRING, &old_owner,
+                                       DBUS_TYPE_STRING, &new_owner,
+                                       DBUS_TYPE_INVALID)
+                  || dbus_error_is_set(&err)) {
+                pa_log_error("Failed to parse NameOwnerChanged: %s", err.message);
+                goto finish;
+            }
+
+            if (pa_streq(name, HSPHFPD_SERVICE)) {
+                if (old_owner && *old_owner) {
+                    pa_log_debug("hsphfpd disappeared");
+                    pa_xfree(hsphfpd->hsphfpd_service_id);
+                    hsphfpd->hsphfpd_service_id = NULL;
+                    hsphfpd->endpoints_listed = false;
+                    pa_hashmap_remove_all(hsphfpd->endpoints);
+                    if (!hsphfpd->legacy_hsp)
+                        hsphfpd->legacy_hsp = pa_bluetooth_legacy_hsp_register(hsphfpd->core, hsphfpd->discovery);
+                }
+
+                if (new_owner && *new_owner) {
+                    pa_log_debug("hsphfpd appeared");
+                    if (hsphfpd->legacy_hsp) {
+                        pa_bluetooth_legacy_hsp_unregister(hsphfpd->legacy_hsp);
+                        hsphfpd->legacy_hsp = NULL;
+                    }
+                    hsphfpd_register_application(hsphfpd);
+                }
+            }
+        }
+
+    } else if (pa_safe_streq(sender, hsphfpd->hsphfpd_service_id)) {
+
+        DBusMessageIter arg_i;
+
+        if (dbus_message_is_signal(m, DBUS_INTERFACE_OBJECTMANAGER, "InterfacesAdded")) {
+            if (!hsphfpd->endpoints_listed)
+                goto finish;
+
+            if (!dbus_message_iter_init(m, &arg_i) || !pa_streq(dbus_message_get_signature(m), "oa{sa{sv}}")) {
+                pa_log_error("Invalid signature found in InterfacesAdded");
+                goto finish;
+            }
+
+            parse_interfaces(hsphfpd, &arg_i);
+        } else if (dbus_message_is_signal(m, DBUS_INTERFACE_OBJECTMANAGER, "InterfacesRemoved")) {
+            const char *path;
+            DBusMessageIter element_i;
+
+            if (!hsphfpd->endpoints_listed)
+                goto finish;
+
+            if (!dbus_message_iter_init(m, &arg_i) || !pa_streq(dbus_message_get_signature(m), "oas")) {
+                pa_log_error("Invalid signature found in InterfacesRemoved");
+                goto finish;
+            }
+
+            dbus_message_iter_get_basic(&arg_i, &path);
+
+            pa_assert_se(dbus_message_iter_next(&arg_i));
+            pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_ARRAY);
+
+            dbus_message_iter_recurse(&arg_i, &element_i);
+
+            while (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_STRING) {
+                const char *iface;
+
+                dbus_message_iter_get_basic(&element_i, &iface);
+
+                if (pa_streq(iface, HSPHFPD_ENDPOINT_INTERFACE)) {
+                    pa_bluetooth_transport *transport = pa_bluetooth_transport_get(hsphfpd->discovery, path);
+                    if (transport)
+                        pa_bluetooth_transport_free(transport);
+                    pa_log_debug("Remove endpoint %s", path);
+                    pa_hashmap_remove(hsphfpd->endpoints, path);
+                }
+
+                dbus_message_iter_next(&element_i);
+            }
+        } else if (dbus_message_is_signal(m, DBUS_INTERFACE_PROPERTIES, "PropertiesChanged")) {
+            const char *iface;
+            const char *path;
+
+            if (!hsphfpd->endpoints_listed)
+                goto finish;
+
+            if (!dbus_message_iter_init(m, &arg_i) || !pa_streq(dbus_message_get_signature(m), "sa{sv}as")) {
+                pa_log_error("Invalid signature found in PropertiesChanged");
+                goto finish;
+            }
+
+            dbus_message_iter_get_basic(&arg_i, &iface);
+
+            pa_assert_se(dbus_message_iter_next(&arg_i));
+            pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_ARRAY);
+
+            path = dbus_message_get_path(m);
+
+            if (pa_streq(iface, HSPHFPD_ENDPOINT_INTERFACE)) {
+                struct hsphfpd_endpoint *endpoint = pa_hashmap_get(hsphfpd->endpoints, path);
+                if (!endpoint) {
+                    pa_log_warn("Properties changed on unknown endpoint %s", path);
+                    goto finish;
+                }
+                pa_log_debug("Properties changed on endpoint %s", path);
+                parse_endpoint_properties(hsphfpd, endpoint, &arg_i);
+            } else if (pa_streq(iface, HSPHFPD_AUDIO_TRANSPORT_INTERFACE)) {
+                pa_hashmap *transports = pa_bluetooth_transport_get_all(hsphfpd->discovery);
+                pa_bluetooth_transport *transport;
+                struct hsphfpd_transport_data *transport_data;
+                void *state;
+
+                /* Find pa_bluetooth_transport which belongs to hsphfpd transport path
+                 * pa_hashmap_get() search transports by hsphfpd endpoint path and
+                 * not by hsphfpd transport path, so do search routine manually */
+                PA_HASHMAP_FOREACH(transport, transports, state) {
+                    if (!transport->owner || !pa_safe_streq(transport->owner, hsphfpd->hsphfpd_service_id))
+                        continue;
+                    transport_data = transport->userdata;
+                    if (transport_data->sco_fd <= 0 || !pa_safe_streq(transport_data->transport_path, path))
+                        continue;
+                    break;
+                }
+
+                if (!transport) {
+                    pa_log_warn("Properties changed on unknown transport %s", path);
+                    goto finish;
+                }
+
+                pa_log_debug("Properties changed on transport %s", path);
+                parse_transport_properties(transport, &arg_i);
+            }
+        }
+
+    }
+
+finish:
+    dbus_error_free(&err);
+    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static void append_audio_agent_object(DBusMessageIter *iter, const char *endpoint, const char *agent_codec) {
+    const char *interface_name = HSPHFPD_AUDIO_AGENT_INTERFACE;
+    DBusMessageIter object, array, entry, dict;
+
+    dbus_message_iter_open_container(iter, DBUS_TYPE_DICT_ENTRY, NULL, &object);
+    pa_assert_se(dbus_message_iter_append_basic(&object, DBUS_TYPE_OBJECT_PATH, &endpoint));
+
+    dbus_message_iter_open_container(&object, DBUS_TYPE_ARRAY, "{sa{sv}}", &array);
+
+    dbus_message_iter_open_container(&array, DBUS_TYPE_DICT_ENTRY, NULL, &entry);
+    pa_assert_se(dbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &interface_name));
+
+    dbus_message_iter_open_container(&entry, DBUS_TYPE_ARRAY, "{sv}", &dict);
+
+    pa_dbus_append_basic_variant_dict_entry(&dict, "AgentCodec", DBUS_TYPE_STRING, &agent_codec);
+
+    dbus_message_iter_close_container(&entry, &dict);
+    dbus_message_iter_close_container(&array, &entry);
+    dbus_message_iter_close_container(&object, &array);
+    dbus_message_iter_close_container(iter, &object);
+}
+
+static DBusHandlerResult application_object_manager_handler(DBusConnection *c, DBusMessage *m, void *userdata) {
+    struct pa_bluetooth_hsphfpd *hsphfpd = userdata;
+    DBusMessage *r;
+    const char *path, *interface, *member;
+
+    pa_assert(hsphfpd);
+
+    path = dbus_message_get_path(m);
+    interface = dbus_message_get_interface(m);
+    member = dbus_message_get_member(m);
+
+    pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
+
+    if (dbus_message_is_method_call(m, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
+        const char *xml = APPLICATION_OBJECT_MANAGER_INTROSPECT_XML;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+        pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_STRING, &xml, DBUS_TYPE_INVALID));
+    } else if (dbus_message_is_method_call(m, DBUS_INTERFACE_OBJECTMANAGER, "GetManagedObjects")) {
+        DBusMessageIter iter, array;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+
+        dbus_message_iter_init_append(r, &iter);
+        dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "{oa{sa{sv}}}", &array);
+
+        append_audio_agent_object(&array, AUDIO_AGENT_ENDPOINT_PCM_S16LE_8KHZ, "PCM_s16le_8kHz");
+
+        dbus_message_iter_close_container(&iter, &array);
+    } else
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(hsphfpd->connection), r, NULL));
+    dbus_message_unref(r);
+
+    return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+static DBusHandlerResult audio_agent_endpoint_pcm_s16le_8khz_handler(DBusConnection *c, DBusMessage *m, void *userdata) {
+    pa_bluetooth_hsphfpd *hsphfpd = userdata;
+    DBusMessage *r = NULL;
+
+    pa_assert(hsphfpd);
+
+    pa_log_debug("dbus: path=%s, interface=%s, member=%s", dbus_message_get_path(m), dbus_message_get_interface(m), dbus_message_get_member(m));
+
+    if (!pa_streq(dbus_message_get_path(m), AUDIO_AGENT_ENDPOINT_PCM_S16LE_8KHZ))
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    if (dbus_message_is_method_call(m, DBUS_INTERFACE_INTROSPECTABLE, "Introspect")) {
+        const char *xml = AUDIO_AGENT_ENDPOINT_INTROSPECT_XML;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+        pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_STRING, &xml, DBUS_TYPE_INVALID));
+    } else if (dbus_message_is_method_call(m, DBUS_INTERFACE_PROPERTIES, "Get")) {
+        const char *interface;
+        const char *property;
+        DBusError error;
+
+        if (!pa_streq(dbus_message_get_signature(m), "ss")) {
+            pa_log_error("Invalid signature for method Get()");
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }
+
+        dbus_error_init(&error);
+        if (!dbus_message_get_args(m, &error, DBUS_TYPE_STRING, &interface, DBUS_TYPE_STRING, &property, DBUS_TYPE_INVALID) || dbus_error_is_set(&error)) {
+            dbus_error_free(&error);
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }
+        dbus_error_free(&error);
+
+        if (!pa_streq(interface, HSPHFPD_AUDIO_AGENT_INTERFACE))
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+        if (pa_streq(property, "AgentCodec")) {
+            const char *agent_codec = "PCM_s16le_8kHz";
+            pa_assert_se(r = dbus_message_new_method_return(m));
+            pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_STRING, &agent_codec, DBUS_TYPE_INVALID));
+        } else
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    } else if (dbus_message_is_method_call(m, DBUS_INTERFACE_PROPERTIES, "GetAll")) {
+        DBusError error;
+        DBusMessageIter iter, dict;
+        const char *interface;
+        const char *agent_codec = "PCM_s16le_8kHz";
+
+        if (!pa_streq(dbus_message_get_signature(m), "s")) {
+            pa_log_error("Invalid signature for method GetAll()");
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }
+
+        dbus_error_init(&error);
+        if (!dbus_message_get_args(m, &error, DBUS_TYPE_STRING, &interface, DBUS_TYPE_INVALID) || dbus_error_is_set(&error)) {
+            dbus_error_free(&error);
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }
+        dbus_error_free(&error);
+
+        if (!pa_streq(interface, HSPHFPD_AUDIO_AGENT_INTERFACE))
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+        pa_assert_se(r = dbus_message_new_method_return(m));
+        dbus_message_iter_init_append(r, &iter);
+        pa_assert_se(dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "{sv}", &dict));
+        pa_dbus_append_basic_variant_dict_entry(&dict, "AgentCodec", DBUS_TYPE_STRING, &agent_codec);
+        pa_assert_se(dbus_message_iter_close_container(&iter, &dict));
+    } else if (dbus_message_is_method_call(m, HSPHFPD_AUDIO_AGENT_INTERFACE, "NewConnection")) {
+        r = hsphfpd_new_connection(hsphfpd, m);
+        if (!r)
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    } else
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    pa_assert(r);
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(hsphfpd->connection), r, NULL));
+    dbus_message_unref(r);
+    return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+pa_bluetooth_hsphfpd *pa_bluetooth_hsphfpd_new(pa_core *core, pa_bluetooth_discovery *discovery) {
+    pa_bluetooth_hsphfpd *hsphfpd;
+    DBusError err;
+    static const DBusObjectPathVTable vtable_application_object_manager = {
+        .message_function = application_object_manager_handler,
+    };
+    static const DBusObjectPathVTable vtable_audio_agent_endpoint_pcm_s16le_8khz = {
+        .message_function = audio_agent_endpoint_pcm_s16le_8khz_handler,
+    };
+
+    pa_assert(core);
+    pa_assert(discovery);
+
+    hsphfpd = pa_xnew0(pa_bluetooth_hsphfpd, 1);
+    hsphfpd->core = core;
+    hsphfpd->discovery = discovery;
+    hsphfpd->endpoints_listed = false;
+    hsphfpd->endpoints = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL, (pa_free_cb_t) hsphfpd_endpoint_free);
+
+    dbus_error_init(&err);
+
+    if (!(hsphfpd->connection = pa_dbus_bus_get(core, DBUS_BUS_SYSTEM, &err))) {
+        pa_log_error("Failed to get D-Bus connection: %s", err.message);
+        dbus_error_free(&err);
+        pa_xfree(hsphfpd);
+        return NULL;
+    }
+
+    if (!dbus_connection_add_filter(pa_dbus_connection_get(hsphfpd->connection), filter_cb, hsphfpd, NULL)) {
+        pa_log_error("Failed to add filter function");
+        pa_dbus_connection_unref(hsphfpd->connection);
+        pa_xfree(hsphfpd);
+        return NULL;
+    }
+
+    if (pa_dbus_add_matches(pa_dbus_connection_get(hsphfpd->connection), &err,
+            "type='signal',sender='" DBUS_SERVICE_DBUS "',interface='" DBUS_SERVICE_DBUS "',member='NameOwnerChanged',arg0='" HSPHFPD_SERVICE "'",
+            "type='signal',interface='" DBUS_INTERFACE_OBJECTMANAGER "',member='InterfacesAdded'",
+            "type='signal',interface='" DBUS_INTERFACE_OBJECTMANAGER "',member='InterfacesRemoved'",
+            "type='signal',interface='" DBUS_INTERFACE_PROPERTIES "',member='PropertiesChanged',arg0='" HSPHFPD_ENDPOINT_INTERFACE "'",
+            "type='signal',interface='" DBUS_INTERFACE_PROPERTIES "',member='PropertiesChanged',arg0='" HSPHFPD_AUDIO_TRANSPORT_INTERFACE "'",
+            NULL) < 0) {
+        pa_log_error("Failed to add hsphfpd D-Bus matches: %s", err.message);
+        dbus_connection_remove_filter(pa_dbus_connection_get(hsphfpd->connection), filter_cb, hsphfpd);
+        pa_dbus_connection_unref(hsphfpd->connection);
+        pa_xfree(hsphfpd);
+        return NULL;
+    }
+
+    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(hsphfpd->connection), APPLICATION_OBJECT_MANAGER_PATH, &vtable_application_object_manager, hsphfpd));
+    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(hsphfpd->connection), AUDIO_AGENT_ENDPOINT_PCM_S16LE_8KHZ, &vtable_audio_agent_endpoint_pcm_s16le_8khz, hsphfpd));
+
+    hsphfpd_register_application(hsphfpd);
+
+    return hsphfpd;
+}
+
+void pa_bluetooth_hsphfpd_free(pa_bluetooth_hsphfpd *hsphfpd) {
+    pa_assert(hsphfpd);
+
+    pa_dbus_free_pending_list(&hsphfpd->pending);
+
+    hsphfpd_unregister_application(hsphfpd);
+
+    dbus_connection_unregister_object_path(pa_dbus_connection_get(hsphfpd->connection), APPLICATION_OBJECT_MANAGER_PATH);
+    dbus_connection_unregister_object_path(pa_dbus_connection_get(hsphfpd->connection), AUDIO_AGENT_ENDPOINT_PCM_S16LE_8KHZ);
+
+    pa_dbus_remove_matches(pa_dbus_connection_get(hsphfpd->connection),
+            "type='signal',sender='" DBUS_SERVICE_DBUS "',interface='" DBUS_SERVICE_DBUS "',member='NameOwnerChanged',arg0='" HSPHFPD_SERVICE "'",
+            "type='signal',interface='" DBUS_INTERFACE_OBJECTMANAGER "',member='InterfacesAdded'",
+            "type='signal',interface='" DBUS_INTERFACE_OBJECTMANAGER "',member='InterfacesRemoved'",
+            "type='signal',interface='" DBUS_INTERFACE_PROPERTIES "',member='PropertiesChanged',arg0='" HSPHFPD_ENDPOINT_INTERFACE "'",
+            "type='signal',interface='" DBUS_INTERFACE_PROPERTIES "',member='PropertiesChanged',arg0='" HSPHFPD_AUDIO_TRANSPORT_INTERFACE "'",
+            NULL);
+
+    dbus_connection_remove_filter(pa_dbus_connection_get(hsphfpd->connection), filter_cb, hsphfpd);
+
+    pa_dbus_connection_unref(hsphfpd->connection);
+
+    pa_hashmap_free(hsphfpd->endpoints);
+
+    if (hsphfpd->legacy_hsp)
+        pa_bluetooth_legacy_hsp_unregister(hsphfpd->legacy_hsp);
+
+    pa_xfree(hsphfpd);
+}
diff --git a/src/modules/bluetooth/hsphfpd-util.h b/src/modules/bluetooth/hsphfpd-util.h
new file mode 100644
index 000000000..a836f69f3
--- /dev/null
+++ b/src/modules/bluetooth/hsphfpd-util.h
@@ -0,0 +1,30 @@
+#ifndef foohsphfpdutilhfoo
+#define foohsphfpdutilhfoo
+
+/***
+  This file is part of PulseAudio.
+
+  Copyrigth 2020 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#include <pulsecore/core.h>
+
+typedef struct pa_bluetooth_hsphfpd pa_bluetooth_hsphfpd;
+
+pa_bluetooth_hsphfpd *pa_bluetooth_hsphfpd_new(pa_core *core, pa_bluetooth_discovery *discovery);
+void pa_bluetooth_hsphfpd_free(pa_bluetooth_hsphfpd *hsphfpd);
+
+#endif
diff --git a/src/modules/bluetooth/backend-native.c b/src/modules/bluetooth/legacy-hsp.c
similarity index 51%
rename from src/modules/bluetooth/backend-native.c
rename to src/modules/bluetooth/legacy-hsp.c
index 5ba743966..2fb374536 100644
--- a/src/modules/bluetooth/backend-native.c
+++ b/src/modules/bluetooth/legacy-hsp.c
@@ -35,12 +35,13 @@
 #include <bluetooth/sco.h>
 
 #include "bluez5-util.h"
+#include "legacy-hsp.h"
 
-struct pa_bluetooth_backend {
+struct pa_bluetooth_legacy_hsp {
   pa_core *core;
   pa_dbus_connection *connection;
   pa_bluetooth_discovery *discovery;
-  bool enable_hs_role;
+  char *service_id;
 
   PA_LLIST_HEAD(pa_dbus_pending, pending);
 };
@@ -49,7 +50,7 @@ struct transport_data {
     int rfcomm_fd;
     pa_io_event *rfcomm_io;
     int sco_fd;
-    pa_io_event *sco_io;
+    pa_io_event *sco_connect_io;
     pa_mainloop_api *mainloop;
 };
 
@@ -62,11 +63,6 @@ struct transport_data {
 #define BLUEZ_PROFILE_INTERFACE BLUEZ_SERVICE ".Profile1"
 
 #define HSP_AG_PROFILE "/Profile/HSPAGProfile"
-#define HSP_HS_PROFILE "/Profile/HSPHSProfile"
-
-/* RFCOMM channel for HSP headset role
- * The choice seems to be a bit arbitrary -- it looks like at least channels 2, 4 and 5 also work*/
-#define HSP_HS_DEFAULT_CHANNEL  3
 
 #define PROFILE_INTROSPECT_XML                                          \
     DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                           \
@@ -90,25 +86,71 @@ struct transport_data {
     " </interface>"                                                     \
     "</node>"
 
-static pa_dbus_pending* send_and_add_to_pending(pa_bluetooth_backend *backend, DBusMessage *m,
+static pa_dbus_pending* send_and_add_to_pending(pa_bluetooth_legacy_hsp *hsp, DBusMessage *m,
         DBusPendingCallNotifyFunction func, void *call_data) {
 
     pa_dbus_pending *p;
     DBusPendingCall *call;
 
-    pa_assert(backend);
+    pa_assert(hsp);
     pa_assert(m);
 
-    pa_assert_se(dbus_connection_send_with_reply(pa_dbus_connection_get(backend->connection), m, &call, -1));
+    pa_assert_se(dbus_connection_send_with_reply(pa_dbus_connection_get(hsp->connection), m, &call, -1));
 
-    p = pa_dbus_pending_new(pa_dbus_connection_get(backend->connection), m, call, backend, call_data);
-    PA_LLIST_PREPEND(pa_dbus_pending, backend->pending, p);
+    p = pa_dbus_pending_new(pa_dbus_connection_get(hsp->connection), m, call, hsp, call_data);
+    PA_LLIST_PREPEND(pa_dbus_pending, hsp->pending, p);
     dbus_pending_call_set_notify(call, func, p, NULL);
 
     return p;
 }
 
+static void sco_connect_callback(pa_mainloop_api *mainloop, pa_io_event *sco_connect_io, int sco_fd, pa_io_event_flags_t events, void *userdata) {
+    pa_bluetooth_transport *t = userdata;
+    struct transport_data *trd = t->userdata;
+    socklen_t len;
+    int error;
+
+    trd->mainloop->io_free(trd->sco_connect_io);
+    trd->sco_connect_io = NULL;
+
+    if (events & (PA_IO_EVENT_HANGUP|PA_IO_EVENT_ERROR)) {
+        error = errno;
+        pa_log_error("connect() to %s failed: %s", t->device->address, pa_cstrerror(error));
+        goto failed;
+    }
+
+    error = 0;
+    len = sizeof(error);
+    if (getsockopt(trd->sco_fd, SOL_SOCKET, SO_ERROR, &error, &len) < 0 || len != sizeof(error)) {
+        error = errno;
+        pa_log_error("getsockopt() failed: %s", pa_cstrerror(error));
+        goto failed;
+    }
+
+    if (error) {
+        pa_log_error("connect() to %s failed: %s", t->device->address, pa_cstrerror(error));
+        goto failed;
+    }
+
+    pa_log_info("connect() to %s successful", t->device->address);
+    pa_bluetooth_transport_set_state(t, PA_BLUETOOTH_TRANSPORT_STATE_PLAYING);
+    return;
+
+failed:
+    close(trd->sco_fd);
+    trd->sco_fd = -error;
+
+    /* If transport state is idle switch it to disconnected state and then back to idle state
+     * so sinks and sources are properly released and connection attempt is marked as failed,
+     * this also trigger profile change to off */
+    if (t->state == PA_BLUETOOTH_TRANSPORT_STATE_IDLE) {
+        pa_bluetooth_transport_set_state(t, PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED);
+        pa_bluetooth_transport_set_state(t, PA_BLUETOOTH_TRANSPORT_STATE_IDLE);
+    }
+}
+
 static int sco_do_connect(pa_bluetooth_transport *t) {
+    struct transport_data *trd = t->userdata;
     pa_bluetooth_device *d = t->device;
     struct sockaddr_sco addr;
     socklen_t len;
@@ -127,7 +169,7 @@ static int sco_do_connect(pa_bluetooth_transport *t) {
     for (i = 5; i >= 0; i--, dst_addr += 3)
         dst.b[i] = strtol(dst_addr, NULL, 16);
 
-    sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_SCO);
+    sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET | SOCK_NONBLOCK, BTPROTO_SCO);
     if (sock < 0) {
         pa_log_error("socket(SEQPACKET, SCO) %s", pa_cstrerror(errno));
         return -1;
@@ -147,162 +189,73 @@ static int sco_do_connect(pa_bluetooth_transport *t) {
     addr.sco_family = AF_BLUETOOTH;
     bacpy(&addr.sco_bdaddr, &dst);
 
-    pa_log_info("doing connect");
-    err = connect(sock, (struct sockaddr *) &addr, len);
-    if (err < 0 && !(errno == EAGAIN || errno == EINPROGRESS)) {
+    pa_log_info("calling connect() to %s", d->address);
+    do {
+        err = connect(sock, (struct sockaddr *) &addr, len);
+    } while (err < 0 && errno == EINTR);
+    if (err < 0 && errno != EINPROGRESS) {
         pa_log_error("connect(): %s", pa_cstrerror(errno));
         goto fail_close;
     }
-    return sock;
+
+    trd->sco_fd = sock;
+    trd->sco_connect_io = trd->mainloop->io_new(trd->mainloop, trd->sco_fd, PA_IO_EVENT_OUTPUT, sco_connect_callback, t);
+    return 0;
 
 fail_close:
     close(sock);
     return -1;
 }
 
-static int sco_do_accept(pa_bluetooth_transport *t) {
+static int sco_acquire_cb(pa_bluetooth_transport *t, size_t *imtu, size_t *omtu) {
     struct transport_data *trd = t->userdata;
-    struct sockaddr_sco addr;
-    socklen_t optlen;
-    int sock;
+    int ret;
 
-    memset(&addr, 0, sizeof(addr));
-    optlen = sizeof(addr);
+    if (trd->sco_connect_io)
+        return -EAGAIN;
 
-    pa_log_info ("doing accept");
-    sock = accept(trd->sco_fd, (struct sockaddr *) &addr, &optlen);
-    if (sock < 0) {
-        if (errno != EAGAIN)
-            pa_log_error("accept(): %s", pa_cstrerror(errno));
-        goto fail;
+    if (trd->sco_fd < 0) {
+        if (trd->sco_fd == -EAGAIN) {
+            ret = sco_do_connect(t);
+            if (ret == 0)
+                ret = -EAGAIN;
+        } else {
+            ret = trd->sco_fd;
+            trd->sco_fd = -EAGAIN;
+        }
+        return ret;
     }
-    return sock;
-
-fail:
-    return -1;
-}
-
-static int sco_acquire_cb(pa_bluetooth_transport *t, bool optional, size_t *imtu, size_t *omtu) {
-    int sock;
-    socklen_t len;
-
-    if (optional)
-        sock = sco_do_accept(t);
-    else
-        sock = sco_do_connect(t);
-
-    if (sock < 0)
-        goto fail;
 
+    /* Legacy HSP profile implementation supports only CVSD air codec with
+     * PCM s16le 8kHz local codec which requies 48 bytes length packet size */
     if (imtu) *imtu = 48;
     if (omtu) *omtu = 48;
 
-    if (t->device->autodetect_mtu) {
-        struct sco_options sco_opt;
-
-        len = sizeof(sco_opt);
-        memset(&sco_opt, 0, len);
-
-        if (getsockopt(sock, SOL_SCO, SCO_OPTIONS, &sco_opt, &len) < 0)
-            pa_log_warn("getsockopt(SCO_OPTIONS) failed, loading defaults");
-        else {
-            pa_log_debug("autodetected imtu = omtu = %u", sco_opt.mtu);
-            if (imtu) *imtu = sco_opt.mtu;
-            if (omtu) *omtu = sco_opt.mtu;
-        }
-    }
-
-    return sock;
-
-fail:
-    return -1;
+    return trd->sco_fd;
 }
 
 static void sco_release_cb(pa_bluetooth_transport *t) {
-    pa_log_info("Transport %s released", t->path);
-    /* device will close the SCO socket for us */
-}
-
-static void sco_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_io_event_flags_t events, void *userdata) {
-    pa_bluetooth_transport *t = userdata;
-
-    pa_assert(io);
-    pa_assert(t);
-
-    if (events & (PA_IO_EVENT_HANGUP|PA_IO_EVENT_ERROR)) {
-        pa_log_error("error listening SCO connection: %s", pa_cstrerror(errno));
-        goto fail;
-    }
-
-    if (t->state != PA_BLUETOOTH_TRANSPORT_STATE_PLAYING) {
-        pa_log_info("SCO incoming connection: changing state to PLAYING");
-        pa_bluetooth_transport_set_state (t, PA_BLUETOOTH_TRANSPORT_STATE_PLAYING);
-    }
-
-fail:
-    return;
-}
-
-static int sco_listen(pa_bluetooth_transport *t) {
     struct transport_data *trd = t->userdata;
-    struct sockaddr_sco addr;
-    int sock, i;
-    bdaddr_t src;
-    const char *src_addr;
 
-    sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET | SOCK_NONBLOCK | SOCK_CLOEXEC, BTPROTO_SCO);
-    if (sock < 0) {
-        pa_log_error("socket(SEQPACKET, SCO) %s", pa_cstrerror(errno));
-        return -1;
-    }
-
-    src_addr = t->device->adapter->address;
-
-    /* don't use ba2str to avoid -lbluetooth */
-    for (i = 5; i >= 0; i--, src_addr += 3)
-        src.b[i] = strtol(src_addr, NULL, 16);
-
-    /* Bind to local address */
-    memset(&addr, 0, sizeof(addr));
-    addr.sco_family = AF_BLUETOOTH;
-    bacpy(&addr.sco_bdaddr, &src);
-
-    if (bind(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-        pa_log_error("bind(): %s", pa_cstrerror(errno));
-        goto fail_close;
-    }
-
-    pa_log_info ("doing listen");
-    if (listen(sock, 1) < 0) {
-        pa_log_error("listen(): %s", pa_cstrerror(errno));
-        goto fail_close;
-    }
-
-    trd->sco_fd = sock;
-    trd->sco_io = trd->mainloop->io_new(trd->mainloop, sock, PA_IO_EVENT_INPUT,
-        sco_io_callback, t);
-
-    return sock;
+    pa_log_info("Transport %s released", t->path);
 
-fail_close:
-    close(sock);
-    return -1;
+    shutdown(trd->sco_fd, SHUT_RDWR);
+    trd->sco_fd = -EAGAIN;
+    /* device will close the SCO socket for us */
 }
 
 static void register_profile_reply(DBusPendingCall *pending, void *userdata) {
     DBusMessage *r;
     pa_dbus_pending *p;
-    pa_bluetooth_backend *b;
-    char *profile;
+    pa_bluetooth_legacy_hsp *hsp;
 
     pa_assert(pending);
     pa_assert_se(p = userdata);
-    pa_assert_se(b = p->context_data);
-    pa_assert_se(profile = p->call_data);
+    pa_assert_se(hsp = p->context_data);
     pa_assert_se(r = dbus_pending_call_steal_reply(pending));
 
     if (dbus_message_is_error(r, BLUEZ_ERROR_NOT_SUPPORTED)) {
-        pa_log_info("Couldn't register profile %s because it is disabled in BlueZ", profile);
+        pa_log_info("Couldn't register HSP profile because it is disabled in BlueZ");
         goto finish;
     }
 
@@ -312,43 +265,57 @@ static void register_profile_reply(DBusPendingCall *pending, void *userdata) {
         goto finish;
     }
 
+    hsp->service_id = pa_xstrdup(dbus_message_get_sender(r));
+
 finish:
     dbus_message_unref(r);
 
-    PA_LLIST_REMOVE(pa_dbus_pending, b->pending, p);
+    PA_LLIST_REMOVE(pa_dbus_pending, hsp->pending, p);
     pa_dbus_pending_free(p);
-
-    pa_xfree(profile);
 }
 
-static void register_profile(pa_bluetooth_backend *b, const char *profile, const char *uuid) {
+static void register_profile(pa_bluetooth_legacy_hsp *hsp) {
     DBusMessage *m;
     DBusMessageIter i, d;
-    dbus_bool_t autoconnect;
-    dbus_uint16_t version, chan;
+    const char *object = HSP_AG_PROFILE;
+    const char *uuid = PA_BLUETOOTH_UUID_HSP_AG; /* Remote headset role connects to local audio gateway role */
 
-    pa_log_debug("Registering Profile %s %s", profile, uuid);
+    pa_log_debug("Registering HSP profile to BlueZ");
 
     pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, "/org/bluez", BLUEZ_PROFILE_MANAGER_INTERFACE, "RegisterProfile"));
 
     dbus_message_iter_init_append(m, &i);
-    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &profile));
+    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &object));
     pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_STRING, &uuid));
     dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
             DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
-    if (pa_bluetooth_uuid_is_hsp_hs(uuid)) {
-        /* In the headset role, the connection will only be initiated from the remote side */
-        autoconnect = 0;
-        pa_dbus_append_basic_variant_dict_entry(&d, "AutoConnect", DBUS_TYPE_BOOLEAN, &autoconnect);
-        chan = HSP_HS_DEFAULT_CHANNEL;
-        pa_dbus_append_basic_variant_dict_entry(&d, "Channel", DBUS_TYPE_UINT16, &chan);
-        /* HSP version 1.2 */
-        version = 0x0102;
-        pa_dbus_append_basic_variant_dict_entry(&d, "Version", DBUS_TYPE_UINT16, &version);
-    }
     dbus_message_iter_close_container(&i, &d);
 
-    send_and_add_to_pending(b, m, register_profile_reply, pa_xstrdup(profile));
+    send_and_add_to_pending(hsp, m, register_profile_reply, NULL);
+}
+
+static void unregister_profile(pa_bluetooth_legacy_hsp *hsp) {
+    DBusMessage *m;
+    const char *object = HSP_AG_PROFILE;
+    pa_hashmap *transports;
+    pa_bluetooth_transport *t;
+    void *state;
+
+    pa_log_debug("Unregistering HSP profile from BlueZ");
+
+    pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, "/org/bluez", BLUEZ_PROFILE_MANAGER_INTERFACE, "UnregisterProfile"));
+    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_OBJECT_PATH, &object, DBUS_TYPE_INVALID));
+    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(hsp->connection), m, NULL));
+
+    pa_assert_se(transports = pa_bluetooth_transport_get_all(hsp->discovery));
+    PA_HASHMAP_FOREACH(t, transports, state) {
+        /* owner for legacy HSP and A2DP is same bluez, so we need to check also for provide */
+        if (!t->owner || !pa_safe_streq(t->owner, hsp->service_id) || t->profile != PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT)
+            continue;
+        /* Function pa_bluetooth_transport_free() is safe as it just calls pa_hashmap_remove()
+         * on current iterator entry and this is by pulseaudio hashmap structure allowed */
+        pa_bluetooth_transport_free(t);
+    }
 }
 
 static void rfcomm_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_io_event_flags_t events, void *userdata) {
@@ -365,10 +332,10 @@ static void rfcomm_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_i
     if (events & PA_IO_EVENT_INPUT) {
         char buf[512];
         ssize_t len;
-        int gain, dummy;
-        bool  do_reply = false;
+        int gain;
+        bool success;
 
-        len = pa_read(fd, buf, 511, NULL);
+        len = pa_read(fd, buf, sizeof(buf)-1, NULL);
         if (len < 0) {
             pa_log_error("RFCOMM read error: %s", pa_cstrerror(errno));
             goto fail;
@@ -379,54 +346,57 @@ static void rfcomm_io_callback(pa_mainloop_api *io, pa_io_event *e, int fd, pa_i
         /* There are only four HSP AT commands:
          * AT+VGS=value: value between 0 and 15, sent by the HS to AG to set the speaker gain.
          * +VGS=value is sent by AG to HS as a response to an AT+VGS command or when the gain
-         * is changed on the AG side.
+         * is changed on the AG side. Some buggy headsets sent it instead of AT+VGS.
          * AT+VGM=value: value between 0 and 15, sent by the HS to AG to set the microphone gain.
          * +VGM=value is sent by AG to HS as a response to an AT+VGM command or when the gain
-         * is changed on the AG side.
+         * is changed on the AG side. Some buggy headsets sent it instead of AT+VGM.
          * AT+CKPD=200: Sent by HS when headset button is pressed.
          * RING: Sent by AG to HS to notify of an incoming call. It can safely be ignored because
-         * it does not expect a reply. */
-        if (sscanf(buf, "AT+VGS=%d", &gain) == 1 || sscanf(buf, "\r\n+VGM=%d\r\n", &gain) == 1) {
-            t->speaker_gain = gain;
-            pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED), t);
-            do_reply = true;
-
-        } else if (sscanf(buf, "AT+VGM=%d", &gain) == 1 || sscanf(buf, "\r\n+VGS=%d\r\n", &gain) == 1) {
-            t->microphone_gain = gain;
-            pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED), t);
-            do_reply = true;
-        } else if (sscanf(buf, "AT+CKPD=%d", &dummy) == 1) {
-            do_reply = true;
+         * it does not expect a reply.
+         * We support only local AG role and only microphone and speaker gain commands.
+         * Leading space in sscanf format matches any amount of whitespace characters including none */
+        if (sscanf(buf, " AT+VGS=%d", &gain) == 1 || sscanf(buf, " +VGS=%d", &gain) == 1) {
+            t->tx_volume_gain = gain;
+            pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_TX_VOLUME_GAIN_CHANGED), t);
+            success = true;
+        } else if (sscanf(buf, " AT+VGM=%d", &gain) == 1 || sscanf(buf, " +VGM=%d", &gain) == 1) {
+            t->rx_volume_gain = gain;
+            pa_hook_fire(pa_bluetooth_discovery_hook(t->device->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_RX_VOLUME_GAIN_CHANGED), t);
+            success = true;
         } else {
-            do_reply = false;
+            success = false;
         }
 
-        if (do_reply) {
+        if (success) {
             pa_log_debug("RFCOMM >> OK");
-
             len = write(fd, "\r\nOK\r\n", 6);
-
-            /* we ignore any errors, it's not critical and real errors should
-             * be caught with the HANGUP and ERROR events handled above */
-            if (len < 0)
-                pa_log_error("RFCOMM write error: %s", pa_cstrerror(errno));
+        } else if (!strstr(buf, "ERROR")) {
+            /* Do not reply to ERROR command as some buggy headsets sent it for ERROR response */
+            pa_log_debug("RFCOMM >> ERROR");
+            len = write(fd, "\r\nERROR\r\n", 9);
+        } else {
+            len = 0;
         }
+
+        /* we ignore any errors, it's not critical and real errors should
+         * be caught with the HANGUP and ERROR events handled above */
+        if (len < 0)
+            pa_log_error("RFCOMM write error: %s", pa_cstrerror(errno));
     }
 
     return;
 
 fail:
-    pa_bluetooth_transport_unlink(t);
     pa_bluetooth_transport_free(t);
 }
 
 static void transport_destroy(pa_bluetooth_transport *t) {
     struct transport_data *trd = t->userdata;
 
-    if (trd->sco_io) {
-        trd->mainloop->io_free(trd->sco_io);
+    if (trd->sco_connect_io) {
+        trd->mainloop->io_free(trd->sco_connect_io);
         shutdown(trd->sco_fd, SHUT_RDWR);
-        close (trd->sco_fd);
+        close(trd->sco_fd);
     }
 
     trd->mainloop->io_free(trd->rfcomm_io);
@@ -436,26 +406,18 @@ static void transport_destroy(pa_bluetooth_transport *t) {
     pa_xfree(trd);
 }
 
-static void set_speaker_gain(pa_bluetooth_transport *t, uint16_t gain) {
+static void set_tx_volume_gain(pa_bluetooth_transport *t, uint16_t gain) {
     struct transport_data *trd = t->userdata;
     char buf[512];
     ssize_t len, written;
 
-    if (t->speaker_gain == gain)
+    if (t->tx_volume_gain == gain)
       return;
 
-    t->speaker_gain = gain;
-
-    /* If we are in the AG role, we send a command to the head set to change
-     * the speaker gain. In the HS role, source and sink are swapped, so
-     * in this case we notify the AG that the microphone gain has changed */
-    if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT) {
-        len = sprintf(buf, "\r\n+VGS=%d\r\n", gain);
-        pa_log_debug("RFCOMM >> +VGS=%d", gain);
-    } else {
-        len = sprintf(buf, "\r\nAT+VGM=%d\r\n", gain);
-        pa_log_debug("RFCOMM >> AT+VGM=%d", gain);
-    }
+    t->tx_volume_gain = gain;
+
+    len = sprintf(buf, "\r\n+VGS=%d\r\n", gain);
+    pa_log_debug("RFCOMM >> +VGS=%d", gain);
 
     written = write(trd->rfcomm_fd, buf, len);
 
@@ -463,26 +425,18 @@ static void set_speaker_gain(pa_bluetooth_transport *t, uint16_t gain) {
         pa_log_error("RFCOMM write error: %s", pa_cstrerror(errno));
 }
 
-static void set_microphone_gain(pa_bluetooth_transport *t, uint16_t gain) {
+static void set_rx_volume_gain(pa_bluetooth_transport *t, uint16_t gain) {
     struct transport_data *trd = t->userdata;
     char buf[512];
     ssize_t len, written;
 
-    if (t->microphone_gain == gain)
+    if (t->rx_volume_gain == gain)
       return;
 
-    t->microphone_gain = gain;
-
-    /* If we are in the AG role, we send a command to the head set to change
-     * the microphone gain. In the HS role, source and sink are swapped, so
-     * in this case we notify the AG that the speaker gain has changed */
-    if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT) {
-        len = sprintf(buf, "\r\n+VGM=%d\r\n", gain);
-        pa_log_debug("RFCOMM >> +VGM=%d", gain);
-    } else {
-        len = sprintf(buf, "\r\nAT+VGS=%d\r\n", gain);
-        pa_log_debug("RFCOMM >> AT+VGS=%d", gain);
-    }
+    t->rx_volume_gain = gain;
+
+    len = sprintf(buf, "\r\n+VGM=%d\r\n", gain);
+    pa_log_debug("RFCOMM >> +VGM=%d", gain);
 
     written = write (trd->rfcomm_fd, buf, len);
 
@@ -491,39 +445,36 @@ static void set_microphone_gain(pa_bluetooth_transport *t, uint16_t gain) {
 }
 
 static DBusMessage *profile_new_connection(DBusConnection *conn, DBusMessage *m, void *userdata) {
-    pa_bluetooth_backend *b = userdata;
+    pa_bluetooth_legacy_hsp *hsp = userdata;
     pa_bluetooth_device *d;
     pa_bluetooth_transport *t;
-    pa_bluetooth_profile_t p;
     DBusMessage *r;
     int fd;
     const char *sender, *path, PA_UNUSED *handler;
     DBusMessageIter arg_i;
-    char *pathfd;
     struct transport_data *trd;
 
     if (!dbus_message_iter_init(m, &arg_i) || !pa_streq(dbus_message_get_signature(m), "oha{sv}")) {
         pa_log_error("Invalid signature found in NewConnection");
-        goto fail;
+        pa_assert_se(r = dbus_message_new_error(m, "org.bluez.Error.InvalidArguments", "Invalid signature"));
+        return r;
     }
 
     handler = dbus_message_get_path(m);
-    if (pa_streq(handler, HSP_AG_PROFILE)) {
-        p = PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT;
-    } else if (pa_streq(handler, HSP_HS_PROFILE)) {
-        p = PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY;
-    } else {
+    if (!pa_streq(handler, HSP_AG_PROFILE)) {
         pa_log_error("Invalid handler");
-        goto fail;
+        pa_assert_se(r = dbus_message_new_error(m, "org.bluez.Error.InvalidArguments", "Invalid handler"));
+        return r;
     }
 
     pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_OBJECT_PATH);
     dbus_message_iter_get_basic(&arg_i, &path);
 
-    d = pa_bluetooth_discovery_get_device_by_path(b->discovery, path);
+    d = pa_bluetooth_discovery_get_device_by_path(hsp->discovery, path);
     if (d == NULL) {
         pa_log_error("Device doesnt exist for %s", path);
-        goto fail;
+        pa_assert_se(r = dbus_message_new_error_printf(m, "org.bluez.Error.InvalidArguments", "Device doesnt exist for %s", path));
+        return r;
     }
 
     pa_assert_se(dbus_message_iter_next(&arg_i));
@@ -531,57 +482,79 @@ static DBusMessage *profile_new_connection(DBusConnection *conn, DBusMessage *m,
     pa_assert(dbus_message_iter_get_arg_type(&arg_i) == DBUS_TYPE_UNIX_FD);
     dbus_message_iter_get_basic(&arg_i, &fd);
 
-    pa_log_debug("dbus: NewConnection path=%s, fd=%d, profile %s", path, fd,
-        pa_bluetooth_profile_to_string(p));
+    pa_log_debug("dbus: NewConnection path=%s, fd=%d", path, fd);
 
     sender = dbus_message_get_sender(m);
 
-    pathfd = pa_sprintf_malloc ("%s/fd%d", path, fd);
-    t = pa_bluetooth_transport_new(d, sender, pathfd, p, NULL, 0);
-    pa_xfree(pathfd);
+    t = pa_bluetooth_transport_new(d, sender, path, PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT, NULL, 0);
+
+    /* Expects that remote HSP headset supports volume control and we do not need to use local softvol */
+    t->rx_soft_volume = false;
+    t->tx_soft_volume = false;
+    t->max_rx_volume_gain = 15;
+    t->max_tx_volume_gain = 15;
 
     t->acquire = sco_acquire_cb;
     t->release = sco_release_cb;
     t->destroy = transport_destroy;
-    t->set_speaker_gain = set_speaker_gain;
-    t->set_microphone_gain = set_microphone_gain;
+    t->set_rx_volume_gain = set_rx_volume_gain;
+    t->set_tx_volume_gain = set_tx_volume_gain;
 
     trd = pa_xnew0(struct transport_data, 1);
     trd->rfcomm_fd = fd;
-    trd->mainloop = b->core->mainloop;
-    trd->rfcomm_io = trd->mainloop->io_new(b->core->mainloop, fd, PA_IO_EVENT_INPUT,
+    trd->mainloop = hsp->core->mainloop;
+    trd->rfcomm_io = trd->mainloop->io_new(hsp->core->mainloop, fd, PA_IO_EVENT_INPUT,
         rfcomm_io_callback, t);
+    trd->sco_fd = -EAGAIN;
     t->userdata =  trd;
 
-    sco_listen(t);
-
     pa_bluetooth_transport_put(t);
 
     pa_log_debug("Transport %s available for profile %s", t->path, pa_bluetooth_profile_to_string(t->profile));
 
     pa_assert_se(r = dbus_message_new_method_return(m));
-
-    return r;
-
-fail:
-    pa_assert_se(r = dbus_message_new_error(m, "org.bluez.Error.InvalidArguments", "Unable to handle new connection"));
     return r;
 }
 
 static DBusMessage *profile_request_disconnection(DBusConnection *conn, DBusMessage *m, void *userdata) {
+    pa_bluetooth_legacy_hsp *hsp = userdata;
     DBusMessage *r;
+    DBusError error;
+    const char *path;
+    pa_bluetooth_transport *t;
 
-    pa_assert_se(r = dbus_message_new_method_return(m));
+    dbus_error_init(&error);
+
+    if (!dbus_message_get_args(m, &error, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_INVALID) || dbus_error_is_set(&error)) {
+        pa_log_error("Invalid parameters found in RequestDisconnection: %s", error.message);
+        pa_assert_se(r = dbus_message_new_error_printf(m, "org.bluez.Error.InvalidArguments", "Invalid parameters: %s", error.message));
+        dbus_error_free(&error);
+        return r;
+    }
+
+    dbus_error_free(&error);
+
+    pa_log_debug("dbus: RequestDisconnection path=%s", path);
 
+    t = pa_bluetooth_transport_get(hsp->discovery, path);
+    if (!t || !pa_safe_streq(dbus_message_get_sender(m), t->owner) || t->profile != PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT) {
+        pa_log_error("RequestDisconnection failed: Endpoint %s is not connected", path);
+        pa_assert_se(r = dbus_message_new_error_printf(m, "org.bluez.Error.InvalidArguments", "Endpoint %s is not connected", path));
+        return r;
+    }
+
+    pa_bluetooth_transport_free(t);
+
+    pa_assert_se(r = dbus_message_new_method_return(m));
     return r;
 }
 
 static DBusHandlerResult profile_handler(DBusConnection *c, DBusMessage *m, void *userdata) {
-    pa_bluetooth_backend *b = userdata;
+    pa_bluetooth_legacy_hsp *hsp = userdata;
     DBusMessage *r = NULL;
     const char *path, *interface, *member;
 
-    pa_assert(b);
+    pa_assert(hsp);
 
     path = dbus_message_get_path(m);
     interface = dbus_message_get_interface(m);
@@ -589,7 +562,7 @@ static DBusHandlerResult profile_handler(DBusConnection *c, DBusMessage *m, void
 
     pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
 
-    if (!pa_streq(path, HSP_AG_PROFILE) && !pa_streq(path, HSP_HS_PROFILE))
+    if (!pa_streq(path, HSP_AG_PROFILE))
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
     if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
@@ -609,106 +582,52 @@ static DBusHandlerResult profile_handler(DBusConnection *c, DBusMessage *m, void
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
     if (r) {
-        pa_assert_se(dbus_connection_send(pa_dbus_connection_get(b->connection), r, NULL));
+        pa_assert_se(dbus_connection_send(pa_dbus_connection_get(hsp->connection), r, NULL));
         dbus_message_unref(r);
     }
 
     return DBUS_HANDLER_RESULT_HANDLED;
 }
 
-static void profile_init(pa_bluetooth_backend *b, pa_bluetooth_profile_t profile) {
+pa_bluetooth_legacy_hsp *pa_bluetooth_legacy_hsp_register(pa_core *c, pa_bluetooth_discovery *y) {
     static const DBusObjectPathVTable vtable_profile = {
         .message_function = profile_handler,
     };
-    const char *object_name;
-    const char *uuid;
-
-    pa_assert(b);
-
-    switch (profile) {
-        case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
-            object_name = HSP_AG_PROFILE;
-            uuid = PA_BLUETOOTH_UUID_HSP_AG;
-            break;
-        case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
-            object_name = HSP_HS_PROFILE;
-            uuid = PA_BLUETOOTH_UUID_HSP_HS;
-            break;
-        default:
-            pa_assert_not_reached();
-            break;
-    }
-
-    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(b->connection), object_name, &vtable_profile, b));
-    register_profile(b, object_name, uuid);
-}
 
-static void profile_done(pa_bluetooth_backend *b, pa_bluetooth_profile_t profile) {
-    pa_assert(b);
-
-    switch (profile) {
-        case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
-            dbus_connection_unregister_object_path(pa_dbus_connection_get(b->connection), HSP_AG_PROFILE);
-            break;
-        case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
-            dbus_connection_unregister_object_path(pa_dbus_connection_get(b->connection), HSP_HS_PROFILE);
-            break;
-        default:
-            pa_assert_not_reached();
-            break;
-    }
-}
-
-void pa_bluetooth_native_backend_enable_hs_role(pa_bluetooth_backend *native_backend, bool enable_hs_role) {
-
-   if (enable_hs_role == native_backend->enable_hs_role)
-       return;
-
-   if (enable_hs_role)
-       profile_init(native_backend, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-   else
-       profile_done(native_backend, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-
-   native_backend->enable_hs_role = enable_hs_role;
-}
-
-pa_bluetooth_backend *pa_bluetooth_native_backend_new(pa_core *c, pa_bluetooth_discovery *y, bool enable_hs_role) {
-    pa_bluetooth_backend *backend;
+    pa_bluetooth_legacy_hsp *hsp;
     DBusError err;
 
-    pa_log_debug("Bluetooth Headset Backend API support using the native backend");
+    pa_log_warn("Enabling legacy HSP profile");
 
-    backend = pa_xnew0(pa_bluetooth_backend, 1);
-    backend->core = c;
+    hsp = pa_xnew0(pa_bluetooth_legacy_hsp, 1);
+    hsp->core = c;
 
     dbus_error_init(&err);
-    if (!(backend->connection = pa_dbus_bus_get(c, DBUS_BUS_SYSTEM, &err))) {
+    if (!(hsp->connection = pa_dbus_bus_get(c, DBUS_BUS_SYSTEM, &err))) {
         pa_log("Failed to get D-Bus connection: %s", err.message);
         dbus_error_free(&err);
-        pa_xfree(backend);
+        pa_xfree(hsp);
         return NULL;
     }
 
-    backend->discovery = y;
-    backend->enable_hs_role = enable_hs_role;
-
-    if (enable_hs_role)
-       profile_init(backend, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-    profile_init(backend, PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT);
+    hsp->discovery = y;
 
-    return backend;
+    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(hsp->connection), HSP_AG_PROFILE, &vtable_profile, hsp));
+    register_profile(hsp);
+    return hsp;
 }
 
-void pa_bluetooth_native_backend_free(pa_bluetooth_backend *backend) {
-    pa_assert(backend);
+void pa_bluetooth_legacy_hsp_unregister(pa_bluetooth_legacy_hsp *hsp) {
+    pa_assert(hsp);
 
-    pa_dbus_free_pending_list(&backend->pending);
+    pa_log_warn("Disabling legacy HSP profile");
 
-    if (backend->enable_hs_role)
-       profile_done(backend, PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
-    profile_done(backend, PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT);
+    pa_dbus_free_pending_list(&hsp->pending);
 
-    pa_dbus_connection_unref(backend->connection);
+    unregister_profile(hsp);
+    dbus_connection_unregister_object_path(pa_dbus_connection_get(hsp->connection), HSP_AG_PROFILE);
+    pa_dbus_connection_unref(hsp->connection);
 
-    pa_xfree(backend);
+    pa_xfree(hsp->service_id);
+    pa_xfree(hsp);
 }
diff --git a/src/modules/bluetooth/legacy-hsp.h b/src/modules/bluetooth/legacy-hsp.h
new file mode 100644
index 000000000..5d7954ad3
--- /dev/null
+++ b/src/modules/bluetooth/legacy-hsp.h
@@ -0,0 +1,35 @@
+#ifndef foolegacyhsphfoo
+#define foolegacyhsphfoo
+
+/***
+  This file is part of PulseAudio.
+
+  Copyrigth 2020 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#include <pulsecore/core.h>
+
+typedef struct pa_bluetooth_legacy_hsp pa_bluetooth_legacy_hsp;
+
+#ifdef HAVE_BLUEZ_5_LEGACY_HSP
+pa_bluetooth_legacy_hsp *pa_bluetooth_legacy_hsp_register(pa_core *c, pa_bluetooth_discovery *y);
+void pa_bluetooth_legacy_hsp_unregister(pa_bluetooth_legacy_hsp *hsp);
+#else
+static inline pa_bluetooth_legacy_hsp *pa_bluetooth_legacy_hsp_register(pa_core *c, pa_bluetooth_discovery *y) { return NULL; }
+static inline void pa_bluetooth_legacy_hsp_unregister(pa_bluetooth_legacy_hsp *hsp) {}
+#endif
+
+#endif
diff --git a/src/modules/bluetooth/meson.build b/src/modules/bluetooth/meson.build
index 9982cbafc..736a479e2 100644
--- a/src/modules/bluetooth/meson.build
+++ b/src/modules/bluetooth/meson.build
@@ -1,7 +1,9 @@
 libbluez5_util_sources = [
+  'a2dp-codec-faststream.c',
   'a2dp-codec-sbc.c',
   'a2dp-codec-util.c',
   'bluez5-util.c',
+  'hsphfpd-util.c',
 ]
 
 libbluez5_util_headers = [
@@ -9,15 +11,17 @@ libbluez5_util_headers = [
   'a2dp-codecs.h',
   'a2dp-codec-util.h',
   'bluez5-util.h',
+  'hsphfpd-util.h',
+  'legacy-hsp.h',
   'rtp.h',
 ]
 
-if get_option('bluez5-native-headset')
-  libbluez5_util_sources += [ 'backend-native.c' ]
+if get_option('bluez5-legacy-hsp')
+  libbluez5_util_sources += [ 'legacy-hsp.c' ]
 endif
 
-if get_option('bluez5-ofono-headset')
-  libbluez5_util_sources += [ 'backend-ofono.c' ]
+if bluez5_aptx
+  libbluez5_util_sources += [ 'a2dp-codec-aptx.c' ]
 endif
 
 libbluez5_util = shared_library('bluez5-util',
@@ -26,7 +30,7 @@ libbluez5_util = shared_library('bluez5-util',
   c_args : [pa_c_args, server_c_args],
   link_args : [nodelete_link_args],
   include_directories : [configinc, topinc],
-  dependencies : [libpulse_dep, libpulsecommon_dep, libpulsecore_dep, dbus_dep, sbc_dep],
+  dependencies : [libpulse_dep, libpulsecommon_dep, libpulsecore_dep, dbus_dep, sbc_dep, bluez5_aptx_dep],
   install : true,
   install_rpath : privlibdir,
   install_dir : modlibexecdir,
diff --git a/src/modules/bluetooth/module-bluetooth-discover.c b/src/modules/bluetooth/module-bluetooth-discover.c
index cf8c7eefe..ffb8cb378 100644
--- a/src/modules/bluetooth/module-bluetooth-discover.c
+++ b/src/modules/bluetooth/module-bluetooth-discover.c
@@ -29,10 +29,6 @@ PA_MODULE_AUTHOR("João Paulo Rechi Vita");
 PA_MODULE_DESCRIPTION("Detect available Bluetooth daemon and load the corresponding discovery module");
 PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(true);
-PA_MODULE_USAGE(
-    "headset=ofono|native|auto"
-    "autodetect_mtu=<boolean>"
-);
 
 struct userdata {
     uint32_t bluez5_module_idx;
diff --git a/src/modules/bluetooth/module-bluetooth-policy.c b/src/modules/bluetooth/module-bluetooth-policy.c
index ffaa14041..320e15924 100644
--- a/src/modules/bluetooth/module-bluetooth-policy.c
+++ b/src/modules/bluetooth/module-bluetooth-policy.c
@@ -36,9 +36,9 @@ PA_MODULE_DESCRIPTION("Policy module to make using bluetooth devices out-of-the-
 PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(true);
 PA_MODULE_USAGE(
-        "auto_switch=<Switch between hsp and a2dp profile? (0 - never, 1 - media.role=phone, 2 - heuristic> "
-        "a2dp_source=<Handle a2dp_source card profile (sink role)?> "
-        "ag=<Handle headset_audio_gateway card profile (headset role)?> ");
+        "auto_switch=<Switch between head unit and a2dp sink card profiles? (0 - never, 1 - media.role=phone, 2 - heuristic> "
+        "a2dp_source=<Handle a2dp source card profiles?> "
+        "ag=<Handle audio gateway card profiles?> ");
 
 static const char* const valid_modargs[] = {
     "auto_switch",
@@ -58,7 +58,12 @@ struct userdata {
     pa_hook_slot *card_init_profile_slot;
     pa_hook_slot *card_unlink_slot;
     pa_hook_slot *profile_available_changed_slot;
-    pa_hashmap *will_need_revert_card_map;
+    pa_hashmap *profile_switch_map;
+};
+
+struct profile_switch {
+    const char *from_profile;
+    const char *to_profile;
 };
 
 /* When a source is created, loopback it to default sink */
@@ -84,9 +89,9 @@ static pa_hook_result_t source_put_hook_callback(pa_core *c, pa_source *source,
     if (!s)
         return PA_HOOK_OK;
 
-    if (u->enable_a2dp_source && pa_streq(s, "a2dp_source"))
+    if (u->enable_a2dp_source && pa_startswith(s, "a2dp_source"))
         role = "music";
-    else if (u->enable_ag && pa_streq(s, "headset_audio_gateway"))
+    else if (u->enable_ag && (pa_streq(s, "headset_audio_gateway") || pa_streq(s, "handsfree_audio_gateway")))
         role = "phone";
     else {
         pa_log_debug("Profile %s cannot be selected for loopback", s);
@@ -125,7 +130,9 @@ static pa_hook_result_t sink_put_hook_callback(pa_core *c, pa_sink *sink, void *
     if (!s)
         return PA_HOOK_OK;
 
-    if (u->enable_ag && pa_streq(s, "headset_audio_gateway"))
+    if (u->enable_a2dp_source && pa_startswith(s, "a2dp_source")) /* A2DP source with microphone backchannel */
+        role = "music";
+    else if (u->enable_ag && (pa_streq(s, "headset_audio_gateway") || pa_streq(s, "handsfree_audio_gateway")))
         role = "phone";
     else {
         pa_log_debug("Profile %s cannot be selected for loopback", s);
@@ -141,43 +148,54 @@ static pa_hook_result_t sink_put_hook_callback(pa_core *c, pa_sink *sink, void *
     return PA_HOOK_OK;
 }
 
-static void card_set_profile(struct userdata *u, pa_card *card, bool revert_to_a2dp)
-{
+static void card_set_profile(struct userdata *u, pa_card *card, const char *revert_to_profile_name) {
+    pa_card_profile *iter_profile;
     pa_card_profile *profile;
+    struct profile_switch *ps;
+    char *old_profile_name;
     void *state;
 
-    /* Find available profile and activate it */
-    PA_HASHMAP_FOREACH(profile, card->profiles, state) {
-        if (profile->available == PA_AVAILABLE_NO)
-            continue;
-
-        /* Check for correct profile based on revert_to_a2dp */
-        if (revert_to_a2dp) {
-            if (!pa_streq(profile->name, "a2dp_sink"))
+    if (revert_to_profile_name) {
+        profile = pa_hashmap_get(card->profiles, revert_to_profile_name);
+    } else {
+        /* Find highest priority profile with both sink and source */
+        profile = NULL;
+        PA_HASHMAP_FOREACH(iter_profile, card->profiles, state) {
+            if (iter_profile->available == PA_AVAILABLE_NO)
                 continue;
-        } else {
-            if (!pa_streq(profile->name, "headset_head_unit"))
+            if (iter_profile->n_sources == 0 || iter_profile->n_sinks == 0)
                 continue;
+            if (!profile || profile->priority < iter_profile->priority)
+                profile = iter_profile;
         }
+    }
 
-        pa_log_debug("Setting card '%s' to profile '%s'", card->name, profile->name);
+    if (!profile) {
+        pa_log_warn("Could not find any suitable profile for card '%s'", card->name);
+        return;
+    }
 
-        if (pa_card_set_profile(card, profile, false) != 0) {
-            pa_log_warn("Could not set profile '%s'", profile->name);
-            continue;
-        }
+    old_profile_name = card->active_profile->name;
 
-        /* When we are not in revert_to_a2dp phase flag this card for will_need_revert */
-        if (!revert_to_a2dp)
-            pa_hashmap_put(u->will_need_revert_card_map, card, PA_INT_TO_PTR(1));
+    pa_log_debug("Setting card '%s' from profile '%s' to profile '%s'", card->name, old_profile_name, profile->name);
 
-        break;
+    pa_card_set_profile(card, profile, false);
+
+    /* When not reverting, store data for future reverting */
+    if (!revert_to_profile_name) {
+        ps = pa_xnew0(struct profile_switch, 1);
+        ps->from_profile = old_profile_name;
+        ps->to_profile = profile->name;
+        pa_hashmap_put(u->profile_switch_map, card, ps);
     }
 }
 
 /* Switch profile for one card */
-static void switch_profile(pa_card *card, bool revert_to_a2dp, void *userdata) {
+static void switch_profile(pa_card *card, bool revert, void *userdata) {
     struct userdata *u = userdata;
+    struct profile_switch *ps;
+    const char *from_profile;
+    const char *to_profile;
     const char *s;
 
     /* Only consider bluetooth cards */
@@ -185,29 +203,34 @@ static void switch_profile(pa_card *card, bool revert_to_a2dp, void *userdata) {
     if (!s || !pa_streq(s, "bluetooth"))
         return;
 
-    if (revert_to_a2dp) {
-        /* In revert_to_a2dp phase only consider cards with will_need_revert flag and remove it */
-        if (!pa_hashmap_remove(u->will_need_revert_card_map, card))
-            return;
+    s = pa_proplist_gets(card->proplist, "bluetooth.protocol");
+    if (!s)
+        return;
+
+    /* Skip card if is already managed by loopback module loaded from source_put_hook_callback() */
+    if ((u->enable_a2dp_source && pa_startswith(s, "a2dp_source")) || /* A2DP source with microphone backchannel */
+        (u->enable_ag && (pa_streq(s, "headset_audio_gateway") || pa_streq(s, "handsfree_audio_gateway"))))
+        return;
 
-        /* Skip card if does not have active hsp profile */
-        if (!pa_streq(card->active_profile->name, "headset_head_unit"))
+    if (revert) {
+        /* In revert phase only consider cards which switched profile */
+        if (!(ps = pa_hashmap_remove(u->profile_switch_map, card)))
             return;
 
-        /* Skip card if already has active a2dp profile */
-        if (pa_streq(card->active_profile->name, "a2dp_sink"))
+        from_profile = ps->from_profile;
+        to_profile = ps->to_profile;
+        pa_xfree(ps);
+
+        /* Skip card if does not have active profile to which was switched */
+        if (!pa_streq(card->active_profile->name, to_profile))
             return;
     } else {
-        /* Skip card if does not have active a2dp profile */
-        if (!pa_streq(card->active_profile->name, "a2dp_sink"))
-            return;
-
-        /* Skip card if already has active hsp profile */
-        if (pa_streq(card->active_profile->name, "headset_head_unit"))
+        /* Skip card if already has both sink and source */
+        if (card->active_profile->n_sources > 0 && card->active_profile->n_sinks > 0)
             return;
     }
 
-    card_set_profile(u, card, revert_to_a2dp);
+    card_set_profile(u, card, revert ? from_profile : NULL);
 }
 
 /* Return true if we should ignore this source output */
@@ -235,6 +258,9 @@ static bool ignore_output(pa_source_output *source_output, void *userdata) {
 
     /* Ignore if recording from monitor of sink */
     if (source_output->direct_on_input)
+
+    /* Ignore if source output is not movable */
+    if (source_output->flags & PA_SOURCE_OUTPUT_DONT_MOVE)
         return true;
 
     return false;
@@ -249,35 +275,45 @@ static unsigned source_output_count(pa_core *c, void *userdata) {
         if (!ignore_output(source_output, userdata))
             ++count;
 
+    pa_log_debug("source_output_count=%u", count);
+
     return count;
 }
 
 /* Switch profile for all cards */
-static void switch_profile_all(pa_idxset *cards, bool revert_to_a2dp, void *userdata) {
+static void switch_profile_all(pa_idxset *cards, bool revert, void *userdata) {
     pa_card *card;
     uint32_t idx;
 
     PA_IDXSET_FOREACH(card, cards, idx)
-        switch_profile(card, revert_to_a2dp, userdata);
+        switch_profile(card, revert, userdata);
 }
 
-/* When a source output is created, switch profile a2dp to profile hsp */
+/* When the first source output is created, switch profile to some which has both sink and source */
 static pa_hook_result_t source_output_put_hook_callback(pa_core *c, pa_source_output *source_output, void *userdata) {
     pa_assert(c);
     pa_assert(source_output);
 
+    pa_log_debug("source_output_put_hook_callback called");
+
     if (ignore_output(source_output, userdata))
         return PA_HOOK_OK;
 
+    /* If there already were source outputs do nothing */
+    if (source_output_count(c, userdata) > 1)
+        return PA_HOOK_OK;
+
     switch_profile_all(c->cards, false, userdata);
     return PA_HOOK_OK;
 }
 
-/* When all source outputs are unlinked, switch profile hsp back back to profile a2dp */
+/* When all source outputs are unlinked, switch to previous profile */
 static pa_hook_result_t source_output_unlink_hook_callback(pa_core *c, pa_source_output *source_output, void *userdata) {
     pa_assert(c);
     pa_assert(source_output);
 
+    pa_log_debug("source_output_unlink_hook_callback called");
+
     if (ignore_output(source_output, userdata))
         return PA_HOOK_OK;
 
@@ -290,30 +326,16 @@ static pa_hook_result_t source_output_unlink_hook_callback(pa_core *c, pa_source
 }
 
 static pa_hook_result_t card_init_profile_hook_callback(pa_core *c, pa_card *card, void *userdata) {
-    struct userdata *u = userdata;
-    const char *s;
-
     pa_assert(c);
     pa_assert(card);
 
+    /* If there are no source outputs do nothing */
     if (source_output_count(c, userdata) == 0)
         return PA_HOOK_OK;
 
-    /* Only consider bluetooth cards */
-    s = pa_proplist_gets(card->proplist, PA_PROP_DEVICE_BUS);
-    if (!s || !pa_streq(s, "bluetooth"))
-        return PA_HOOK_OK;
-
-    /* Ignore card if has already set other initial profile than a2dp */
-    if (card->active_profile &&
-        !pa_streq(card->active_profile->name, "a2dp_sink"))
-        return PA_HOOK_OK;
-
-    /* Set initial profile to hsp */
-    card_set_profile(u, card, false);
+    /* Set initial profile to some with source */
+    switch_profile(card, false, userdata);
 
-    /* Flag this card for will_need_revert */
-    pa_hashmap_put(u->will_need_revert_card_map, card, PA_INT_TO_PTR(1));
     return PA_HOOK_OK;
 }
 
@@ -357,8 +379,8 @@ static pa_hook_result_t profile_available_hook_callback(pa_core *c, pa_card_prof
     if (!s || !pa_streq(s, "bluetooth"))
         return PA_HOOK_OK;
 
-    /* Do not automatically switch profiles for headsets, just in case */
-    if (pa_streq(profile->name, "a2dp_sink") || pa_streq(profile->name, "headset_head_unit"))
+    /* Only consider A2DP sources and auto gateways */
+    if (!pa_startswith(profile->name, "a2dp_source") && !pa_streq(s, "headset_audio_gateway") && !pa_streq(s, "handsfree_audio_gateway"))
         return PA_HOOK_OK;
 
     is_active_profile = card->active_profile == profile;
@@ -383,8 +405,7 @@ static pa_hook_result_t profile_available_hook_callback(pa_core *c, pa_card_prof
 
     pa_log_debug("Setting card '%s' to profile '%s'", card->name, selected_profile->name);
 
-    if (pa_card_set_profile(card, selected_profile, false) != 0)
-        pa_log_warn("Could not set profile '%s'", selected_profile->name);
+    pa_card_set_profile(card, selected_profile, false);
 
     return PA_HOOK_OK;
 }
@@ -446,7 +467,7 @@ int pa__init(pa_module *m) {
         goto fail;
     }
 
-    u->will_need_revert_card_map = pa_hashmap_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
+    u->profile_switch_map = pa_hashmap_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
 
     u->source_put_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SOURCE_PUT], PA_HOOK_NORMAL,
                                          (pa_hook_cb_t) source_put_hook_callback, u);
@@ -511,7 +532,7 @@ void pa__done(pa_module *m) {
     if (u->profile_available_changed_slot)
         pa_hook_slot_free(u->profile_available_changed_slot);
 
-    pa_hashmap_free(u->will_need_revert_card_map);
+    pa_hashmap_free(u->profile_switch_map);
 
     pa_xfree(u);
 }
diff --git a/src/modules/bluetooth/module-bluez5-device.c b/src/modules/bluetooth/module-bluez5-device.c
index 402053a59..ab3cc1cd7 100644
--- a/src/modules/bluetooth/module-bluez5-device.c
+++ b/src/modules/bluetooth/module-bluez5-device.c
@@ -54,19 +54,15 @@ PA_MODULE_AUTHOR("João Paulo Rechi Vita");
 PA_MODULE_DESCRIPTION("BlueZ 5 Bluetooth audio sink and source");
 PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(false);
-PA_MODULE_USAGE("path=<device object path>"
-                "autodetect_mtu=<boolean>");
+PA_MODULE_USAGE("path=<device object path>");
 
 #define FIXED_LATENCY_PLAYBACK_A2DP (25 * PA_USEC_PER_MSEC)
 #define FIXED_LATENCY_PLAYBACK_SCO  (25 * PA_USEC_PER_MSEC)
 #define FIXED_LATENCY_RECORD_A2DP   (25 * PA_USEC_PER_MSEC)
 #define FIXED_LATENCY_RECORD_SCO    (25 * PA_USEC_PER_MSEC)
 
-#define HSP_MAX_GAIN 15
-
 static const char* const valid_modargs[] = {
     "path",
-    "autodetect_mtu",
     NULL
 };
 
@@ -97,9 +93,10 @@ struct userdata {
     pa_core *core;
 
     pa_hook_slot *device_connection_changed_slot;
+    pa_hook_slot *profile_connection_changed_slot;
     pa_hook_slot *transport_state_changed_slot;
-    pa_hook_slot *transport_speaker_gain_changed_slot;
-    pa_hook_slot *transport_microphone_gain_changed_slot;
+    pa_hook_slot *transport_rx_volume_gain_changed_slot;
+    pa_hook_slot *transport_tx_volume_gain_changed_slot;
 
     pa_bluetooth_discovery *discovery;
     pa_bluetooth_device *device;
@@ -131,15 +128,16 @@ struct userdata {
     pa_usec_t started_at;
     pa_smoother *read_smoother;
     pa_memchunk write_memchunk;
-
-    const pa_a2dp_codec *a2dp_codec;
+    bool support_a2dp_codec_switch;
 
     void *encoder_info;
+    void *encoder_backchannel_info;
     pa_sample_spec encoder_sample_spec;
     void *encoder_buffer;                        /* Codec transfer buffer */
     size_t encoder_buffer_size;                  /* Size of the buffer */
 
     void *decoder_info;
+    void *decoder_backchannel_info;
     pa_sample_spec decoder_sample_spec;
     void *decoder_buffer;                        /* Codec transfer buffer */
     size_t decoder_buffer_size;                  /* Size of the buffer */
@@ -253,8 +251,10 @@ static int sco_process_render(struct userdata *u) {
     int saved_errno;
 
     pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT ||
-                u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
+    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT ||
+              u->profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT ||
+              u->profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY ||
+              u->profile == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY);
     pa_assert(u->sink);
 
     pa_sink_render_full(u->sink, u->write_block_size, &memchunk);
@@ -323,8 +323,10 @@ static int sco_process_push(struct userdata *u) {
     pa_usec_t tstamp = 0;
 
     pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT ||
-                u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY);
+    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT ||
+              u->profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT ||
+              u->profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY ||
+              u->profile == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY);
     pa_assert(u->source);
     pa_assert(u->read_smoother);
 
@@ -501,14 +503,15 @@ static int a2dp_write_buffer(struct userdata *u, size_t nbytes) {
 
 /* Run from IO thread */
 static int a2dp_process_render(struct userdata *u) {
+    const pa_a2dp_codec *a2dp_codec;
     const uint8_t *ptr;
     size_t processed;
     size_t length;
 
     pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK);
     pa_assert(u->sink);
-    pa_assert(u->a2dp_codec);
+
+    a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(u->profile);
 
     /* First, render some data */
     if (!u->write_memchunk.memblock)
@@ -521,7 +524,7 @@ static int a2dp_process_render(struct userdata *u) {
     /* Try to create a packet of the full MTU */
     ptr = (const uint8_t *) pa_memblock_acquire_chunk(&u->write_memchunk);
 
-    length = u->a2dp_codec->encode_buffer(u->encoder_info, u->write_index / pa_frame_size(&u->encoder_sample_spec), ptr, u->write_memchunk.length, u->encoder_buffer, u->encoder_buffer_size, &processed);
+    length = a2dp_codec->encode_buffer(pa_bluetooth_profile_is_a2dp_sink(u->profile) ? u->encoder_info : u->encoder_backchannel_info, u->write_index / pa_frame_size(&u->encoder_sample_spec), ptr, u->write_memchunk.length, u->encoder_buffer, u->encoder_buffer_size, &processed);
 
     pa_memblock_release(u->write_memchunk.memblock);
 
@@ -535,14 +538,15 @@ static int a2dp_process_render(struct userdata *u) {
 
 /* Run from IO thread */
 static int a2dp_process_push(struct userdata *u) {
+    const pa_a2dp_codec *a2dp_codec;
     int ret = 0;
     pa_memchunk memchunk;
 
     pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE);
     pa_assert(u->source);
     pa_assert(u->read_smoother);
-    pa_assert(u->a2dp_codec);
+
+    a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(u->profile);
 
     memchunk.memblock = pa_memblock_new(u->core->mempool, u->read_block_size);
     memchunk.index = memchunk.length = 0;
@@ -613,7 +617,7 @@ static int a2dp_process_push(struct userdata *u) {
         ptr = pa_memblock_acquire(memchunk.memblock);
         memchunk.length = pa_memblock_get_length(memchunk.memblock);
 
-        memchunk.length = u->a2dp_codec->decode_buffer(u->decoder_info, u->decoder_buffer, l, ptr, memchunk.length, &processed);
+        memchunk.length = a2dp_codec->decode_buffer(pa_bluetooth_profile_is_a2dp_source(u->profile) ? u->decoder_info : u->decoder_backchannel_info, u->decoder_buffer, l, ptr, memchunk.length, &processed);
 
         pa_memblock_release(memchunk.memblock);
 
@@ -699,7 +703,7 @@ static void teardown_stream(struct userdata *u) {
     u->stream_setup_done = false;
 }
 
-static int transport_acquire(struct userdata *u, bool optional) {
+static int transport_acquire(struct userdata *u) {
     pa_assert(u->transport);
 
     if (u->transport_acquired)
@@ -707,7 +711,7 @@ static int transport_acquire(struct userdata *u, bool optional) {
 
     pa_log_debug("Acquiring transport %s", u->transport->path);
 
-    u->stream_fd = u->transport->acquire(u->transport, optional, &u->read_link_mtu, &u->write_link_mtu);
+    u->stream_fd = u->transport->acquire(u->transport, &u->read_link_mtu, &u->write_link_mtu);
     if (u->stream_fd < 0)
         return u->stream_fd;
 
@@ -751,7 +755,7 @@ static void transport_release(struct userdata *u) {
 static void handle_sink_block_size_change(struct userdata *u) {
     pa_sink_set_max_request_within_thread(u->sink, u->write_block_size);
     pa_sink_set_fixed_latency_within_thread(u->sink,
-                                            (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK ?
+                                            (pa_bluetooth_profile_is_a2dp(u->profile) ?
                                              FIXED_LATENCY_PLAYBACK_A2DP : FIXED_LATENCY_PLAYBACK_SCO) +
                                             pa_bytes_to_usec(u->write_block_size, &u->encoder_sample_spec));
 
@@ -767,7 +771,10 @@ static void handle_sink_block_size_change(struct userdata *u) {
 
 /* Run from I/O thread */
 static void transport_config_mtu(struct userdata *u) {
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
+    if (u->profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT ||
+        u->profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT ||
+        u->profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY ||
+        u->profile == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY) {
         u->read_block_size = u->read_link_mtu;
         u->write_block_size = u->write_link_mtu;
 
@@ -781,11 +788,15 @@ static void transport_config_mtu(struct userdata *u) {
             u->write_block_size = pa_frame_align(u->write_block_size, &u->sink->sample_spec);
         }
     } else {
-        pa_assert(u->a2dp_codec);
-        if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
-            u->write_block_size = u->a2dp_codec->get_write_block_size(u->encoder_info, u->write_link_mtu);
+        const pa_a2dp_codec *a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(u->profile);
+        if (pa_bluetooth_profile_is_a2dp_sink(u->profile)) {
+            u->write_block_size = a2dp_codec->get_write_block_size(u->encoder_info, u->write_link_mtu);
+            if (u->source)
+                u->read_block_size = a2dp_codec->get_read_block_size(u->decoder_backchannel_info, u->read_link_mtu);
         } else {
-            u->read_block_size = u->a2dp_codec->get_read_block_size(u->decoder_info, u->read_link_mtu);
+            u->read_block_size = a2dp_codec->get_read_block_size(u->decoder_info, u->read_link_mtu);
+            if (u->sink)
+                u->write_block_size = a2dp_codec->get_write_block_size(u->encoder_backchannel_info, u->write_link_mtu);
         }
     }
 
@@ -794,13 +805,14 @@ static void transport_config_mtu(struct userdata *u) {
 
     if (u->source)
         pa_source_set_fixed_latency_within_thread(u->source,
-                                                  (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE ?
+                                                  (pa_bluetooth_profile_is_a2dp(u->profile) ?
                                                    FIXED_LATENCY_RECORD_A2DP : FIXED_LATENCY_RECORD_SCO) +
                                                   pa_bytes_to_usec(u->read_block_size, &u->decoder_sample_spec));
 }
 
 /* Run from I/O thread */
 static int setup_stream(struct userdata *u) {
+    const pa_a2dp_codec *a2dp_codec;
     struct pollfd *pollfd;
     int one;
 
@@ -812,14 +824,23 @@ static int setup_stream(struct userdata *u) {
 
     pa_log_info("Transport %s resuming", u->transport->path);
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
-        pa_assert(u->a2dp_codec);
-        if (u->a2dp_codec->reset(u->encoder_info) < 0)
-            return -1;
-    } else if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE) {
-        pa_assert(u->a2dp_codec);
-        if (u->a2dp_codec->reset(u->decoder_info) < 0)
-            return -1;
+    if (pa_bluetooth_profile_is_a2dp(u->profile)) {
+        a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(u->profile);
+        if (pa_bluetooth_profile_is_a2dp_sink(u->profile)) {
+            if (a2dp_codec->reset(u->encoder_info) < 0)
+                return -1;
+            if (u->source) {
+                if (a2dp_codec->reset(u->decoder_backchannel_info) < 0)
+                    return -1;
+            }
+        } else {
+            if (a2dp_codec->reset(u->decoder_info) < 0)
+                return -1;
+            if (u->sink) {
+                if (a2dp_codec->reset(u->encoder_backchannel_info) < 0)
+                    return -1;
+            }
+        }
     }
 
     transport_config_mtu(u);
@@ -853,7 +874,7 @@ static int setup_stream(struct userdata *u) {
 static bool setup_transport_and_stream(struct userdata *u) {
     int transport_error;
 
-    transport_error = transport_acquire(u, false);
+    transport_error = transport_acquire(u);
     if (transport_error < 0) {
         if (transport_error != -EAGAIN)
             return false;
@@ -967,35 +988,33 @@ static void source_set_volume_cb(pa_source *s) {
     pa_assert(u);
     pa_assert(u->source == s);
 
-    if (u->transport->set_microphone_gain == NULL)
-      return;
-
-    gain = (pa_cvolume_max(&s->real_volume) * HSP_MAX_GAIN) / PA_VOLUME_NORM;
-
-    if (gain > HSP_MAX_GAIN)
-        gain = HSP_MAX_GAIN;
-
-    volume = (pa_volume_t) (gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
-
-    /* increment volume by one to correct rounding errors */
-    if (volume < PA_VOLUME_NORM)
-        volume++;
+    volume = pa_cvolume_max(&s->real_volume);
+    gain = (volume * u->transport->max_rx_volume_gain + PA_VOLUME_NORM / 2) / PA_VOLUME_NORM;
 
-    pa_cvolume_set(&s->real_volume, u->decoder_sample_spec.channels, volume);
+    if (gain > u->transport->max_rx_volume_gain) {
+        gain = u->transport->max_rx_volume_gain;
 
-    /* Set soft volume when in headset role */
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
+        /* Requested volume is above maximum, always set soft volume */
         pa_cvolume_set(&s->soft_volume, u->decoder_sample_spec.channels, volume);
+    } else {
+        volume = (pa_volume_t) ((gain * PA_VOLUME_NORM + u->transport->max_rx_volume_gain / 2) / u->transport->max_rx_volume_gain);
+        pa_cvolume_set(&s->real_volume, u->decoder_sample_spec.channels, volume);
+
+        /* Set soft volume when transport requires it, otherwise reset soft volume to default */
+        if (u->transport->rx_soft_volume)
+            pa_cvolume_set(&s->soft_volume, u->decoder_sample_spec.channels, volume);
+        else
+            pa_cvolume_reset(&s->soft_volume, u->decoder_sample_spec.channels);
+    }
 
-    /* If we are in the AG role, we send a command to the head set to change
-     * the microphone gain. In the HS role, source and sink are swapped, so
-     * in this case we notify the AG that the speaker gain has changed */
-    u->transport->set_microphone_gain(u->transport, gain);
+    if (u->transport->set_rx_volume_gain)
+        u->transport->set_rx_volume_gain(u->transport, gain);
 }
 
 /* Run from main thread */
 static int add_source(struct userdata *u) {
     pa_source_new_data data;
+    pa_card_profile *cp;
 
     pa_assert(u->transport);
 
@@ -1007,30 +1026,16 @@ static int add_source(struct userdata *u) {
     data.namereg_fail = false;
     pa_proplist_sets(data.proplist, "bluetooth.protocol", pa_bluetooth_profile_to_string(u->profile));
     pa_source_new_data_set_sample_spec(&data, &u->decoder_sample_spec);
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
+    if (u->profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT)
         pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "phone");
 
+    pa_assert_se(cp = pa_hashmap_get(u->card->profiles, pa_bluetooth_profile_to_string(u->profile)));
+    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_DESCRIPTION, "%s - %s", pa_proplist_gets(u->card->proplist, PA_PROP_DEVICE_DESCRIPTION), cp->description);
+
     connect_ports(u, &data, PA_DIRECTION_INPUT);
 
     if (!u->transport_acquired)
-        switch (u->profile) {
-            case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-            case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
-                data.suspend_cause = PA_SUSPEND_USER;
-                break;
-            case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
-                /* u->stream_fd contains the error returned by the last transport_acquire()
-                 * EAGAIN means we are waiting for a NewConnection signal */
-                if (u->stream_fd == -EAGAIN)
-                    data.suspend_cause = PA_SUSPEND_USER;
-                else
-                    pa_assert_not_reached();
-                break;
-            case PA_BLUETOOTH_PROFILE_A2DP_SINK:
-            case PA_BLUETOOTH_PROFILE_OFF:
-                pa_assert_not_reached();
-                break;
-        }
+        data.suspend_cause = PA_SUSPEND_USER;
 
     u->source = pa_source_new(u->core, &data, PA_SOURCE_HARDWARE|PA_SOURCE_LATENCY);
     pa_source_new_data_done(&data);
@@ -1043,10 +1048,8 @@ static int add_source(struct userdata *u) {
     u->source->parent.process_msg = source_process_msg;
     u->source->set_state_in_io_thread = source_set_state_in_io_thread_cb;
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        pa_source_set_set_volume_callback(u->source, source_set_volume_cb);
-        u->source->n_volume_steps = 16;
-    }
+    pa_source_set_set_volume_callback(u->source, source_set_volume_cb);
+    u->source->n_volume_steps = u->transport->max_rx_volume_gain + 1;
     return 0;
 }
 
@@ -1062,7 +1065,8 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
         case PA_SINK_MESSAGE_GET_LATENCY: {
             int64_t wi = 0, ri = 0;
 
-            if (u->read_smoother) {
+            /* Do not use read smoother for A2DP sink as it belongs to independent backchannel */
+            if (!pa_bluetooth_profile_is_a2dp(u->profile) && u->read_smoother) {
                 ri = pa_smoother_get(u->read_smoother, pa_rtclock_now());
                 wi = pa_bytes_to_usec(u->write_index + u->write_block_size, &u->encoder_sample_spec);
             } else if (u->started_at) {
@@ -1151,35 +1155,33 @@ static void sink_set_volume_cb(pa_sink *s) {
     pa_assert(u);
     pa_assert(u->sink == s);
 
-    if (u->transport->set_speaker_gain == NULL)
-      return;
-
-    gain = (pa_cvolume_max(&s->real_volume) * HSP_MAX_GAIN) / PA_VOLUME_NORM;
+    volume = pa_cvolume_max(&s->real_volume);
+    gain = (volume * u->transport->max_tx_volume_gain + PA_VOLUME_NORM / 2) / PA_VOLUME_NORM;
 
-    if (gain > HSP_MAX_GAIN)
-        gain = HSP_MAX_GAIN;
+    if (gain > u->transport->max_tx_volume_gain) {
+        gain = u->transport->max_tx_volume_gain;
 
-    volume = (pa_volume_t) (gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
-
-    /* increment volume by one to correct rounding errors */
-    if (volume < PA_VOLUME_NORM)
-        volume++;
-
-    pa_cvolume_set(&s->real_volume, u->encoder_sample_spec.channels, volume);
-
-    /* Set soft volume when in headset role */
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
+        /* Requested volume is above maximum, always set soft volume */
         pa_cvolume_set(&s->soft_volume, u->encoder_sample_spec.channels, volume);
+    } else {
+        volume = (pa_volume_t) ((gain * PA_VOLUME_NORM + u->transport->max_tx_volume_gain / 2) / u->transport->max_tx_volume_gain);
+        pa_cvolume_set(&s->real_volume, u->encoder_sample_spec.channels, volume);
 
-    /* If we are in the AG role, we send a command to the head set to change
-     * the speaker gain. In the HS role, source and sink are swapped, so
-     * in this case we notify the AG that the microphone gain has changed */
-    u->transport->set_speaker_gain(u->transport, gain);
+        /* Set soft volume when transport requires it, otherwise reset soft volume to default */
+        if (u->transport->tx_soft_volume)
+            pa_cvolume_set(&s->soft_volume, u->encoder_sample_spec.channels, volume);
+        else
+            pa_cvolume_reset(&s->soft_volume, u->encoder_sample_spec.channels);
+    }
+
+    if (u->transport->set_tx_volume_gain)
+        u->transport->set_tx_volume_gain(u->transport, gain);
 }
 
 /* Run from main thread */
 static int add_sink(struct userdata *u) {
     pa_sink_new_data data;
+    pa_card_profile *cp;
 
     pa_assert(u->transport);
 
@@ -1191,31 +1193,16 @@ static int add_sink(struct userdata *u) {
     data.namereg_fail = false;
     pa_proplist_sets(data.proplist, "bluetooth.protocol", pa_bluetooth_profile_to_string(u->profile));
     pa_sink_new_data_set_sample_spec(&data, &u->encoder_sample_spec);
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
+    if (u->profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT)
         pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "phone");
 
+    pa_assert_se(cp = pa_hashmap_get(u->card->profiles, pa_bluetooth_profile_to_string(u->profile)));
+    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_DESCRIPTION, "%s - %s", pa_proplist_gets(u->card->proplist, PA_PROP_DEVICE_DESCRIPTION), cp->description);
+
     connect_ports(u, &data, PA_DIRECTION_OUTPUT);
 
     if (!u->transport_acquired)
-        switch (u->profile) {
-            case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
-                data.suspend_cause = PA_SUSPEND_USER;
-                break;
-            case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
-                /* u->stream_fd contains the error returned by the last transport_acquire()
-                 * EAGAIN means we are waiting for a NewConnection signal */
-                if (u->stream_fd == -EAGAIN)
-                    data.suspend_cause = PA_SUSPEND_USER;
-                else
-                    pa_assert_not_reached();
-                break;
-            case PA_BLUETOOTH_PROFILE_A2DP_SINK:
-                /* Profile switch should have failed */
-            case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-            case PA_BLUETOOTH_PROFILE_OFF:
-                pa_assert_not_reached();
-                break;
-        }
+        data.suspend_cause = PA_SUSPEND_USER;
 
     u->sink = pa_sink_new(u->core, &data, PA_SINK_HARDWARE|PA_SINK_LATENCY);
     pa_sink_new_data_done(&data);
@@ -1228,16 +1215,17 @@ static int add_sink(struct userdata *u) {
     u->sink->parent.process_msg = sink_process_msg;
     u->sink->set_state_in_io_thread = sink_set_state_in_io_thread_cb;
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        pa_sink_set_set_volume_callback(u->sink, sink_set_volume_cb);
-        u->sink->n_volume_steps = 16;
-    }
+    pa_sink_set_set_volume_callback(u->sink, sink_set_volume_cb);
+    u->sink->n_volume_steps = u->transport->max_tx_volume_gain + 1;
     return 0;
 }
 
 /* Run from main thread */
 static int transport_config(struct userdata *u) {
-    if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
+    if (u->profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT ||
+        u->profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT ||
+        u->profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY ||
+        u->profile == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY) {
         u->encoder_sample_spec.format = PA_SAMPLE_S16LE;
         u->encoder_sample_spec.channels = 1;
         u->encoder_sample_spec.rate = 8000;
@@ -1246,19 +1234,18 @@ static int transport_config(struct userdata *u) {
         u->decoder_sample_spec.rate = 8000;
         return 0;
     } else {
-        bool is_a2dp_sink = u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK;
+        const pa_a2dp_codec *a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(u->profile);
+        bool is_a2dp_sink = pa_bluetooth_profile_is_a2dp_sink(u->profile);
         void *info;
 
         pa_assert(u->transport);
 
-        pa_assert(!u->a2dp_codec);
         pa_assert(!u->encoder_info);
         pa_assert(!u->decoder_info);
+        pa_assert(!u->encoder_backchannel_info);
+        pa_assert(!u->decoder_backchannel_info);
 
-        u->a2dp_codec = u->transport->a2dp_codec;
-        pa_assert(u->a2dp_codec);
-
-        info = u->a2dp_codec->init(is_a2dp_sink, false, u->transport->config, u->transport->config_size, is_a2dp_sink ? &u->encoder_sample_spec : &u->decoder_sample_spec);
+        info = a2dp_codec->init(is_a2dp_sink, false, u->transport->config, u->transport->config_size, is_a2dp_sink ? &u->encoder_sample_spec : &u->decoder_sample_spec);
         if (is_a2dp_sink)
             u->encoder_info = info;
         else
@@ -1267,6 +1254,25 @@ static int transport_config(struct userdata *u) {
         if (!info)
             return -1;
 
+        if (a2dp_codec->support_backchannel) {
+            info = a2dp_codec->init(!is_a2dp_sink, true, u->transport->config, u->transport->config_size, !is_a2dp_sink ? &u->encoder_sample_spec : &u->decoder_sample_spec);
+            if (is_a2dp_sink)
+                u->decoder_backchannel_info = info;
+            else
+                u->encoder_backchannel_info = info;
+
+            if (!info) {
+                if (is_a2dp_sink) {
+                    a2dp_codec->deinit(u->encoder_info);
+                    u->encoder_info = NULL;
+                } else {
+                    a2dp_codec->deinit(u->decoder_info);
+                    u->decoder_info = NULL;
+                }
+                return -1;
+            }
+        }
+
         return 0;
     }
 }
@@ -1274,6 +1280,7 @@ static int transport_config(struct userdata *u) {
 /* Run from main thread */
 static int setup_transport(struct userdata *u) {
     pa_bluetooth_transport *t;
+    int transport_error;
 
     pa_assert(u);
     pa_assert(!u->transport);
@@ -1288,30 +1295,35 @@ static int setup_transport(struct userdata *u) {
 
     u->transport = t;
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
-        transport_acquire(u, true); /* In case of error, the sink/sources will be created suspended */
-    else {
-        int transport_error;
-
-        transport_error = transport_acquire(u, false);
-        if (transport_error < 0 && transport_error != -EAGAIN)
-            return -1; /* We need to fail here until the interactions with module-suspend-on-idle and alike get improved */
-    }
+    transport_error = transport_acquire(u);
+    if (transport_error < 0 && transport_error != -EAGAIN)
+        return -1; /* We need to fail here until the interactions with module-suspend-on-idle and alike get improved */
+    /* When transport_error is -EAGAIN then the sink/sources will be created suspended */
 
     return transport_config(u);
 }
 
 /* Run from main thread */
 static pa_direction_t get_profile_direction(pa_bluetooth_profile_t p) {
-    static const pa_direction_t profile_direction[] = {
-        [PA_BLUETOOTH_PROFILE_A2DP_SINK] = PA_DIRECTION_OUTPUT,
-        [PA_BLUETOOTH_PROFILE_A2DP_SOURCE] = PA_DIRECTION_INPUT,
-        [PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
-        [PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
-        [PA_BLUETOOTH_PROFILE_OFF] = 0
-    };
-
-    return profile_direction[p];
+    if (p == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT ||
+        p == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT ||
+        p == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY ||
+        p == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY)
+        return PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT;
+    else if (p == PA_BLUETOOTH_PROFILE_OFF)
+        return 0;
+    else if (pa_bluetooth_profile_is_a2dp_sink(p)) {
+        if (pa_bluetooth_profile_support_a2dp_backchannel(p))
+            return PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT;
+        else
+            return PA_DIRECTION_OUTPUT;
+    } else if (pa_bluetooth_profile_is_a2dp_source(p)) {
+        if (pa_bluetooth_profile_support_a2dp_backchannel(p))
+            return PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT;
+        else
+            return PA_DIRECTION_INPUT;
+    } else
+        pa_assert_not_reached();
 }
 
 /* Run from main thread */
@@ -1320,7 +1332,8 @@ static int init_profile(struct userdata *u) {
     pa_assert(u);
     pa_assert(u->profile != PA_BLUETOOTH_PROFILE_OFF);
 
-    if (setup_transport(u) < 0)
+    r = setup_transport(u);
+    if (r < 0)
         return -1;
 
     pa_assert(u->transport);
@@ -1342,7 +1355,7 @@ static int write_block(struct userdata *u) {
     if (u->write_index <= 0)
         u->started_at = pa_rtclock_now();
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
+    if (pa_bluetooth_profile_is_a2dp(u->profile)) {
         if ((n_written = a2dp_process_render(u)) < 0)
             return -1;
     } else {
@@ -1416,7 +1429,7 @@ static void thread_func(void *userdata) {
                 if (pollfd->revents & POLLIN) {
                     int n_read;
 
-                    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE)
+                    if (pa_bluetooth_profile_is_a2dp(u->profile))
                         n_read = a2dp_process_push(u);
                     else
                         n_read = sco_process_push(u);
@@ -1424,11 +1437,17 @@ static void thread_func(void *userdata) {
                     if (n_read < 0)
                         goto fail;
 
-                    if (have_sink && n_read > 0) {
+                    if (have_sink && n_read > 0 && !pa_bluetooth_profile_is_a2dp(u->profile)) {
                         /* We just read something, so we are supposed to write something, too */
                         bytes_to_write += n_read;
                         blocks_to_write += bytes_to_write / u->write_block_size;
                         bytes_to_write = bytes_to_write % u->write_block_size;
+
+                        /* SCO is synchronous socket, ensure that we do not send more bytes than we received */
+                        if (u->write_block_size != (size_t) n_read && (size_t) n_read <= u->write_link_mtu) {
+                            u->write_block_size = (size_t) n_read;
+                            handle_sink_block_size_change(u);
+                        }
                     }
                 }
             }
@@ -1446,7 +1465,7 @@ static void thread_func(void *userdata) {
 
                 /* If we have a source, we let the source determine the timing
                  * for the sink */
-                if (have_source) {
+                if (have_source && !pa_bluetooth_profile_is_a2dp(u->profile)) {
 
                     if (writable && blocks_to_write > 0) {
                         int result;
@@ -1516,8 +1535,10 @@ static void thread_func(void *userdata) {
                                 skip_bytes -= bytes_to_render;
                             }
 
-                            if (u->write_index > 0 && u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
-                                size_t new_write_block_size = u->a2dp_codec->reduce_encoder_bitrate(u->encoder_info, u->write_link_mtu);
+                            if (u->write_index > 0 && pa_bluetooth_profile_is_a2dp(u->profile)) {
+                                bool is_a2dp_sink = pa_bluetooth_profile_is_a2dp_sink(u->profile);
+                                const pa_a2dp_codec *a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(u->profile);
+                                size_t new_write_block_size = a2dp_codec->reduce_encoder_bitrate(is_a2dp_sink ? u->encoder_info : u->encoder_backchannel_info, u->write_link_mtu);
                                 if (new_write_block_size) {
                                     u->write_block_size = new_write_block_size;
                                     handle_sink_block_size_change(u);
@@ -1621,13 +1642,13 @@ static int start_thread(struct userdata *u) {
 
         /* If we are in the headset role, the sink should not become default
          * unless there is no other sound device available. */
-        if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
+        if (u->profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY || u->profile == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY)
             u->sink->priority = 1500;
 
-        pa_sink_put(u->sink);
-
         if (u->sink->set_volume)
             u->sink->set_volume(u->sink);
+
+        pa_sink_put(u->sink);
     }
 
     if (u->source) {
@@ -1637,13 +1658,13 @@ static int start_thread(struct userdata *u) {
         /* If we are in the headset role or the device is an a2dp source,
          * the source should not become default unless there is no other
          * sound device available. */
-        if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY || u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE)
+        if (u->profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY || u->profile == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY || pa_bluetooth_profile_is_a2dp_source(u->profile))
             u->source->priority = 1500;
 
-        pa_source_put(u->source);
-
         if (u->source->set_volume)
             u->source->set_volume(u->source);
+
+        pa_source_put(u->source);
     }
 
     return 0;
@@ -1651,6 +1672,8 @@ static int start_thread(struct userdata *u) {
 
 /* Run from main thread */
 static void stop_thread(struct userdata *u) {
+    const pa_a2dp_codec *a2dp_codec;
+
     pa_assert(u);
 
     if (u->sink)
@@ -1696,30 +1719,41 @@ static void stop_thread(struct userdata *u) {
         u->read_smoother = NULL;
     }
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK || u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE) {
+    if (pa_bluetooth_profile_is_a2dp(u->profile)) {
+        a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(u->profile);
+
         if (u->encoder_info) {
-            u->a2dp_codec->deinit(u->encoder_info);
+            a2dp_codec->deinit(u->encoder_info);
             u->encoder_info = NULL;
         }
 
         if (u->decoder_info) {
-            u->a2dp_codec->deinit(u->decoder_info);
+            a2dp_codec->deinit(u->decoder_info);
             u->decoder_info = NULL;
         }
 
-        u->a2dp_codec = NULL;
+        if (u->decoder_backchannel_info) {
+            a2dp_codec->deinit(u->decoder_backchannel_info);
+            u->decoder_backchannel_info = NULL;
+        }
+
+        if (u->encoder_backchannel_info) {
+            a2dp_codec->deinit(u->encoder_backchannel_info);
+            u->encoder_backchannel_info = NULL;
+        }
     }
 }
 
 /* Run from main thread */
 static pa_available_t get_port_availability(struct userdata *u, pa_direction_t direction) {
     pa_available_t result = PA_AVAILABLE_NO;
-    unsigned i;
+    unsigned i, count;
 
     pa_assert(u);
     pa_assert(u->device);
 
-    for (i = 0; i < PA_BLUETOOTH_PROFILE_COUNT; i++) {
+    count = pa_bluetooth_profile_count();
+    for (i = 0; i < count; i++) {
         pa_bluetooth_transport *transport;
 
         if (!(get_profile_direction(i) & direction))
@@ -1863,8 +1897,12 @@ static void create_card_ports(struct userdata *u, pa_hashmap *ports) {
 static pa_card_profile *create_card_profile(struct userdata *u, pa_bluetooth_profile_t profile, pa_hashmap *ports) {
     pa_device_port *input_port, *output_port;
     const char *name;
+    char *description;
     pa_card_profile *cp = NULL;
     pa_bluetooth_profile_t *p;
+    const pa_a2dp_codec *a2dp_codec;
+    bool is_a2dp_sink;
+    bool support_backchannel;
 
     pa_assert(u->input_port_name);
     pa_assert(u->output_port_name);
@@ -1873,34 +1911,20 @@ static pa_card_profile *create_card_profile(struct userdata *u, pa_bluetooth_pro
 
     name = pa_bluetooth_profile_to_string(profile);
 
-    switch (profile) {
-    case PA_BLUETOOTH_PROFILE_A2DP_SINK:
-        cp = pa_card_profile_new(name, _("High Fidelity Playback (A2DP Sink)"), sizeof(pa_bluetooth_profile_t));
-        cp->priority = 40;
-        cp->n_sinks = 1;
-        cp->n_sources = 0;
-        cp->max_sink_channels = 2;
-        cp->max_source_channels = 0;
-        pa_hashmap_put(output_port->profiles, cp->name, cp);
-
-        p = PA_CARD_PROFILE_DATA(cp);
-        break;
-
-    case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-        cp = pa_card_profile_new(name, _("High Fidelity Capture (A2DP Source)"), sizeof(pa_bluetooth_profile_t));
-        cp->priority = 20;
-        cp->n_sinks = 0;
-        cp->n_sources = 1;
-        cp->max_sink_channels = 0;
-        cp->max_source_channels = 2;
-        pa_hashmap_put(input_port->profiles, cp->name, cp);
-
-        p = PA_CARD_PROFILE_DATA(cp);
-        break;
-
-    case PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT:
-        cp = pa_card_profile_new(name, _("Headset Head Unit (HSP/HFP)"), sizeof(pa_bluetooth_profile_t));
-        cp->priority = 30;
+    if (profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT ||
+        profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT ||
+        profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY ||
+        profile == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY) {
+        if (profile == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT)
+            description = _("Headset Head Unit (HSP)");
+        else if (profile == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT)
+            description = _("Headset Head Unit (HFP)");
+        else if (profile == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY)
+            description = _("Headset Audio Gateway (HSP)");
+        else
+            description = _("Headset Audio Gateway (HFP)");
+        cp = pa_card_profile_new(name, description, sizeof(*cp));
+        cp->priority = profile;
         cp->n_sinks = 1;
         cp->n_sources = 1;
         cp->max_sink_channels = 1;
@@ -1909,22 +1933,41 @@ static pa_card_profile *create_card_profile(struct userdata *u, pa_bluetooth_pro
         pa_hashmap_put(output_port->profiles, cp->name, cp);
 
         p = PA_CARD_PROFILE_DATA(cp);
-        break;
+    } else if (pa_bluetooth_profile_is_a2dp(profile)) {
+        a2dp_codec = pa_bluetooth_profile_to_a2dp_codec(profile);
+        is_a2dp_sink = pa_bluetooth_profile_is_a2dp_sink(profile);
+        support_backchannel = pa_bluetooth_profile_support_a2dp_backchannel(profile);
 
-    case PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY:
-        cp = pa_card_profile_new(name, _("Headset Audio Gateway (HSP/HFP)"), sizeof(pa_bluetooth_profile_t));
-        cp->priority = 10;
-        cp->n_sinks = 1;
-        cp->n_sources = 1;
-        cp->max_sink_channels = 1;
-        cp->max_source_channels = 1;
-        pa_hashmap_put(input_port->profiles, cp->name, cp);
-        pa_hashmap_put(output_port->profiles, cp->name, cp);
+        if (is_a2dp_sink)
+            description = pa_sprintf_malloc(_("High Fidelity Playback (A2DP Sink) with codec %s"), a2dp_codec->description);
+        else
+            description = pa_sprintf_malloc(_("High Fidelity Capture (A2DP Source) with codec %s"), a2dp_codec->description);
 
-        p = PA_CARD_PROFILE_DATA(cp);
-        break;
+        cp = pa_card_profile_new(name, description, sizeof(*cp));
+        pa_xfree(description);
+
+        cp->priority = profile;
 
-    case PA_BLUETOOTH_PROFILE_OFF:
+        if (is_a2dp_sink) {
+            cp->n_sinks = 1;
+            cp->n_sources = support_backchannel ? 1 : 0;
+            cp->max_sink_channels = 2;
+            cp->max_source_channels = support_backchannel ? 1 : 0;
+        } else {
+            cp->n_sinks = support_backchannel ? 1 : 0;
+            cp->n_sources = 1;
+            cp->max_sink_channels = support_backchannel ? 1 : 0;
+            cp->max_source_channels = 2;
+        }
+
+        if (is_a2dp_sink || support_backchannel)
+            pa_hashmap_put(output_port->profiles, cp->name, cp);
+
+        if (!is_a2dp_sink || support_backchannel)
+            pa_hashmap_put(input_port->profiles, cp->name, cp);
+
+        p = PA_CARD_PROFILE_DATA(cp);
+    } else {
         pa_assert_not_reached();
     }
 
@@ -1935,6 +1978,12 @@ static pa_card_profile *create_card_profile(struct userdata *u, pa_bluetooth_pro
     else
         cp->available = PA_AVAILABLE_NO;
 
+    if (cp->available == PA_AVAILABLE_NO && u->support_a2dp_codec_switch &&
+        (u->device->new_profile_in_progress ||
+         (pa_bluetooth_profile_is_a2dp_sink(profile) && pa_bluetooth_device_a2dp_sink_transport_connected(u->device)) ||
+         (pa_bluetooth_profile_is_a2dp_source(profile) && pa_bluetooth_device_a2dp_source_transport_connected(u->device))))
+        cp->available = PA_AVAILABLE_UNKNOWN;
+
     return cp;
 }
 
@@ -1950,10 +1999,27 @@ static int set_profile_cb(pa_card *c, pa_card_profile *new_profile) {
     p = PA_CARD_PROFILE_DATA(new_profile);
 
     if (*p != PA_BLUETOOTH_PROFILE_OFF) {
-        const pa_bluetooth_device *d = u->device;
+        pa_bluetooth_device *d = u->device;
+
+        d->new_profile_in_progress = 0;
 
         if (!d->transports[*p] || d->transports[*p]->state <= PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED) {
-            pa_log_warn("Refused to switch profile to %s: Not connected", new_profile->name);
+            if (pa_bluetooth_profile_is_a2dp(*p) && u->support_a2dp_codec_switch) {
+                if ((pa_bluetooth_profile_is_a2dp_sink(*p) && pa_bluetooth_device_a2dp_sink_transport_connected(d)) ||
+                    (pa_bluetooth_profile_is_a2dp_source(*p) && pa_bluetooth_device_a2dp_source_transport_connected(d))) {
+                    pa_log_info("Profile with different A2DP codec is in use, trying to asynchronously change it");
+                    if (!pa_bluetooth_device_change_a2dp_profile(d, *p))
+                        return -PA_ERR_IO;
+                    d->new_profile_in_progress = *p;
+                    /* profile changing is in progress now, return error from callback as new profile is not active yet */
+                    return -PA_ERR_IO;
+                }
+            }
+
+            pa_log_info("Profile %s is not connected yet, trying to asynchronously connect it", new_profile->name);
+            pa_bluetooth_device_connect_profile(d, *p);
+            d->new_profile_in_progress = *p;
+            /* profile changing is in progress now, return error from callback as new profile is not active yet */
             return -PA_ERR_IO;
         }
     }
@@ -1980,19 +2046,58 @@ off:
     return -PA_ERR_IO;
 }
 
-static int uuid_to_profile(const char *uuid, pa_bluetooth_profile_t *_r) {
-    if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK))
-        *_r = PA_BLUETOOTH_PROFILE_A2DP_SINK;
-    else if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE))
-        *_r = PA_BLUETOOTH_PROFILE_A2DP_SOURCE;
-    else if (pa_bluetooth_uuid_is_hsp_hs(uuid) || pa_streq(uuid, PA_BLUETOOTH_UUID_HFP_HF))
-        *_r = PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT;
-    else if (pa_streq(uuid, PA_BLUETOOTH_UUID_HSP_AG) || pa_streq(uuid, PA_BLUETOOTH_UUID_HFP_AG))
-        *_r = PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY;
-    else
-        return -PA_ERR_INVALID;
+static void add_card_profile(pa_bluetooth_profile_t profile, pa_card_new_data *data, struct userdata *u) {
+    pa_card_profile *cp;
 
-    return 0;
+    if (pa_hashmap_get(data->profiles, pa_bluetooth_profile_to_string(profile)))
+        return;
+
+    cp = create_card_profile(u, profile, data->ports);
+    pa_hashmap_put(data->profiles, cp->name, cp);
+}
+
+static void choose_initial_profile(struct userdata *u) {
+    pa_bluetooth_transport *transport;
+    pa_card_profile *iter_profile;
+    pa_card_profile *profile;
+    void *state;
+
+    pa_log_debug("Looking for A2DP profile which has active bluez transport for card %s", u->card->name);
+
+    profile = NULL;
+
+    /* Try to find the best A2DP profile with active transport */
+    PA_HASHMAP_FOREACH(iter_profile, u->card->profiles, state) {
+        transport = u->device->transports[*(pa_bluetooth_profile_t *)PA_CARD_PROFILE_DATA(iter_profile)];
+
+        /* Ignore profiles without active bluez transport */
+        if (!transport || transport->state == PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED)
+            continue;
+
+        /* Ignore non-A2DP profiles */
+        if (!pa_bluetooth_profile_is_a2dp(transport->profile))
+            continue;
+
+        pa_log_debug("%s has active bluez transport", iter_profile->name);
+
+        if (!profile || iter_profile->priority > profile->priority)
+            profile = iter_profile;
+    }
+
+    /* When there is no active A2DP bluez transport, fallback to core pulseaudio function for choosing initial profile */
+    if (!profile) {
+        pa_log_debug("No A2DP profile with bluez active transport was found for card %s", u->card->name);
+        pa_card_choose_initial_profile(u->card);
+        return;
+    }
+
+    /* Do same job as pa_card_choose_initial_profile() */
+    pa_log_info("Setting initial A2DP profile '%s' for card %s", profile->name, u->card->name);
+    u->card->active_profile = profile;
+    u->card->save_profile = false;
+
+    /* Let policy modules override the default. */
+    pa_hook_fire(&u->card->core->hooks[PA_CORE_HOOK_CARD_CHOOSE_INITIAL_PROFILE], u->card);
 }
 
 /* Run from main thread */
@@ -2003,6 +2108,8 @@ static int add_card(struct userdata *u) {
     pa_bluetooth_form_factor_t ff;
     pa_card_profile *cp;
     pa_bluetooth_profile_t *p;
+    bool have_a2dp_sink;
+    bool have_a2dp_source;
     const char *uuid;
     void *state;
 
@@ -2035,22 +2142,76 @@ static int add_card(struct userdata *u) {
 
     create_card_ports(u, data.ports);
 
+    have_a2dp_sink = false;
+    have_a2dp_source = false;
+
     PA_HASHMAP_FOREACH(uuid, d->uuids, state) {
         pa_bluetooth_profile_t profile;
 
-        if (uuid_to_profile(uuid, &profile) < 0)
+        if (pa_bluetooth_uuid_is_hsp_hs(uuid))
+            profile = PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT;
+        else if (pa_streq(uuid, PA_BLUETOOTH_UUID_HFP_HF))
+            profile = PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT;
+        else if (pa_streq(uuid, PA_BLUETOOTH_UUID_HSP_AG))
+            profile = PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY;
+        else if (pa_streq(uuid, PA_BLUETOOTH_UUID_HFP_AG))
+            profile = PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY;
+        else {
+            if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK))
+                have_a2dp_sink = true;
+            else if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE))
+                have_a2dp_source = true;
             continue;
+        }
 
-        if (pa_hashmap_get(data.profiles, pa_bluetooth_profile_to_string(profile)))
-            continue;
+        add_card_profile(profile, &data, u);
+    }
+
+    if (have_a2dp_sink || have_a2dp_source) {
+        if (!d->adapter->media_application_registered) {
+            /*
+             * We are running old version of bluez which does not announce supported codecs
+             * by remote device nor does not support codec switching. Pulseaudio already
+             * registered to bluez only SBC codec, so create only one profile for SBC codec.
+             */
+            pa_log_warn("Detected old bluez version, only SBC codec is supported");
+            u->support_a2dp_codec_switch = false;
+
+            if (have_a2dp_sink)
+                add_card_profile(pa_bluetooth_profile_for_a2dp_codec("sbc", true), &data, u);
+
+            if (have_a2dp_source)
+                add_card_profile(pa_bluetooth_profile_for_a2dp_codec("sbc", false), &data, u);
+        } else {
+            const pa_a2dp_codec *a2dp_codec;
+            pa_bluetooth_profile_t profile;
+            const char *endpoint;
+            unsigned i, count;
 
-        cp = create_card_profile(u, profile, data.ports);
-        pa_hashmap_put(data.profiles, cp->name, cp);
+            u->support_a2dp_codec_switch = true;
+
+            count = pa_bluetooth_a2dp_codec_count();
+            for (i = 0; i < count; i++) {
+                a2dp_codec = pa_bluetooth_a2dp_codec_iter(i);
+
+                if (pa_bluetooth_device_find_a2dp_endpoints_for_codec(d, a2dp_codec, true, &endpoint, 1) > 0) {
+                    profile = pa_bluetooth_profile_for_a2dp_codec(a2dp_codec->name, true);
+                    add_card_profile(profile, &data, u);
+                    pa_log_info("Detected codec %s on sink endpoint %s", a2dp_codec->name, endpoint);
+                }
+
+                if (pa_bluetooth_device_find_a2dp_endpoints_for_codec(d, a2dp_codec, false, &endpoint, 1) > 0) {
+                    profile = pa_bluetooth_profile_for_a2dp_codec(a2dp_codec->name, false);
+                    add_card_profile(profile, &data, u);
+                    pa_log_info("Detected codec %s on source endpoint %s", a2dp_codec->name, endpoint);
+                }
+            }
+        }
     }
 
     pa_assert(!pa_hashmap_isempty(data.profiles));
 
-    cp = pa_card_profile_new("off", _("Off"), sizeof(pa_bluetooth_profile_t));
+    cp = pa_card_profile_new("off", _("Off"), sizeof(*cp));
     cp->available = PA_AVAILABLE_YES;
     p = PA_CARD_PROFILE_DATA(cp);
     *p = PA_BLUETOOTH_PROFILE_OFF;
@@ -2065,7 +2226,7 @@ static int add_card(struct userdata *u) {
 
     u->card->userdata = u;
     u->card->set_profile = set_profile_cb;
-    pa_card_choose_initial_profile(u->card);
+    choose_initial_profile(u);
     pa_card_put(u->card);
 
     p = PA_CARD_PROFILE_DATA(u->card->active_profile);
@@ -2081,13 +2242,49 @@ static void handle_transport_state_change(struct userdata *u, struct pa_bluetoot
     pa_card_profile *cp;
     pa_device_port *port;
     pa_available_t oldavail;
+    pa_available_t newavail;
 
     pa_assert(u);
     pa_assert(t);
-    pa_assert_se(cp = pa_hashmap_get(u->card->profiles, pa_bluetooth_profile_to_string(t->profile)));
+
+    cp = pa_hashmap_get(u->card->profiles, pa_bluetooth_profile_to_string(t->profile));
+    if (!cp) {
+        /* Profile does not exist or associated A2DP codec is not supported, switch to off */
+        pa_assert_se(pa_card_set_profile(u->card, pa_hashmap_get(u->card->profiles, "off"), false) >= 0);
+        return;
+    }
 
     oldavail = cp->available;
-    pa_card_profile_set_available(cp, transport_state_to_availability(t->state));
+
+    newavail = transport_state_to_availability(t->state);
+
+    if (u->support_a2dp_codec_switch && pa_bluetooth_profile_is_a2dp(t->profile)) {
+        pa_card_profile *iter_cp;
+        void *state;
+
+        if (newavail == PA_AVAILABLE_NO &&
+            (u->device->new_profile_in_progress ||
+             (pa_bluetooth_profile_is_a2dp_sink(t->profile) && pa_bluetooth_device_a2dp_sink_transport_connected(u->device)) ||
+             (pa_bluetooth_profile_is_a2dp_source(t->profile) && pa_bluetooth_device_a2dp_source_transport_connected(u->device)))) {
+            newavail = PA_AVAILABLE_UNKNOWN;
+        }
+
+        /* Change availability for other profiles (except current) in same A2DP category (sink / source) */
+        PA_HASHMAP_FOREACH(iter_cp, u->card->profiles, state) {
+            if (cp == iter_cp)
+                continue;
+            if (!pa_startswith(iter_cp->name, "a2dp_"))
+                continue;
+            if (pa_bluetooth_profile_is_a2dp_sink(t->profile) && !pa_startswith(iter_cp->name, "a2dp_sink"))
+                continue;
+            if (pa_bluetooth_profile_is_a2dp_source(t->profile) && !pa_startswith(iter_cp->name, "a2dp_source"))
+                continue;
+            /* Do not set PA_AVAILABLE_YES for other profiles */
+            pa_card_profile_set_available(iter_cp, (newavail == PA_AVAILABLE_YES) ? PA_AVAILABLE_UNKNOWN : newavail);
+        }
+    }
+
+    pa_card_profile_set_available(cp, newavail);
 
     /* Update port availability */
     pa_assert_se(port = pa_hashmap_get(u->card->ports, u->output_port_name));
@@ -2099,7 +2296,7 @@ static void handle_transport_state_change(struct userdata *u, struct pa_bluetoot
     acquire = (t->state == PA_BLUETOOTH_TRANSPORT_STATE_PLAYING && u->profile == t->profile);
     release = (oldavail != PA_AVAILABLE_NO && t->state != PA_BLUETOOTH_TRANSPORT_STATE_PLAYING && u->profile == t->profile);
 
-    if (acquire && transport_acquire(u, true) >= 0) {
+    if (acquire && transport_acquire(u) >= 0) {
         if (u->source) {
             pa_log_debug("Resuming source %s because its transport state changed to playing", u->source->name);
 
@@ -2157,7 +2354,7 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
     pa_assert(d);
     pa_assert(u);
 
-    if (d != u->device || pa_bluetooth_device_any_transport_connected(d))
+    if (d != u->device || pa_bluetooth_device_any_transport_connected(d) || d->new_profile_in_progress)
         return PA_HOOK_OK;
 
     pa_log_debug("Unloading module for device %s", d->path);
@@ -2166,6 +2363,60 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
     return PA_HOOK_OK;
 }
 
+/* Run from main thread */
+static pa_hook_result_t profile_connection_changed_cb(pa_bluetooth_discovery *y, const struct pa_bluetooth_device_and_profile *device_and_profile, struct userdata *u) {
+    const pa_bluetooth_device *d = device_and_profile->device;
+    pa_bluetooth_profile_t p = device_and_profile->profile;
+    pa_bluetooth_status s = device_and_profile->status;
+    pa_bluetooth_transport *t;
+    pa_card_profile *cp;
+
+    pa_assert(d);
+    pa_assert(p);
+    pa_assert(u);
+
+    if (d != u->device || !u->device->new_profile_in_progress)
+        return PA_HOOK_OK;
+
+    pa_assert(p != PA_BLUETOOTH_PROFILE_OFF);
+
+    if (p == u->device->new_profile_in_progress ||
+        (u->support_a2dp_codec_switch &&
+         ((pa_bluetooth_profile_is_a2dp_sink(p) && pa_bluetooth_profile_is_a2dp_sink(u->device->new_profile_in_progress)) ||
+          (pa_bluetooth_profile_is_a2dp_source(p) && pa_bluetooth_profile_is_a2dp_source(u->device->new_profile_in_progress))))) {
+
+        /* Asynchronous operation for profile change finished */
+        u->device->new_profile_in_progress = 0;
+
+        t = u->device->transports[p];
+        if ((t && t->state > PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED) ||
+            (u->support_a2dp_codec_switch &&
+             ((pa_bluetooth_profile_is_a2dp_sink(p) && pa_bluetooth_device_a2dp_sink_transport_connected(u->device)) ||
+              (pa_bluetooth_profile_is_a2dp_source(p) && pa_bluetooth_device_a2dp_source_transport_connected(u->device))))) {
+            /* Activate newly connected profile */
+            pa_assert_se(cp = pa_hashmap_get(u->card->profiles, pa_bluetooth_profile_to_string(p)));
+            pa_card_set_profile(u->card, cp, true);
+        } else if (s != PA_BLUETOOTH_STATUS_NOTAVAILABLE) {
+            /* Some bluetooth headsets do not allow connecting both HSP and HFP profile at the same time
+             * Try to first disconnect one profile and then connect second profile
+             * But do not try it when previous attempt failed with error "NotAvailable", it means hsphfpd or pulseaudio cannot handle that profile */
+            u->device->new_profile_in_progress = p;
+            if (p == PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT && u->device->transports[PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT] && u->device->transports[PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT]->state >= PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED)
+                pa_bluetooth_device_disconnect_and_connect_profile(u->device, PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT, PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT);
+            else if (p == PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT && u->device->transports[PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT] && u->device->transports[PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT]->state >= PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED)
+                pa_bluetooth_device_disconnect_and_connect_profile(u->device, PA_BLUETOOTH_PROFILE_HSP_HEAD_UNIT, PA_BLUETOOTH_PROFILE_HFP_HEAD_UNIT);
+            else if (p == PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY && u->device->transports[PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY] && u->device->transports[PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY]->state >= PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED)
+                pa_bluetooth_device_disconnect_and_connect_profile(u->device, PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY, PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY);
+            else if (p == PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY && u->device->transports[PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY] && u->device->transports[PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY]->state >= PA_BLUETOOTH_TRANSPORT_STATE_DISCONNECTED)
+                pa_bluetooth_device_disconnect_and_connect_profile(u->device, PA_BLUETOOTH_PROFILE_HSP_AUDIO_GATEWAY, PA_BLUETOOTH_PROFILE_HFP_AUDIO_GATEWAY);
+            else
+                u->device->new_profile_in_progress = 0;
+        }
+    }
+
+    return PA_HOOK_OK;
+}
+
 /* Run from main thread */
 static pa_hook_result_t transport_state_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
     pa_assert(t);
@@ -2180,7 +2431,7 @@ static pa_hook_result_t transport_state_changed_cb(pa_bluetooth_discovery *y, pa
     return PA_HOOK_OK;
 }
 
-static pa_hook_result_t transport_speaker_gain_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
+static pa_hook_result_t transport_tx_volume_gain_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
     pa_volume_t volume;
     pa_cvolume v;
     uint16_t gain;
@@ -2191,15 +2442,18 @@ static pa_hook_result_t transport_speaker_gain_changed_cb(pa_bluetooth_discovery
     if (t != u->transport)
       return PA_HOOK_OK;
 
-    gain = t->speaker_gain;
-    volume = (pa_volume_t) (gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
+    if (!u->sink)
+        return PA_HOOK_OK;
+
+    gain = t->tx_volume_gain;
+    volume = (pa_volume_t) ((gain * PA_VOLUME_NORM + t->max_tx_volume_gain / 2) / t->max_tx_volume_gain);
 
-    /* increment volume by one to correct rounding errors */
-    if (volume < PA_VOLUME_NORM)
-        volume++;
+    if (volume > PA_VOLUME_NORM)
+        volume = PA_VOLUME_NORM;
 
     pa_cvolume_set(&v, u->encoder_sample_spec.channels, volume);
-    if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
+
+    if (!t->tx_soft_volume && pa_cvolume_is_norm(&u->sink->soft_volume))
         pa_sink_volume_changed(u->sink, &v);
     else
         pa_sink_set_volume(u->sink, &v, true, true);
@@ -2207,7 +2461,7 @@ static pa_hook_result_t transport_speaker_gain_changed_cb(pa_bluetooth_discovery
     return PA_HOOK_OK;
 }
 
-static pa_hook_result_t transport_microphone_gain_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
+static pa_hook_result_t transport_rx_volume_gain_changed_cb(pa_bluetooth_discovery *y, pa_bluetooth_transport *t, struct userdata *u) {
     pa_volume_t volume;
     pa_cvolume v;
     uint16_t gain;
@@ -2218,16 +2472,18 @@ static pa_hook_result_t transport_microphone_gain_changed_cb(pa_bluetooth_discov
     if (t != u->transport)
       return PA_HOOK_OK;
 
-    gain = t->microphone_gain;
-    volume = (pa_volume_t) (gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
+    if (!u->source)
+        return PA_HOOK_OK;
+
+    gain = t->rx_volume_gain;
+    volume = (pa_volume_t)((gain * PA_VOLUME_NORM + t->max_rx_volume_gain / 2) / t->max_rx_volume_gain);
 
-    /* increment volume by one to correct rounding errors */
-    if (volume < PA_VOLUME_NORM)
-        volume++;
+    if (volume > PA_VOLUME_NORM)
+        volume = PA_VOLUME_NORM;
 
     pa_cvolume_set(&v, u->decoder_sample_spec.channels, volume);
 
-    if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
+    if (!t->rx_soft_volume && pa_cvolume_is_norm(&u->source->soft_volume))
         pa_source_volume_changed(u->source, &v);
     else
         pa_source_set_volume(u->source, &v, true, true);
@@ -2271,7 +2527,6 @@ int pa__init(pa_module* m) {
     struct userdata *u;
     const char *path;
     pa_modargs *ma;
-    bool autodetect_mtu;
 
     pa_assert(m);
 
@@ -2301,29 +2556,25 @@ int pa__init(pa_module* m) {
         goto fail_free_modargs;
     }
 
-    autodetect_mtu = false;
-    if (pa_modargs_get_value_boolean(ma, "autodetect_mtu", &autodetect_mtu) < 0) {
-        pa_log("Invalid boolean value for autodetect_mtu parameter");
-        goto fail_free_modargs;
-    }
-
-    u->device->autodetect_mtu = autodetect_mtu;
-
     pa_modargs_free(ma);
 
     u->device_connection_changed_slot =
         pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_DEVICE_CONNECTION_CHANGED),
                         PA_HOOK_NORMAL, (pa_hook_cb_t) device_connection_changed_cb, u);
 
+    u->profile_connection_changed_slot =
+        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_PROFILE_CONNECTION_CHANGED),
+                        PA_HOOK_NORMAL, (pa_hook_cb_t) profile_connection_changed_cb, u);
+
     u->transport_state_changed_slot =
         pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_STATE_CHANGED),
                         PA_HOOK_NORMAL, (pa_hook_cb_t) transport_state_changed_cb, u);
 
-    u->transport_speaker_gain_changed_slot =
-        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED), PA_HOOK_NORMAL, (pa_hook_cb_t) transport_speaker_gain_changed_cb, u);
+    u->transport_rx_volume_gain_changed_slot =
+        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_RX_VOLUME_GAIN_CHANGED), PA_HOOK_NORMAL, (pa_hook_cb_t) transport_rx_volume_gain_changed_cb, u);
 
-    u->transport_microphone_gain_changed_slot =
-        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED), PA_HOOK_NORMAL, (pa_hook_cb_t) transport_microphone_gain_changed_cb, u);
+    u->transport_tx_volume_gain_changed_slot =
+        pa_hook_connect(pa_bluetooth_discovery_hook(u->discovery, PA_BLUETOOTH_HOOK_TRANSPORT_TX_VOLUME_GAIN_CHANGED), PA_HOOK_NORMAL, (pa_hook_cb_t) transport_tx_volume_gain_changed_cb, u);
 
     if (add_card(u) < 0)
         goto fail;
@@ -2377,14 +2628,17 @@ void pa__done(pa_module *m) {
     if (u->device_connection_changed_slot)
         pa_hook_slot_free(u->device_connection_changed_slot);
 
+    if (u->profile_connection_changed_slot)
+        pa_hook_slot_free(u->profile_connection_changed_slot);
+
     if (u->transport_state_changed_slot)
         pa_hook_slot_free(u->transport_state_changed_slot);
 
-    if (u->transport_speaker_gain_changed_slot)
-        pa_hook_slot_free(u->transport_speaker_gain_changed_slot);
+    if (u->transport_rx_volume_gain_changed_slot)
+        pa_hook_slot_free(u->transport_rx_volume_gain_changed_slot);
 
-    if (u->transport_microphone_gain_changed_slot)
-        pa_hook_slot_free(u->transport_microphone_gain_changed_slot);
+    if (u->transport_tx_volume_gain_changed_slot)
+        pa_hook_slot_free(u->transport_tx_volume_gain_changed_slot);
 
     if (u->encoder_buffer)
         pa_xfree(u->encoder_buffer);
diff --git a/src/modules/bluetooth/module-bluez5-discover.c b/src/modules/bluetooth/module-bluez5-discover.c
index 47b576103..d50e65ef1 100644
--- a/src/modules/bluetooth/module-bluez5-discover.c
+++ b/src/modules/bluetooth/module-bluez5-discover.c
@@ -34,16 +34,6 @@ PA_MODULE_AUTHOR("João Paulo Rechi Vita");
 PA_MODULE_DESCRIPTION("Detect available BlueZ 5 Bluetooth audio devices and load BlueZ 5 Bluetooth audio drivers");
 PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(true);
-PA_MODULE_USAGE(
-    "headset=ofono|native|auto"
-    "autodetect_mtu=<boolean>"
-);
-
-static const char* const valid_modargs[] = {
-    "headset",
-    "autodetect_mtu",
-    NULL
-};
 
 struct userdata {
     pa_module *module;
@@ -51,7 +41,6 @@ struct userdata {
     pa_hashmap *loaded_device_paths;
     pa_hook_slot *device_connection_changed_slot;
     pa_bluetooth_discovery *discovery;
-    bool autodetect_mtu;
 };
 
 static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y, const pa_bluetooth_device *d, struct userdata *u) {
@@ -62,7 +51,8 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
 
     module_loaded = pa_hashmap_get(u->loaded_device_paths, d->path) ? true : false;
 
-    if (module_loaded && !pa_bluetooth_device_any_transport_connected(d)) {
+    /* When changing A2DP profile there is no transport connected, ensure that no module is unloaded */
+    if (module_loaded && !pa_bluetooth_device_any_transport_connected(d) && !d->new_profile_in_progress) {
         /* disconnection, the module unloads itself */
         pa_log_debug("Unregistering module for %s", d->path);
         pa_hashmap_remove(u->loaded_device_paths, d->path);
@@ -72,7 +62,7 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
     if (!module_loaded && pa_bluetooth_device_any_transport_connected(d)) {
         /* a new device has been connected */
         pa_module *m;
-        char *args = pa_sprintf_malloc("path=%s autodetect_mtu=%i", d->path, (int)u->autodetect_mtu);
+        char *args = pa_sprintf_malloc("path=%s", d->path);
 
         pa_log_debug("Loading module-bluez5-device %s", args);
         pa_module_load(&m, u->module->core, "module-bluez5-device", args);
@@ -91,51 +81,23 @@ static pa_hook_result_t device_connection_changed_cb(pa_bluetooth_discovery *y,
     return PA_HOOK_OK;
 }
 
-#ifdef HAVE_BLUEZ_5_NATIVE_HEADSET
-const char *default_headset_backend = "auto";
-#else
-const char *default_headset_backend = "ofono";
-#endif
-
 int pa__init(pa_module *m) {
     struct userdata *u;
     pa_modargs *ma;
-    const char *headset_str;
-    int headset_backend;
-    bool autodetect_mtu;
 
     pa_assert(m);
 
-    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+    if (!(ma = pa_modargs_new(m->argument, NULL))) {
         pa_log("failed to parse module arguments.");
         goto fail;
     }
 
-    pa_assert_se(headset_str = pa_modargs_get_value(ma, "headset", default_headset_backend));
-    if (pa_streq(headset_str, "ofono"))
-        headset_backend = HEADSET_BACKEND_OFONO;
-    else if (pa_streq(headset_str, "native"))
-        headset_backend = HEADSET_BACKEND_NATIVE;
-    else if (pa_streq(headset_str, "auto"))
-        headset_backend = HEADSET_BACKEND_AUTO;
-    else {
-        pa_log("headset parameter must be either ofono, native or auto (found %s)", headset_str);
-        goto fail;
-    }
-
-    autodetect_mtu = false;
-    if (pa_modargs_get_value_boolean(ma, "autodetect_mtu", &autodetect_mtu) < 0) {
-        pa_log("Invalid boolean value for autodetect_mtu parameter");
-        goto fail;
-    }
-
     m->userdata = u = pa_xnew0(struct userdata, 1);
     u->module = m;
     u->core = m->core;
-    u->autodetect_mtu = autodetect_mtu;
     u->loaded_device_paths = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
 
-    if (!(u->discovery = pa_bluetooth_discovery_get(u->core, headset_backend)))
+    if (!(u->discovery = pa_bluetooth_discovery_get(u->core)))
         goto fail;
 
     u->device_connection_changed_slot =
